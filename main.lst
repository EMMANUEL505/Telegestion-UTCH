CCS PCD C Compiler, Version 4.104, 5967               06-Aug-15 20:00

               Filename: C:\Users\e882742\Documents\TELEGESTION\dsPIC software\main.lst

               ROM used: 13414 bytes (30%)
                         Largest free fragment is 31642
               RAM used: 554 (27%) at main() level
                         586 (29%) worst case
               Stack:    7 locations

*
0000:  GOTO    2A82
.................... /******************Configuration file********************/ 
.................... #include "Config.h" 
.................... #include <30f5015.h> 
.................... //////// Standard Header file for the DSPIC30F5015 device //////////////// 
.................... #device DSPIC30F5015 
.................... #list 
....................  
....................  
.................... #device ADC=10 
.................... #fuses FRC_PLL4, NOWRT, NOPROTECT, NOWDT, NOBROWNOUT, NOMCLR 
.................... #use delay(clock=29480000)  
*
074E:  CP0     W0
0750:  BTSC.B  42.1
0752:  BRA     75C
0754:  REPEAT  #1CC3
0756:  NOP     
0758:  DEC     W0,W0
075A:  BRA     74E
075C:  RETURN  
*
1F88:  LSR     W0,#0,W0
1F8A:  CP0     W0
1F8C:  BTSC.B  42.1
1F8E:  BRA     1F98
1F90:  REPEAT  #34
1F92:  NOP     
1F94:  DEC     W0,W0
1F96:  BRA     1F8A
1F98:  RETURN  
.................... #use rs232(baud=115200,bits=8, xmit=PIN_F3,rcv=PIN_F2, parity=N)//, timeout=2000) 
.................... #byte OERR=0x020E 
.................... #USE FIXED_IO(B_OUTPUTS=PIN_B7,PIN_B8) 
....................  
.................... #define Timmer_Mode     1	//new mode  operation 
.................... #define Automated_Mode  3 
.................... #define Manual_Mode     2 
....................  
.................... #define Lamp_On         1 
.................... #define Lamp_Off        0 
....................  
.................... #define day_             0 
.................... #define month_           1 
.................... #define year_            2 
.................... #define hour_            3 
.................... #define min_             4 
.................... #define sec_             5 
....................  
.................... #define RoboCable			1 
.................... #define RoboEnergia			2 
.................... #define LamparaFundida		3 
....................  
.................... #define LCD_Delay			2000 
....................  
.................... #define TEMP_ch				0 
.................... #define CURRENT_ch			1 
.................... #define AN2_ch				2 
.................... #define SENSOR1_ch			3 
.................... #define SENSOR2_ch			4 
.................... #define POWER_ch			5 
.................... #define REFERENCE_ch		6 
....................  
.................... /******************Include files*************************/ 
.................... #include "DS1302_2.c"		//Driver for Real Time Clock  
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_D5 
.................... #define RTC_IO   PIN_D6 
.................... #define RTC_RST  PIN_D4 
....................  
.................... #endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
08FC:  CLR.B   9B9
08FE:  MOV     9B8,W4
0900:  LSR     W4,#8,W4
0902:  CP.B    W4L,#7
0904:  BRA     GTU,920
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
0906:  BCLR.B  42.0
0908:  RRC.B   9B8
090A:  BRA     C,910
090C:  BCLR.B  2D6.6
090E:  BRA     912
0910:  BSET.B  2D6.6
0912:  BCLR.B  2D2.6
....................       output_high(RTC_SCLK); 
0914:  BCLR.B  2D2.5
0916:  BSET.B  2D6.5
....................       output_low(RTC_SCLK); 
0918:  BCLR.B  2D2.5
091A:  BCLR.B  2D6.5
....................    } 
091C:  INC.B   09B9
091E:  BRA     8FE
.................... } 
0920:  RETURN  
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
0922:  BCLR.B  2D2.4
0924:  BSET.B  2D6.4
....................    write_ds1302_byte(cmd); 
0926:  MOV.B   9B4,W0L
0928:  MOV.B   W0L,9B8
092A:  CALL    8FC
....................    write_ds1302_byte(data); 
092E:  MOV.B   9B5,W0L
0930:  MOV.B   W0L,9B8
0932:  CALL    8FC
....................    output_low(RTC_RST); 
0936:  BCLR.B  2D2.4
0938:  BCLR.B  2D6.4
.................... } 
093A:  RETURN  
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
093C:  BCLR.B  2D2.4
093E:  BSET.B  2D6.4
....................    write_ds1302_byte(cmd); 
0940:  MOV.B   9AA,W0L
0942:  MOV.B   W0L,9B8
0944:  CALL    8FC
....................     
....................    input(RTC_IO); 
0948:  BSET.B  2D2.6
....................    delay_us(1); 
094A:  REPEAT  #5
094C:  NOP     
....................           
....................    for(i=0;i<=7;++i) { 
094E:  CLR.B   9AB
0950:  MOV     9AA,W4
0952:  LSR     W4,#8,W4
0954:  CP.B    W4L,#7
0956:  BRA     GTU,97A
....................       shift_right(&data,1,input(RTC_IO)); 
0958:  BSET.B  2D2.6
095A:  BTSC.B  2D4.6
095C:  BRA     962
095E:  BCLR.B  42.0
0960:  BRA     964
0962:  BSET.B  42.0
0964:  RRC.B   9AC
....................       output_high(RTC_SCLK); 
0966:  BCLR.B  2D2.5
0968:  BSET.B  2D6.5
....................       delay_us(2); 
096A:  REPEAT  #C
096C:  NOP     
....................       output_low(RTC_SCLK); 
096E:  BCLR.B  2D2.5
0970:  BCLR.B  2D6.5
....................       delay_us(2); 
0972:  REPEAT  #C
0974:  NOP     
....................    } 
0976:  INC.B   09AB
0978:  BRA     950
....................    output_low(RTC_RST); 
097A:  BCLR.B  2D2.4
097C:  BCLR.B  2D6.4
....................  
....................    return(data); 
097E:  MOV.B   9AC,W0L
0980:  MOV.B   W0L,0
.................... } 
0982:  RETURN  
....................  
.................... void rtc_init() { 
0984:  MOV     W5,[W15++]
....................    BYTE x; 
....................    output_low(RTC_RST); 
0986:  BCLR.B  2D2.4
0988:  BCLR.B  2D6.4
....................    delay_us(2); 
098A:  REPEAT  #C
098C:  NOP     
....................    output_low(RTC_SCLK); 
098E:  BCLR.B  2D2.5
0990:  BCLR.B  2D6.5
....................    write_ds1302(0x8e,0); 
0992:  MOV.B   #8E,W0L
0994:  MOV.B   W0L,9B4
0996:  CLR.B   9B5
0998:  CALL    922
....................    write_ds1302(0x90,0xa4); 
099C:  MOV.B   #90,W0L
099E:  MOV.B   W0L,9B4
09A0:  MOV.B   #A4,W0L
09A2:  MOV.B   W0L,9B5
09A4:  CALL    922
....................    x=read_ds1302(0x81); 
09A8:  MOV.B   #81,W0L
09AA:  MOV.B   W0L,9AA
09AC:  CALL    93C
09B0:  MOV.B   W0L,9A6
....................    if((x & 0x80)!=0) 
09B2:  MOV.B   9A6,W0L
09B4:  AND.B   #80,W0L
09B6:  CP0.B   W0L
09B8:  BRA     Z,9C4
....................      write_ds1302(0x80,0); 
09BA:  MOV.B   #80,W0L
09BC:  MOV.B   W0L,9B4
09BE:  CLR.B   9B5
09C0:  CALL    922
.................... } 
09C4:  MOV     [--W15],W5
09C6:  RETURN  
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
*
10AC:  MOV     W5,[W15++]
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
10AE:  MOV     9B2,W4
10B0:  CLR.B   9
10B2:  MOV     #A,W3
10B4:  REPEAT  #11
10B6:  DIV.U   W4,W3
10B8:  MOV.B   W0L,9B3
....................    nibl=data-(nibh*10); 
10BA:  MOV     9B2,W4
10BC:  LSR     W4,#8,W4
10BE:  MUL.UU  W4,#A,W0
10C0:  MOV     9B2,W4
10C2:  SUB.B   W4L,W0L,W0L
10C4:  MOV.B   W0L,9B4
....................  
....................    return((nibh<<4)|nibl); 
10C6:  MOV.B   9B3,W0L
10C8:  SL      W0,#4,W0
10CA:  IOR.B   9B4,W0L
.................... } 
10CC:  MOV     [--W15],W5
10CE:  RETURN  
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
*
1F62:  MOV     W5,[W15++]
....................    byte i; 
....................  
....................    i=data; 
1F64:  MOV.B   9AC,W0L
1F66:  MOV.B   W0L,9AD
....................    data=(i>>4)*10; 
1F68:  MOV.B   9AD,W0L
1F6A:  CLR.B   1
1F6C:  LSR     W0,#4,W0
1F6E:  MOV.B   W0L,W4L
1F70:  CLR.B   9
1F72:  MUL.UU  W4,#A,W0
1F74:  MOV.B   W0L,9AC
....................    data=data+(i<<4>>4); 
1F76:  MOV.B   9AD,W0L
1F78:  SL      W0,#4,W0
1F7A:  CLR.B   1
1F7C:  LSR     W0,#4,W0
1F7E:  ADD.B   9AC
....................  
....................    return data; 
1F80:  MOV.B   9AC,W0L
1F82:  MOV.B   W0L,0
.................... } 
1F84:  MOV     [--W15],W5
1F86:  RETURN  
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
*
10D0:  MOV     W5,[W15++]
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
10D2:  MOV.B   9A6,W0L
10D4:  MOV.B   W0L,9B2
10D6:  CALL    10AC
10DA:  MOV.B   W0L,W5L
10DC:  MOV.B   #86,W0L
10DE:  MOV.B   W0L,9B4
10E0:  MOV.B   W5L,W0L
10E2:  MOV.B   W0L,9B5
10E4:  CALL    922
....................    write_ds1302(0x88,get_bcd(mth)); 
10E8:  MOV.B   9A7,W0L
10EA:  MOV.B   W0L,9B2
10EC:  CALL    10AC
10F0:  MOV.B   W0L,W5L
10F2:  MOV.B   #88,W0L
10F4:  MOV.B   W0L,9B4
10F6:  MOV.B   W5L,W0L
10F8:  MOV.B   W0L,9B5
10FA:  CALL    922
....................    write_ds1302(0x8c,get_bcd(year)); 
10FE:  MOV.B   9A8,W0L
1100:  MOV.B   W0L,9B2
1102:  CALL    10AC
1106:  MOV.B   W0L,W5L
1108:  MOV.B   #8C,W0L
110A:  MOV.B   W0L,9B4
110C:  MOV.B   W5L,W0L
110E:  MOV.B   W0L,9B5
1110:  CALL    922
....................    write_ds1302(0x8a,get_bcd(dow)); 
1114:  MOV.B   9A9,W0L
1116:  MOV.B   W0L,9B2
1118:  CALL    10AC
111C:  MOV.B   W0L,W5L
111E:  MOV.B   #8A,W0L
1120:  MOV.B   W0L,9B4
1122:  MOV.B   W5L,W0L
1124:  MOV.B   W0L,9B5
1126:  CALL    922
....................    write_ds1302(0x84,get_bcd(hr)); 
112A:  MOV.B   9AA,W0L
112C:  MOV.B   W0L,9B2
112E:  CALL    10AC
1132:  MOV.B   W0L,W5L
1134:  MOV.B   #84,W0L
1136:  MOV.B   W0L,9B4
1138:  MOV.B   W5L,W0L
113A:  MOV.B   W0L,9B5
113C:  CALL    922
....................    write_ds1302(0x82,get_bcd(min)); 
1140:  MOV.B   9AB,W0L
1142:  MOV.B   W0L,9B2
1144:  CALL    10AC
1148:  MOV.B   W0L,W5L
114A:  MOV.B   #82,W0L
114C:  MOV.B   W0L,9B4
114E:  MOV.B   W5L,W0L
1150:  MOV.B   W0L,9B5
1152:  CALL    922
....................    write_ds1302(0x80,get_bcd(0)); 
1156:  CLR.B   9B2
1158:  CALL    10AC
115C:  MOV.B   W0L,W5L
115E:  MOV.B   #80,W0L
1160:  MOV.B   W0L,9B4
1162:  MOV.B   W5L,W0L
1164:  MOV.B   W0L,9B5
1166:  CALL    922
.................... } 
116A:  MOV     [--W15],W5
116C:  RETURN  
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
2FC6:  MOV.B   #87,W0L
2FC8:  MOV.B   W0L,9AA
2FCA:  CALL    93C
2FCE:  MOV.B   W0L,W5L
2FD0:  PUSH    9AC
2FD2:  MOV.B   W5L,[W15-#2]
2FD4:  POP     9AC
2FD6:  CALL    1F62
2FDA:  MOV.B   W0L,992
....................    mth = rm_bcd(read_ds1302(0x89)); 
2FDC:  MOV.B   #89,W0L
2FDE:  MOV.B   W0L,9AA
2FE0:  CALL    93C
2FE4:  MOV.B   W0L,W5L
2FE6:  PUSH    9AC
2FE8:  MOV.B   W5L,[W15-#2]
2FEA:  POP     9AC
2FEC:  CALL    1F62
2FF0:  MOV.B   W0L,993
....................    year = rm_bcd(read_ds1302(0x8d)); 
2FF2:  MOV.B   #8D,W0L
2FF4:  MOV.B   W0L,9AA
2FF6:  CALL    93C
2FFA:  MOV.B   W0L,W5L
2FFC:  PUSH    9AC
2FFE:  MOV.B   W5L,[W15-#2]
3000:  POP     9AC
3002:  CALL    1F62
3006:  MOV.B   W0L,994
....................    dow = rm_bcd(read_ds1302(0x8b)); 
3008:  MOV.B   #8B,W0L
300A:  MOV.B   W0L,9AA
300C:  CALL    93C
3010:  MOV.B   W0L,W5L
3012:  PUSH    9AC
3014:  MOV.B   W5L,[W15-#2]
3016:  POP     9AC
3018:  CALL    1F62
301C:  MOV.B   W0L,998
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
301E:  MOV.B   #85,W0L
3020:  MOV.B   W0L,9AA
3022:  CALL    93C
3026:  MOV.B   W0L,W5L
3028:  PUSH    9AC
302A:  MOV.B   W5L,[W15-#2]
302C:  POP     9AC
302E:  CALL    1F62
3032:  MOV.B   W0L,995
....................    min = rm_bcd(read_ds1302(0x83)); 
3034:  MOV.B   #83,W0L
3036:  MOV.B   W0L,9AA
3038:  CALL    93C
303C:  MOV.B   W0L,W5L
303E:  PUSH    9AC
3040:  MOV.B   W5L,[W15-#2]
3042:  POP     9AC
3044:  CALL    1F62
3048:  MOV.B   W0L,996
....................    sec = rm_bcd(read_ds1302(0x81)); 
304A:  MOV.B   #81,W0L
304C:  MOV.B   W0L,9AA
304E:  CALL    93C
3052:  MOV.B   W0L,W5L
3054:  PUSH    9AC
3056:  MOV.B   W5L,[W15-#2]
3058:  POP     9AC
305A:  CALL    1F62
305E:  MOV.B   W0L,997
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... //#include "mcp4921_DSPIC.c" 
.................... #include "lcd_2.c"			//Driver for common LCD modules    
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
....................      #define LCD_ENABLE_PIN  PIN_B12                                   //// 
....................      #define LCD_RS_PIN      PIN_B10                                    ////     
....................      #define LCD_RW_PIN      PIN_B11                                    //// 
....................      #define LCD_DATA4       PIN_D0                                    //// 
....................      #define LCD_DATA5       PIN_D1                                    //// 
....................      #define LCD_DATA6       PIN_D2                                    //// 
....................      #define LCD_DATA7       PIN_D3  
....................  
....................  
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
*
07DC:  MOV     W5,[W15++]
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
07DE:  BSET.B  2D2.0
....................    output_float(LCD_DATA5); 
07E0:  BSET.B  2D2.1
....................    output_float(LCD_DATA6); 
07E2:  BSET.B  2D2.2
....................    output_float(LCD_DATA7); 
07E4:  BSET.B  2D2.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
07E6:  BSET.B  2CB.3
07E8:  MOV     #7E,W4
07EA:  MOV     W4,2C6
....................    delay_cycles(1); 
07EC:  NOP     
....................    lcd_output_enable(1); 
07EE:  BSET.B  2CB.4
07F0:  MOV     #7E,W4
07F2:  MOV     W4,2C6
....................    delay_cycles(1); 
07F4:  NOP     
....................    high = lcd_read_nibble(); 
07F6:  CALL    7A2
07FA:  MOV.B   W0L,9C9
....................        
....................    lcd_output_enable(0); 
07FC:  BCLR.B  2CB.4
07FE:  MOV     #7E,W4
0800:  MOV     W4,2C6
....................    delay_cycles(1); 
0802:  NOP     
....................    lcd_output_enable(1); 
0804:  BSET.B  2CB.4
0806:  MOV     #7E,W4
0808:  MOV     W4,2C6
....................    delay_us(1); 
080A:  REPEAT  #5
080C:  NOP     
....................    low = lcd_read_nibble(); 
080E:  CALL    7A2
0812:  MOV.B   W0L,9C8
....................        
....................    lcd_output_enable(0); 
0814:  BCLR.B  2CB.4
0816:  MOV     #7E,W4
0818:  MOV     W4,2C6
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
081A:  BCLR.B  2D2.0
....................    output_drive(LCD_DATA5); 
081C:  BCLR.B  2D2.1
....................    output_drive(LCD_DATA6); 
081E:  BCLR.B  2D2.2
....................    output_drive(LCD_DATA7); 
0820:  BCLR.B  2D2.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0822:  MOV.B   9C9,W0L
0824:  SL      W0,#4,W0
0826:  IOR.B   9C8,W0L
.................... } 
0828:  MOV     [--W15],W5
082A:  RETURN  
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
07A2:  MOV     W5,[W15++]
07A4:  CLR.B   9CA
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
07A6:  BSET.B  2D2.0
07A8:  CLR.B   W0
07AA:  BTSC.B  2D4.0
07AC:  INC     W0,W0
07AE:  IOR.B   9CA
....................    n |= input(LCD_DATA5) << 1; 
07B0:  BSET.B  2D2.1
07B2:  CLR.B   W0
07B4:  BTSC.B  2D4.1
07B6:  INC     W0,W0
07B8:  SL      W0,#1,W0
07BA:  IOR.B   9CA
....................    n |= input(LCD_DATA6) << 2; 
07BC:  BSET.B  2D2.2
07BE:  CLR.B   W0
07C0:  BTSC.B  2D4.2
07C2:  INC     W0,W0
07C4:  SL      W0,#2,W0
07C6:  IOR.B   9CA
....................    n |= input(LCD_DATA7) << 3; 
07C8:  BSET.B  2D2.3
07CA:  CLR.B   W0
07CC:  BTSC.B  2D4.3
07CE:  INC     W0,W0
07D0:  SL      W0,#3,W0
07D2:  IOR.B   9CA
....................     
....................    return(n); 
07D4:  MOV.B   9CA,W0L
07D6:  MOV.B   W0L,0
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
07D8:  MOV     [--W15],W5
07DA:  RETURN  
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
075E:  BTSC.B  9CA.0
0760:  BRA     766
0762:  BCLR.B  2D6.0
0764:  BRA     768
0766:  BSET.B  2D6.0
0768:  BCLR.B  2D2.0
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
076A:  BTSC.B  9CA.1
076C:  BRA     772
076E:  BCLR.B  2D6.1
0770:  BRA     774
0772:  BSET.B  2D6.1
0774:  BCLR.B  2D2.1
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0776:  BTSC.B  9CA.2
0778:  BRA     77E
077A:  BCLR.B  2D6.2
077C:  BRA     780
077E:  BSET.B  2D6.2
0780:  BCLR.B  2D2.2
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
0782:  BTSC.B  9CA.3
0784:  BRA     78A
0786:  BCLR.B  2D6.3
0788:  BRA     78C
078A:  BSET.B  2D6.3
078C:  BCLR.B  2D2.3
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
078E:  NOP     
....................    lcd_output_enable(1); 
0790:  BSET.B  2CB.4
0792:  MOV     #7E,W4
0794:  MOV     W4,2C6
....................    delay_us(2); 
0796:  REPEAT  #C
0798:  NOP     
....................    lcd_output_enable(0); 
079A:  BCLR.B  2CB.4
079C:  MOV     #7E,W4
079E:  MOV     W4,2C6
.................... } 
07A0:  RETURN  
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
*
082C:  MOV     W5,[W15++]
....................    lcd_output_rs(0); 
082E:  BCLR.B  2CB.2
0830:  MOV     #7E,W4
0832:  MOV     W4,2C6
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
0834:  CALL    7DC
0838:  MOV.B   W0L,W5L
083A:  BTSC    W5.7
083C:  BRA     834
....................    lcd_output_rs(address); 
083E:  CP0.B   9C4
0840:  BRA     NZ,846
0842:  BCLR.B  2CB.2
0844:  BRA     848
0846:  BSET.B  2CB.2
0848:  MOV     #7E,W4
084A:  MOV     W4,2C6
....................    delay_cycles(1); 
084C:  NOP     
....................    lcd_output_rw(0); 
084E:  BCLR.B  2CB.3
0850:  MOV     #7E,W4
0852:  MOV     W4,2C6
....................    delay_cycles(1); 
0854:  NOP     
....................    lcd_output_enable(0); 
0856:  BCLR.B  2CB.4
0858:  MOV     #7E,W4
085A:  MOV     W4,2C6
....................    lcd_send_nibble(n >> 4); 
085C:  MOV     9C4,W5
085E:  LSR     W5,#8,W5
0860:  CLR.B   B
0862:  LSR     W5,#4,W5
0864:  PUSH    9CA
0866:  MOV.B   W5L,[W15-#2]
0868:  POP     9CA
086A:  CALL    75E
....................    lcd_send_nibble(n & 0xf); 
086E:  MOV.B   9C5,W0L
0870:  AND.B   W0L,#F,W5L
0872:  PUSH    9CA
0874:  MOV.B   W5L,[W15-#2]
0876:  POP     9CA
0878:  CALL    75E
.................... } 
087C:  MOV     [--W15],W5
087E:  RETURN  
....................  
.................... void lcd_init(void)  
.................... { 
0880:  MOV     W5,[W15++]
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0882:  BCLR.B  2D2.0
....................    output_drive(LCD_DATA5); 
0884:  BCLR.B  2D2.1
....................    output_drive(LCD_DATA6); 
0886:  BCLR.B  2D2.2
....................    output_drive(LCD_DATA7); 
0888:  BCLR.B  2D2.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
088A:  MOV     #7E,W4
088C:  MOV     W4,2C6
....................    lcd_rs_tris(); 
088E:  MOV     #7E,W4
0890:  MOV     W4,2C6
....................    lcd_rw_tris(); 
0892:  MOV     #7E,W4
0894:  MOV     W4,2C6
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0896:  BCLR.B  2CB.2
0898:  MOV     #7E,W4
089A:  MOV     W4,2C6
....................    lcd_output_rw(0); 
089C:  BCLR.B  2CB.3
089E:  MOV     #7E,W4
08A0:  MOV     W4,2C6
....................    lcd_output_enable(0); 
08A2:  BCLR.B  2CB.4
08A4:  MOV     #7E,W4
08A6:  MOV     W4,2C6
....................      
....................    delay_ms(15); 
08A8:  MOV     #F,W0
08AA:  CALL    74E
....................    for(i=1;i<=3;++i) 
08AE:  MOV.B   #1,W0L
08B0:  MOV.B   W0L,9A6
08B2:  MOV     9A6,W4
08B4:  CP.B    W4L,#3
08B6:  BRA     GTU,8D0
....................    { 
....................        lcd_send_nibble(3); 
08B8:  MOV.B   #3,W0L
08BA:  MOV.B   W0L,9CA
08BC:  CALL    75E
....................        delay_ms(5); 
08C0:  REPEAT  #FF0
08C2:  NOP     
08C4:  REPEAT  #3FFF
08C6:  NOP     
08C8:  REPEAT  #3FFF
08CA:  NOP     
....................    } 
08CC:  INC.B   09A6
08CE:  BRA     8B2
....................      
....................    lcd_send_nibble(2); 
08D0:  MOV.B   #2,W0L
08D2:  MOV.B   W0L,9CA
08D4:  CALL    75E
....................    for(i=0;i<=3;++i) 
08D8:  CLR.B   9A6
08DA:  MOV     9A6,W4
08DC:  CP.B    W4L,#3
08DE:  BRA     GTU,8F8
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
08E0:  MOV.B   9A6,W0L
08E2:  CLR.B   1
08E4:  CALL    100
08E8:  MOV.B   W0L,W5L
08EA:  CLR.B   9C4
08EC:  MOV.B   W5L,W0L
08EE:  MOV.B   W0L,9C5
08F0:  CALL    82C
08F4:  INC.B   09A6
08F6:  BRA     8DA
.................... } 
08F8:  MOV     [--W15],W5
08FA:  RETURN  
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
*
09C8:  MOV     W5,[W15++]
....................    BYTE address; 
....................  
....................    if(y!=1) 
09CA:  MOV     9BE,W4
09CC:  LSR     W4,#8,W4
09CE:  CP.B    W4L,#1
09D0:  BRA     Z,9D8
....................       address=LCD_LINE_TWO; 
09D2:  MOV.B   #40,W0L
09D4:  MOV.B   W0L,9C0
....................    else 
09D6:  BRA     9DA
....................       address=0; 
09D8:  CLR.B   9C0
....................       
....................    address+=x-1; 
09DA:  MOV     9BE,W4
09DC:  SUB.B   W4L,#1,W0L
09DE:  ADD.B   9C0
....................    lcd_send_byte(0,0x80|address); 
09E0:  MOV     9C0,W5
09E2:  IOR.B   #80,W5L
09E4:  CLR.B   9C4
09E6:  MOV.B   W5L,W0L
09E8:  MOV.B   W0L,9C5
09EA:  CALL    82C
.................... } 
09EE:  MOV     [--W15],W5
09F0:  RETURN  
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
09F2:  MOV.B   9BC,W0L
09F4:  CLR.B   1
09F6:  XOR     #C,W0
09F8:  BRA     Z,A04
09FA:  XOR     #6,W0
09FC:  BRA     Z,A14
09FE:  XOR     #2,W0
0A00:  BRA     Z,A22
0A02:  BRA     A2E
....................       case '\f'   :  lcd_send_byte(0,1); 
0A04:  CLR.B   9C4
0A06:  MOV.B   #1,W0L
0A08:  MOV.B   W0L,9C5
0A0A:  CALL    82C
....................                      delay_ms(2); 
0A0E:  REPEAT  #3992
0A10:  NOP     
....................                      break; 
0A12:  BRA     A3C
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0A14:  MOV.B   #1,W0L
0A16:  MOV.B   W0L,9BE
0A18:  MOV.B   #2,W0L
0A1A:  MOV.B   W0L,9BF
0A1C:  CALL    9C8
0A20:  BRA     A3C
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0A22:  CLR.B   9C4
0A24:  MOV.B   #10,W0L
0A26:  MOV.B   W0L,9C5
0A28:  CALL    82C
0A2C:  BRA     A3C
....................       
....................       default     : lcd_send_byte(1,c);     break; 
0A2E:  MOV.B   #1,W0L
0A30:  MOV.B   W0L,9C4
0A32:  MOV.B   9BC,W0L
0A34:  MOV.B   W0L,9C5
0A36:  CALL    82C
0A3A:  BRA     A3C
....................    } 
.................... } 
0A3C:  RETURN  
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... #include "ADH8066.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             ADH8066.C                                 //// 
.................... ////                 Driver for ADH8066 GPRS modules                       //// 
.................... ////                                                                       //// 
.................... ////  StringToHex(Str,size,result)                                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2014  Adolfo Emmanuel Sigala Villa           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************Global definitions********************/ 
.................... //#define AT "AT+" 
.................... //#define CPIN "CPIN?\r\n" 
.................... //#define AIPDCONT "AIPDCONT=\"INTERNET.MOVISTAR.MX\",\"MOVISTAR\",\"MOVISTAR\"\r\n" 
.................... //#define AIPO "AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n" 
.................... //#define HOST "HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n" 
....................  
.................... #define Buzzer_delay	200 
.................... #define Buzzer_On		1 
.................... #define Buzzer_Off      0 
.................... extern float current,battery,temp,s1,s2,reference; 
.................... /******************Variable and constant definitions*****/ 
.................... const char hexcode[17]="0123456789abcdef"; 
....................  
.................... char InputBuffer[350]={0}; 
*
2AD4:  CLR     818
2AD6:  CLR     81A
2AD8:  CLR     81C
2ADA:  CLR     81E
2ADC:  CLR     820
2ADE:  CLR     822
2AE0:  CLR     824
2AE2:  CLR     826
2AE4:  CLR     828
2AE6:  CLR     82A
2AE8:  CLR     82C
2AEA:  CLR     82E
2AEC:  CLR     830
2AEE:  CLR     832
2AF0:  CLR     834
2AF2:  CLR     836
2AF4:  CLR     838
2AF6:  CLR     83A
2AF8:  CLR     83C
2AFA:  CLR     83E
2AFC:  CLR     840
2AFE:  CLR     842
2B00:  CLR     844
2B02:  CLR     846
2B04:  CLR     848
2B06:  CLR     84A
2B08:  CLR     84C
2B0A:  CLR     84E
2B0C:  CLR     850
2B0E:  CLR     852
2B10:  CLR     854
2B12:  CLR     856
2B14:  CLR     858
2B16:  CLR     85A
2B18:  CLR     85C
2B1A:  CLR     85E
2B1C:  CLR     860
2B1E:  CLR     862
2B20:  CLR     864
2B22:  CLR     866
2B24:  CLR     868
2B26:  CLR     86A
2B28:  CLR     86C
2B2A:  CLR     86E
2B2C:  CLR     870
2B2E:  CLR     872
2B30:  CLR     874
2B32:  CLR     876
2B34:  CLR     878
2B36:  CLR     87A
2B38:  CLR     87C
2B3A:  CLR     87E
2B3C:  CLR     880
2B3E:  CLR     882
2B40:  CLR     884
2B42:  CLR     886
2B44:  CLR     888
2B46:  CLR     88A
2B48:  CLR     88C
2B4A:  CLR     88E
2B4C:  CLR     890
2B4E:  CLR     892
2B50:  CLR     894
2B52:  CLR     896
2B54:  CLR     898
2B56:  CLR     89A
2B58:  CLR     89C
2B5A:  CLR     89E
2B5C:  CLR     8A0
2B5E:  CLR     8A2
2B60:  CLR     8A4
2B62:  CLR     8A6
2B64:  CLR     8A8
2B66:  CLR     8AA
2B68:  CLR     8AC
2B6A:  CLR     8AE
2B6C:  CLR     8B0
2B6E:  CLR     8B2
2B70:  CLR     8B4
2B72:  CLR     8B6
2B74:  CLR     8B8
2B76:  CLR     8BA
2B78:  CLR     8BC
2B7A:  CLR     8BE
2B7C:  CLR     8C0
2B7E:  CLR     8C2
2B80:  CLR     8C4
2B82:  CLR     8C6
2B84:  CLR     8C8
2B86:  CLR     8CA
2B88:  CLR     8CC
2B8A:  CLR     8CE
2B8C:  CLR     8D0
2B8E:  CLR     8D2
2B90:  CLR     8D4
2B92:  CLR     8D6
2B94:  CLR     8D8
2B96:  CLR     8DA
2B98:  CLR     8DC
2B9A:  CLR     8DE
2B9C:  CLR     8E0
2B9E:  CLR     8E2
2BA0:  CLR     8E4
2BA2:  CLR     8E6
2BA4:  CLR     8E8
2BA6:  CLR     8EA
2BA8:  CLR     8EC
2BAA:  CLR     8EE
2BAC:  CLR     8F0
2BAE:  CLR     8F2
2BB0:  CLR     8F4
2BB2:  CLR     8F6
2BB4:  CLR     8F8
2BB6:  CLR     8FA
2BB8:  CLR     8FC
2BBA:  CLR     8FE
2BBC:  CLR     900
2BBE:  CLR     902
2BC0:  CLR     904
2BC2:  CLR     906
2BC4:  CLR     908
2BC6:  CLR     90A
2BC8:  CLR     90C
2BCA:  CLR     90E
2BCC:  CLR     910
2BCE:  CLR     912
2BD0:  CLR     914
2BD2:  CLR     916
2BD4:  CLR     918
2BD6:  CLR     91A
2BD8:  CLR     91C
2BDA:  CLR     91E
2BDC:  CLR     920
2BDE:  CLR     922
2BE0:  CLR     924
2BE2:  CLR     926
2BE4:  CLR     928
2BE6:  CLR     92A
2BE8:  CLR     92C
2BEA:  CLR     92E
2BEC:  CLR     930
2BEE:  CLR     932
2BF0:  CLR     934
2BF2:  CLR     936
2BF4:  CLR     938
2BF6:  CLR     93A
2BF8:  CLR     93C
2BFA:  CLR     93E
2BFC:  CLR     940
2BFE:  CLR     942
2C00:  CLR     944
2C02:  CLR     946
2C04:  CLR     948
2C06:  CLR     94A
2C08:  CLR     94C
2C0A:  CLR     94E
2C0C:  CLR     950
2C0E:  CLR     952
2C10:  CLR     954
2C12:  CLR     956
2C14:  CLR     958
2C16:  CLR     95A
2C18:  CLR     95C
2C1A:  CLR     95E
2C1C:  CLR     960
2C1E:  CLR     962
2C20:  CLR     964
2C22:  CLR     966
2C24:  CLR     968
2C26:  CLR     96A
2C28:  CLR     96C
2C2A:  CLR     96E
2C2C:  CLR     970
2C2E:  CLR     972
2C30:  CLR     974
.................... int16 ptime=100; 
....................  
.................... /***********StringToHex*********************************** 
.................... **   Description: This function converts a string in    ** 
.................... **     their hex codification                           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void StringToHex(char* str,unsigned int size,char* result) 
.................... { 
.................... 	int index=0,aux=0,aux2=0; 
.................... 	for(index=0;index<size;index++) 
.................... 		{ 
.................... 			aux=*(str+index); 
.................... 			aux2=aux/16; 
.................... 			*(result+(index*2))=hexcode[aux2]; 
.................... 			if(aux>15) 
.................... 				{ 
.................... 					aux=aux-(aux2*16); 
.................... 				} 
.................... 			*(result+((index*2)+1))=hexcode[aux];	 
.................... 		} 
.................... } 
....................  
.................... /***********FillArray************************************* 
.................... **   Description: Function used to fill an array with   ** 
.................... **     value of (val) variable                          ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void FillArray(char* arrayval,int size,char val) 
.................... { 
*
0A3E:  MOV     W5,[W15++]
0A40:  CLR     9C4
.................... 	int index=0; 
.................... 	for(index=0;index<size;index++) 
0A42:  CLR     9C4
0A44:  MOV     9C4,W0
0A46:  MOV     9C0,W4
0A48:  CP      W4,W0
0A4A:  BRA     LE,A5A
.................... 	{ 
.................... 		*(arrayval+index)=val; 
0A4C:  MOV     9BE,W0
0A4E:  ADD     9C4,W0
0A50:  MOV     W0,W5
0A52:  MOV.B   9C2,W0L
0A54:  MOV.B   W0L,[W5+#0]
.................... 	} 
0A56:  INC     09C4
0A58:  BRA     A44
.................... } 
0A5A:  MOV     [--W15],W5
0A5C:  RETURN  
....................  
.................... /***********ReadBuffer************************************ 
.................... **   Description: Reads incoming characters until arrive** 
.................... **     a carriage return '\r' and save the buffer in    ** 
.................... **       *buffer array                                  ** 
.................... *********************************************************/ 
.................... void ReadBuffer(char* buffer) 
.................... { 
0A5E:  MOV     W5,[W15++]
0A60:  CLR     9C0
.................... 	int16 index=0; 
.................... 	OERR=16; 
0A62:  MOV.B   #10,W0L
0A64:  MOV.B   W0L,20E
.................... 	//******Get incoming buffer data****** 
.................... 	while(getc()!='\n'); 
0A66:  BTSS.B  20E.0
0A68:  BRA     A66
0A6A:  MOV     212,W0
0A6C:  CP.B    W0L,#A
0A6E:  BRA     NZ,A66
....................     do 
....................     { 
....................        *(buffer+index)=getc();	 
0A70:  MOV     9BE,W0
0A72:  ADD     9C0,W0
0A74:  MOV     W0,W5
0A76:  BTSS.B  20E.0
0A78:  BRA     A76
0A7A:  MOV     212,W0
0A7C:  MOV.B   W0L,[W5]
.................... 		index++; 
0A7E:  INC     09C0
....................     }while(index<350 && *(buffer+index-1)!='\r'); 
0A80:  MOV     9C0,W4
0A82:  MOV     #15E,W3
0A84:  CP      W3,W4
0A86:  BRA     LE,A96
0A88:  MOV     9BE,W0
0A8A:  ADD     9C0,W0
0A8C:  MOV     W0,W5
0A8E:  SUB     W5,#1,W0
0A90:  MOV.B   [W0],W4L
0A92:  CP.B    W4L,#D
0A94:  BRA     NZ,A70
....................  
.................... 	//***Buzzer sound when receive******** 
....................     //output_bit(PIN_D9,Buzzer_On); 
.................... 	delay_ms(Buzzer_delay); 
0A96:  MOV     #C8,W0
0A98:  CALL    74E
.................... 	//output_bit(PIN_D9,Buzzer_Off); 
.................... 	OERR=16; 
0A9C:  MOV.B   #10,W0L
0A9E:  MOV.B   W0L,20E
....................  
.................... } 
0AA0:  MOV     [--W15],W5
0AA2:  RETURN  
....................  
.................... /***********PrintBuffer*********************************** 
.................... **   Description: Prints in LCD the specified buffer    ** 
.................... **     of characters with a permanency of ms            ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void PrintBuffer(char* buffer,int16 permanency) 
.................... { 
0AA4:  MOV     W5,[W15++]
.................... 	lcd_putc("\f"); 
0AA6:  MOV     #0,W5
0AA8:  MOV     W5,W0
0AAA:  CALL    110
0AAE:  IOR.B   #0,W0L
0AB0:  BTSC.B  42.1
0AB2:  BRA     ABE
0AB4:  INC     W5,W5
0AB6:  MOV.B   W0L,9BC
0AB8:  CALL    9F2
0ABC:  BRA     AA8
....................     printf(lcd_putc,"%s",buffer); 
0ABE:  MOV     9B0,W1
0AC0:  CP0.B   [W1]
0AC2:  BRA     Z,AD4
0AC4:  MOV     W1,[W15++]
0AC6:  MOV.B   [W1+#0],W0L
0AC8:  MOV.B   W0L,9BC
0ACA:  CALL    9F2
0ACE:  MOV     [--W15],W1
0AD0:  INC     W1,W1
0AD2:  BRA     AC0
.................... 	delay_ms(permanency); 
0AD4:  MOV     9B2,W0
0AD6:  CALL    74E
.................... } 
0ADA:  MOV     [--W15],W5
0ADC:  RETURN  
....................  
.................... /***********ValidateCommand******************************* 
.................... **   Description: Validate that input string does not   ** 
.................... **     contains an ERROR                                ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int ValidateCommand(char* cmdstr,int size) 
.................... { 
0ADE:  MOV     W5,[W15++]
0AE0:  CLR     9BE
0AE2:  MOV     #1,W4
0AE4:  MOV     W4,9C0
.................... 	int index=0,result=1; 
.................... 	for(index=0;index<size;index++) 
0AE6:  CLR     9BE
0AE8:  MOV     9BE,W0
0AEA:  MOV     9BC,W4
0AEC:  CP      W4,W0
0AEE:  BRA     LE,B10
.................... 	{ 
.................... 		if(*(cmdstr+index)=='E' && *(cmdstr+(index+1))=='R')  
0AF0:  MOV     9BA,W0
0AF2:  ADD     9BE,W0
0AF4:  MOV.B   [W0],W4L
0AF6:  XOR.B   #45,W4L
0AF8:  BRA     NZ,B0C
0AFA:  MOV     9BE,W4
0AFC:  ADD     W4,#1,W4
0AFE:  MOV     W4,W0
0B00:  MOV     9BA,W4
0B02:  ADD     W0,W4,W0
0B04:  MOV.B   [W0],W4L
0B06:  XOR.B   #52,W4L
0B08:  BRA     NZ,B0C
.................... 		{ 
.................... 			result=0; 
0B0A:  CLR     9C0
.................... 		} 
.................... 	} 
0B0C:  INC     09BE
0B0E:  BRA     AE8
....................     return result; 
0B10:  PUSH    9C0
0B12:  POP     0
.................... } 
0B14:  MOV     [--W15],W5
0B16:  RETURN  
....................  
.................... /***********GetDecVal************************************* 
.................... **   Description: Function used to find a decimal value ** 
.................... **     into string                                      ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int GetDecVal(char* arrayval,int16 size,char stch1,char stch2) 
.................... { 
*
0E64:  MOV     W5,[W15++]
0E66:  CLR     9C4
0E68:  SETM    9C6
.................... 	int16 ind=0; 
....................     int16  value=-1; 
.................... 	while(ind<size && *(arrayval+ind)!='$')// && value==-1) 
.................... 	{ 
0E6A:  MOV     9C4,W0
0E6C:  MOV     9C0,W4
0E6E:  CP      W4,W0
0E70:  BRA     LE,ED2
0E72:  MOV     9BE,W0
0E74:  ADD     9C4,W0
0E76:  MOV.B   [W0],W4L
0E78:  XOR.B   #24,W4L
0E7A:  BRA     Z,ED2
.................... 		if(*(arrayval+ind)==stch1 && *(arrayval+(ind+1))==stch2) 
0E7C:  MOV     9BE,W0
0E7E:  ADD     9C4,W0
0E80:  MOV.B   [W0],W0L
0E82:  CP.B    9C2
0E84:  BRA     NZ,ECE
0E86:  MOV     9C4,W4
0E88:  ADD     W4,#1,W4
0E8A:  MOV     W4,W0
0E8C:  MOV     9BE,W4
0E8E:  ADD     W0,W4,W0
0E90:  MOV.B   [W0],W0L
0E92:  CP.B    9C3
0E94:  BRA     NZ,ECE
.................... 			{ 
.................... 				ind+=2; 
0E96:  MOV     9C4,W4
0E98:  ADD     W4,#2,W4
0E9A:  MOV     W4,9C4
.................... 				value=0; 
0E9C:  CLR     9C6
.................... 				while(*(arrayval+ind)>47 && *(arrayval+ind)<58) 
.................... 					{ 
0E9E:  MOV     9BE,W0
0EA0:  ADD     9C4,W0
0EA2:  MOV     #2F,W4
0EA4:  CP.B    W4L,[W0]
0EA6:  BRA     C,ECE
0EA8:  MOV     9BE,W0
0EAA:  ADD     9C4,W0
0EAC:  MOV.B   [W0],W4L
0EAE:  MOV     #3A,W3
0EB0:  CP.B    W3L,W4L
0EB2:  BRA     LEU,ECE
.................... 						value*=10; 
0EB4:  MOV     9C6,W4
0EB6:  MUL.UU  W4,#A,W0
0EB8:  MOV     W0,9C6
.................... 						value+=(*(arrayval+ind)-48); 
0EBA:  MOV     9BE,W0
0EBC:  ADD     9C4,W0
0EBE:  MOV.B   [W0],W4L
0EC0:  SUB.B   #30,W4L
0EC2:  MOV.B   W4L,W0L
0EC4:  MOV.B   W0L,0
0EC6:  ZE      W0,W0
0EC8:  ADD     9C6
.................... 						ind++; 
0ECA:  INC     09C4
.................... 					} 
0ECC:  BRA     E9E
.................... 			} 
.................... 		ind++; 
0ECE:  INC     09C4
.................... 	} 
0ED0:  BRA     E6A
.................... 	return value; 
0ED2:  PUSH    9C6
0ED4:  POP     0
.................... } 
0ED6:  MOV     [--W15],W5
0ED8:  RETURN  
....................  
.................... /***********ConfigureGPRS********************************* 
.................... **   Description: Function used to configure the GPRS   ** 
.................... **     module to conect it to internet                  ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ConfigureGPRS() 
.................... { 
*
0B18:  MOV     W5,[W15++]
0B1A:  CLR     9A6
0B1C:  CLR     9A8
.................... 	int status=0,count=0; 
.................... 	while(status==0 && count<5) 
.................... 		{ 
0B1E:  CP0     9A6
0B20:  BRA     NZ,D66
0B22:  MOV     9A8,W4
0B24:  CP      W4,#5
0B26:  BRA     GE,D66
.................... 			FillArray(InputBuffer,350,0);  //Clear input_buffer 
0B28:  CLR.B   9C2
0B2A:  MOV     #818,W4
0B2C:  MOV     W4,9BE
0B2E:  MOV     #15E,W4
0B30:  MOV     W4,9C0
0B32:  CALL    A3E
.................... 			printf("AT+CPIN?\r\n");         //Verify chip 
0B36:  MOV     #0,W1
0B38:  MOV     W1,W0
0B3A:  CALL    11E
0B3E:  INC     W1,W1
0B40:  MOV     W1,[W15++]
0B42:  BTSC.B  20F.1
0B44:  BRA     B42
0B46:  MOV     W0,210
0B48:  MOV     [--W15],W1
0B4A:  MOV     #9,W0
0B4C:  CPSGT   W1,W0
0B4E:  BRA     B38
.................... 			ReadBuffer(InputBuffer); 
0B50:  MOV     #818,W4
0B52:  MOV     W4,9BE
0B54:  CALL    A5E
.................... 			PrintBuffer(InputBuffer,100); 
0B58:  MOV     #64,W4
0B5A:  MOV     W4,9B2
0B5C:  MOV     #818,W4
0B5E:  MOV     W4,9B0
0B60:  CALL    AA4
.................... 			status=ValidateCommand(InputBuffer,30); 
0B64:  MOV     #1E,W4
0B66:  MOV     W4,9BC
0B68:  MOV     #818,W4
0B6A:  MOV     W4,9BA
0B6C:  CALL    ADE
0B70:  MOV     W0,9A6
.................... 			if(status==1) lcd_putc("\fCMD OK"); 
0B72:  MOV     9A6,W4
0B74:  CP      W4,#1
0B76:  BRA     NZ,B92
0B78:  MOV     #0,W5
0B7A:  MOV     W5,W0
0B7C:  CALL    136
0B80:  IOR.B   #0,W0L
0B82:  BTSC.B  42.1
0B84:  BRA     B90
0B86:  INC     W5,W5
0B88:  MOV.B   W0L,9BC
0B8A:  CALL    9F2
0B8E:  BRA     B7A
.................... 			else  
0B90:  BRA     BAC
.................... 				{	 
.................... 					lcd_putc("\fCMD BAD"); 
0B92:  MOV     #0,W5
0B94:  MOV     W5,W0
0B96:  CALL    14A
0B9A:  IOR.B   #0,W0L
0B9C:  BTSC.B  42.1
0B9E:  BRA     BAA
0BA0:  INC     W5,W5
0BA2:  MOV.B   W0L,9BC
0BA4:  CALL    9F2
0BA8:  BRA     B94
.................... 					status=0; 
0BAA:  CLR     9A6
.................... 				} 
.................... 			delay_ms(600); 
0BAC:  MOV     #258,W0
0BAE:  CALL    74E
.................... 			if(status==1) 
0BB2:  MOV     9A6,W4
0BB4:  CP      W4,#1
0BB6:  BRA     NZ,C42
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0BB8:  CLR.B   9C2
0BBA:  MOV     #818,W4
0BBC:  MOV     W4,9BE
0BBE:  MOV     #15E,W4
0BC0:  MOV     W4,9C0
0BC2:  CALL    A3E
.................... 					printf("AT+AIPDCONT=\"internet.movistar.mx\",\"movistar\",\"movistar\"\r\n");  //Configure internet 
0BC6:  MOV     #0,W1
0BC8:  MOV     W1,W0
0BCA:  CALL    160
0BCE:  INC     W1,W1
0BD0:  MOV     W1,[W15++]
0BD2:  BTSC.B  20F.1
0BD4:  BRA     BD2
0BD6:  MOV     W0,210
0BD8:  MOV     [--W15],W1
0BDA:  MOV     #39,W0
0BDC:  CPSGT   W1,W0
0BDE:  BRA     BC8
.................... 					ReadBuffer(InputBuffer); 
0BE0:  MOV     #818,W4
0BE2:  MOV     W4,9BE
0BE4:  CALL    A5E
.................... 					PrintBuffer(InputBuffer,1000); 
0BE8:  MOV     #818,W4
0BEA:  MOV     W4,9B0
0BEC:  MOV     #3E8,W4
0BEE:  MOV     W4,9B2
0BF0:  CALL    AA4
.................... 					status=ValidateCommand(InputBuffer,30); 
0BF4:  MOV     #1E,W4
0BF6:  MOV     W4,9BC
0BF8:  MOV     #818,W4
0BFA:  MOV     W4,9BA
0BFC:  CALL    ADE
0C00:  MOV     W0,9A6
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0C02:  MOV     9A6,W4
0C04:  CP      W4,#1
0C06:  BRA     NZ,C22
0C08:  MOV     #0,W5
0C0A:  MOV     W5,W0
0C0C:  CALL    136
0C10:  IOR.B   #0,W0L
0C12:  BTSC.B  42.1
0C14:  BRA     C20
0C16:  INC     W5,W5
0C18:  MOV.B   W0L,9BC
0C1A:  CALL    9F2
0C1E:  BRA     C0A
.................... 					else  
0C20:  BRA     C3C
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0C22:  MOV     #0,W5
0C24:  MOV     W5,W0
0C26:  CALL    14A
0C2A:  IOR.B   #0,W0L
0C2C:  BTSC.B  42.1
0C2E:  BRA     C3A
0C30:  INC     W5,W5
0C32:  MOV.B   W0L,9BC
0C34:  CALL    9F2
0C38:  BRA     C24
.................... 							status=0; 
0C3A:  CLR     9A6
.................... 						} 
.................... 					delay_ms(600); 
0C3C:  MOV     #258,W0
0C3E:  CALL    74E
.................... 				}		 
.................... 			if(status==1) 
0C42:  MOV     9A6,W4
0C44:  CP      W4,#1
0C46:  BRA     NZ,CD2
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0C48:  CLR.B   9C2
0C4A:  MOV     #818,W4
0C4C:  MOV     W4,9BE
0C4E:  MOV     #15E,W4
0C50:  MOV     W4,9C0
0C52:  CALL    A3E
.................... 					printf("AT+AIPA=1\r\n");        //Conect to internet 
0C56:  MOV     #0,W1
0C58:  MOV     W1,W0
0C5A:  CALL    1A4
0C5E:  INC     W1,W1
0C60:  MOV     W1,[W15++]
0C62:  BTSC.B  20F.1
0C64:  BRA     C62
0C66:  MOV     W0,210
0C68:  MOV     [--W15],W1
0C6A:  MOV     #A,W0
0C6C:  CPSGT   W1,W0
0C6E:  BRA     C58
.................... 					ReadBuffer(InputBuffer); 
0C70:  MOV     #818,W4
0C72:  MOV     W4,9BE
0C74:  CALL    A5E
.................... 					PrintBuffer(InputBuffer,1000); 
0C78:  MOV     #818,W4
0C7A:  MOV     W4,9B0
0C7C:  MOV     #3E8,W4
0C7E:  MOV     W4,9B2
0C80:  CALL    AA4
.................... 					status=ValidateCommand(InputBuffer,30); 
0C84:  MOV     #1E,W4
0C86:  MOV     W4,9BC
0C88:  MOV     #818,W4
0C8A:  MOV     W4,9BA
0C8C:  CALL    ADE
0C90:  MOV     W0,9A6
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0C92:  MOV     9A6,W4
0C94:  CP      W4,#1
0C96:  BRA     NZ,CB2
0C98:  MOV     #0,W5
0C9A:  MOV     W5,W0
0C9C:  CALL    136
0CA0:  IOR.B   #0,W0L
0CA2:  BTSC.B  42.1
0CA4:  BRA     CB0
0CA6:  INC     W5,W5
0CA8:  MOV.B   W0L,9BC
0CAA:  CALL    9F2
0CAE:  BRA     C9A
.................... 					else  
0CB0:  BRA     CCC
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0CB2:  MOV     #0,W5
0CB4:  MOV     W5,W0
0CB6:  CALL    14A
0CBA:  IOR.B   #0,W0L
0CBC:  BTSC.B  42.1
0CBE:  BRA     CCA
0CC0:  INC     W5,W5
0CC2:  MOV.B   W0L,9BC
0CC4:  CALL    9F2
0CC8:  BRA     CB4
.................... 							status=0; 
0CCA:  CLR     9A6
.................... 						} 
.................... 					delay_ms(500); 
0CCC:  MOV     #1F4,W0
0CCE:  CALL    74E
.................... 				} 
.................... 			if(status==1) 
0CD2:  MOV     9A6,W4
0CD4:  CP      W4,#1
0CD6:  BRA     NZ,D62
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0CD8:  CLR.B   9C2
0CDA:  MOV     #818,W4
0CDC:  MOV     W4,9BE
0CDE:  MOV     #15E,W4
0CE0:  MOV     W4,9C0
0CE2:  CALL    A3E
.................... 					printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server"AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n" 
0CE6:  MOV     #0,W1
0CE8:  MOV     W1,W0
0CEA:  CALL    1BC
0CEE:  INC     W1,W1
0CF0:  MOV     W1,[W15++]
0CF2:  BTSC.B  20F.1
0CF4:  BRA     CF2
0CF6:  MOV     W0,210
0CF8:  MOV     [--W15],W1
0CFA:  MOV     #30,W0
0CFC:  CPSGT   W1,W0
0CFE:  BRA     CE8
.................... 					ReadBuffer(InputBuffer);																	  
0D00:  MOV     #818,W4
0D02:  MOV     W4,9BE
0D04:  CALL    A5E
.................... 					PrintBuffer(InputBuffer,1000); 
0D08:  MOV     #818,W4
0D0A:  MOV     W4,9B0
0D0C:  MOV     #3E8,W4
0D0E:  MOV     W4,9B2
0D10:  CALL    AA4
.................... 					status=ValidateCommand(InputBuffer,30); 
0D14:  MOV     #1E,W4
0D16:  MOV     W4,9BC
0D18:  MOV     #818,W4
0D1A:  MOV     W4,9BA
0D1C:  CALL    ADE
0D20:  MOV     W0,9A6
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0D22:  MOV     9A6,W4
0D24:  CP      W4,#1
0D26:  BRA     NZ,D42
0D28:  MOV     #0,W5
0D2A:  MOV     W5,W0
0D2C:  CALL    136
0D30:  IOR.B   #0,W0L
0D32:  BTSC.B  42.1
0D34:  BRA     D40
0D36:  INC     W5,W5
0D38:  MOV.B   W0L,9BC
0D3A:  CALL    9F2
0D3E:  BRA     D2A
.................... 					else  
0D40:  BRA     D5C
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0D42:  MOV     #0,W5
0D44:  MOV     W5,W0
0D46:  CALL    14A
0D4A:  IOR.B   #0,W0L
0D4C:  BTSC.B  42.1
0D4E:  BRA     D5A
0D50:  INC     W5,W5
0D52:  MOV.B   W0L,9BC
0D54:  CALL    9F2
0D58:  BRA     D44
.................... 							status=0; 
0D5A:  CLR     9A6
.................... 						} 
.................... 					delay_ms(500); 
0D5C:  MOV     #1F4,W0
0D5E:  CALL    74E
.................... 				} 
.................... 			count++; 
0D62:  INC     09A8
.................... 		} 
0D64:  BRA     B1E
.................... 	//return status; 
.................... } 
0D66:  MOV     [--W15],W5
0D68:  RETURN  
.................... /***********OpenPort************************************** 
.................... **   Description: Open a TCP port in domain name and    ** 
.................... **     specified in dname and rport variables           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int OpenPort(int socket, int lport,char dname[100], int rport) 
.................... { 
.................... 	int state=0; 
.................... 	printf("AT+AIPO=%d,%d,\"%s\",%d,0,,1,2\r\n",socket,lport,dname,rport);  //Conect to server 
.................... 	//******Get incoming buffer data****** 
.................... 	ReadBuffer(InputBuffer); 
.................... 	//***Validate ok command************** 
.................... 	state=ValidateCommand(InputBuffer,30); 
.................... 	if(state==1) lcd_putc("\fCMD OK"); 
.................... 	else 
.................... 		{ 
.................... 			 lcd_putc("\fCMD BAD"); 
.................... 			 state=0; 
.................... 		} 
.................... 	delay_ms(ptime); 
.................... 	return state; 
.................... } 
....................  
.................... /***********ClosePort************************************* 
.................... **   Description: Close a TCP port in domain name and   ** 
.................... **     specified in dname and rport variables           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ClosePort(int socket) 
.................... { 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
*
0EDA:  CLR.B   9C2
0EDC:  MOV     #818,W4
0EDE:  MOV     W4,9BE
0EE0:  MOV     #15E,W4
0EE2:  MOV     W4,9C0
0EE4:  CALL    A3E
.................... 	printf("AT+AIPC=%d\r\n",socket);  //Disconnect 
0EE8:  MOV     #0,W1
0EEA:  MOV     W1,W0
0EEC:  CALL    1FA
0EF0:  INC     W1,W1
0EF2:  MOV     W1,[W15++]
0EF4:  BTSC.B  20F.1
0EF6:  BRA     EF4
0EF8:  MOV     W0,210
0EFA:  MOV     [--W15],W1
0EFC:  MOV     #7,W0
0EFE:  CPSGT   W1,W0
0F00:  BRA     EEA
0F02:  MOV     9BA,W0
0F04:  MOV     #0,W4
0F06:  CALL    D6A
0F0A:  BTSC.B  20F.1
0F0C:  BRA     F0A
0F0E:  MOV     #D,W4
0F10:  MOV     W4,210
0F12:  BTSC.B  20F.1
0F14:  BRA     F12
0F16:  MOV     #A,W4
0F18:  MOV     W4,210
.................... 	ReadBuffer(InputBuffer); 
0F1A:  MOV     #818,W4
0F1C:  MOV     W4,9BE
0F1E:  CALL    A5E
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	//delay_ms(ptime); 
.................... } 
0F22:  RETURN  
....................  
.................... /***********ConfigureDatetime***************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  dy24mt3yr2014hr11mn52$ (24/marzo/2014 11:52 a.m)    ** 
.................... *********************************************************/ 
.................... int ConfigureDatetime(int Id, byte* DateTime) 
.................... { 
0F24:  MOV     W5,[W15++]
0F26:  MOV     W6,[W15++]
0F28:  CLR     9AA
0F2A:  CLR     9AC
.................... 	int status=0; 
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
0F2C:  CLR.B   9C2
0F2E:  MOV     #818,W4
0F30:  MOV     W4,9BE
0F32:  MOV     #15E,W4
0F34:  MOV     W4,9C0
0F36:  CALL    A3E
.................... 	printf("GET /TIMEGPRS/NOWTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
0F3A:  MOV     #0,W1
0F3C:  MOV     W1,W0
0F3E:  CALL    214
0F42:  INC     W1,W1
0F44:  MOV     W1,[W15++]
0F46:  BTSC.B  20F.1
0F48:  BRA     F46
0F4A:  MOV     W0,210
0F4C:  MOV     [--W15],W1
0F4E:  MOV     #15,W0
0F50:  CPSGT   W1,W0
0F52:  BRA     F3C
0F54:  MOV     9A6,W0
0F56:  MOV     #0,W4
0F58:  CALL    D6A
0F5C:  MOV     #18,W1
0F5E:  MOV     W1,W0
0F60:  CALL    214
0F64:  INC     W1,W1
0F66:  MOV     W1,[W15++]
0F68:  BTSC.B  20F.1
0F6A:  BRA     F68
0F6C:  MOV     W0,210
0F6E:  MOV     [--W15],W1
0F70:  MOV     #44,W0
0F72:  CPSGT   W1,W0
0F74:  BRA     F5E
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
0F76:  MOV     #818,W4
0F78:  MOV     9AC,W3
0F7A:  ADD     W3,W4,W5
0F7C:  BTSS.B  20E.0
0F7E:  BRA     F7C
0F80:  MOV     212,W0
0F82:  MOV.B   W0L,[W5]
.................... 		index++; 
0F84:  INC     09AC
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
0F86:  MOV     9AC,W4
0F88:  MOV     #15E,W3
0F8A:  CP      W3,W4
0F8C:  BRA     LE,F9C
0F8E:  MOV     9AC,W4
0F90:  SUB     W4,#1,W5
0F92:  MOV     #818,W4
0F94:  ADD     W5,W4,W0
0F96:  MOV.B   [W0],W4L
0F98:  XOR.B   #24,W4L
0F9A:  BRA     NZ,F76
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
0F9C:  MOV     #818,W4
0F9E:  MOV     W4,9BA
0FA0:  PUSH    9AC
0FA2:  POP     9BC
0FA4:  CALL    ADE
0FA8:  MOV     W0,W5
0FAA:  CP      W5,#1
0FAC:  BRA     NZ,1068
.................... 		{ 
.................... 			lcd_putc("\fCMD OK"); 
0FAE:  MOV     #0,W5
0FB0:  MOV     W5,W0
0FB2:  CALL    136
0FB6:  IOR.B   #0,W0L
0FB8:  BTSC.B  42.1
0FBA:  BRA     FC6
0FBC:  INC     W5,W5
0FBE:  MOV.B   W0L,9BC
0FC0:  CALL    9F2
0FC4:  BRA     FB0
.................... 			delay_ms(ptime); 
0FC6:  MOV     976,W0
0FC8:  CALL    74E
....................  
.................... 			*(DateTime)=(int)GetDecVal(InputBuffer,index,'d','y'); 
0FCC:  MOV     9A8,W5
0FCE:  MOV.B   #64,W0L
0FD0:  MOV.B   W0L,9C2
0FD2:  MOV.B   #79,W0L
0FD4:  MOV.B   W0L,9C3
0FD6:  MOV     #818,W4
0FD8:  MOV     W4,9BE
0FDA:  PUSH    9AC
0FDC:  POP     9C0
0FDE:  CALL    E64
0FE2:  MOV.B   W0L,[W5]
.................... 			*(DateTime+1)=(int)GetDecVal(InputBuffer,index,'m','t'); 
0FE4:  MOV     9A8,W4
0FE6:  ADD     W4,#1,W4
0FE8:  MOV     W4,W0
0FEA:  MOV     W0,W5
0FEC:  MOV.B   #6D,W0L
0FEE:  MOV.B   W0L,9C2
0FF0:  MOV.B   #74,W0L
0FF2:  MOV.B   W0L,9C3
0FF4:  MOV     #818,W4
0FF6:  MOV     W4,9BE
0FF8:  PUSH    9AC
0FFA:  POP     9C0
0FFC:  CALL    E64
1000:  MOV.B   W0L,[W5]
.................... 			*(DateTime+2)=(int)(GetDecVal(InputBuffer,index,'y','r')-2000); 
1002:  MOV     9A8,W4
1004:  ADD     W4,#2,W4
1006:  MOV     W4,W0
1008:  MOV     W0,W5
100A:  MOV.B   #79,W0L
100C:  MOV.B   W0L,9C2
100E:  MOV.B   #72,W0L
1010:  MOV.B   W0L,9C3
1012:  MOV     #818,W4
1014:  MOV     W4,9BE
1016:  PUSH    9AC
1018:  POP     9C0
101A:  CALL    E64
101E:  MOV     W0,W6
1020:  MOV     #7D0,W4
1022:  SUB     W6,W4,W0
1024:  MOV.B   W0L,[W5]
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
1026:  MOV     9A8,W4
1028:  ADD     W4,#3,W4
102A:  MOV     W4,W0
102C:  MOV     W0,W5
102E:  MOV.B   #68,W0L
1030:  MOV.B   W0L,9C2
1032:  MOV.B   #72,W0L
1034:  MOV.B   W0L,9C3
1036:  MOV     #818,W4
1038:  MOV     W4,9BE
103A:  PUSH    9AC
103C:  POP     9C0
103E:  CALL    E64
1042:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
1044:  MOV     9A8,W4
1046:  ADD     W4,#4,W4
1048:  MOV     W4,W0
104A:  MOV     W0,W5
104C:  MOV.B   #6D,W0L
104E:  MOV.B   W0L,9C2
1050:  MOV.B   #6E,W0L
1052:  MOV.B   W0L,9C3
1054:  MOV     #818,W4
1056:  MOV     W4,9BE
1058:  PUSH    9AC
105A:  POP     9C0
105C:  CALL    E64
1060:  MOV.B   W0L,[W5]
....................  
.................... 			status=1; 
1062:  MOV     #1,W4
1064:  MOV     W4,9AA
.................... 		} 
....................  
.................... 	else  
1066:  BRA     106A
.................... 		{ 
.................... 			status=0; 
1068:  CLR     9AA
.................... 		} 
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
106A:  MOV     #32,W0
106C:  CALL    74E
.................... 	printf("+"); 
1070:  BTSC.B  20F.1
1072:  BRA     1070
1074:  MOV     #2B,W4
1076:  MOV     W4,210
.................... 	printf("+"); 
1078:  BTSC.B  20F.1
107A:  BRA     1078
107C:  MOV     #2B,W4
107E:  MOV     W4,210
.................... 	printf("+"); 
1080:  BTSC.B  20F.1
1082:  BRA     1080
1084:  MOV     #2B,W4
1086:  MOV     W4,210
.................... 	OERR=16; 
1088:  MOV.B   #10,W0L
108A:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
108C:  MOV     #818,W4
108E:  MOV     W4,9BE
1090:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
1094:  MOV     #32,W0
1096:  CALL    74E
.................... 	ClosePort(1); 
109A:  MOV     #1,W4
109C:  MOV     W4,9BA
109E:  CALL    EDA
.................... 	return status; 
10A2:  PUSH    9AA
10A4:  POP     0
.................... } 
10A6:  MOV     [--W15],W6
10A8:  MOV     [--W15],W5
10AA:  RETURN  
....................  
.................... /***********GetSunriseTime******************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current sunrise time of the specified device     ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  hr11mn52$ (11:52 a.m)                               ** 
.................... *********************************************************/ 
.................... void GetOnTime(int Id, byte* DateTime) 
.................... { 
*
146C:  MOV     W5,[W15++]
146E:  CLR     9AA
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1470:  CLR.B   9C2
1472:  MOV     #818,W4
1474:  MOV     W4,9BE
1476:  MOV     #15E,W4
1478:  MOV     W4,9C0
147A:  CALL    A3E
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
147E:  MOV     #0,W1
1480:  MOV     W1,W0
1482:  CALL    1A4
1486:  INC     W1,W1
1488:  MOV     W1,[W15++]
148A:  BTSC.B  20F.1
148C:  BRA     148A
148E:  MOV     W0,210
1490:  MOV     [--W15],W1
1492:  MOV     #A,W0
1494:  CPSGT   W1,W0
1496:  BRA     1480
.................... 	ReadBuffer(InputBuffer); 
1498:  MOV     #818,W4
149A:  MOV     W4,9BE
149C:  CALL    A5E
.................... 	delay_ms(ptime); 
14A0:  MOV     976,W0
14A2:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
14A6:  CLR.B   9C2
14A8:  MOV     #818,W4
14AA:  MOV     W4,9BE
14AC:  MOV     #15E,W4
14AE:  MOV     W4,9C0
14B0:  CALL    A3E
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
14B4:  MOV     #0,W1
14B6:  MOV     W1,W0
14B8:  CALL    1BC
14BC:  INC     W1,W1
14BE:  MOV     W1,[W15++]
14C0:  BTSC.B  20F.1
14C2:  BRA     14C0
14C4:  MOV     W0,210
14C6:  MOV     [--W15],W1
14C8:  MOV     #30,W0
14CA:  CPSGT   W1,W0
14CC:  BRA     14B6
.................... 	ReadBuffer(InputBuffer); 
14CE:  MOV     #818,W4
14D0:  MOV     W4,9BE
14D2:  CALL    A5E
.................... 	delay_ms(ptime); 
14D6:  MOV     976,W0
14D8:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
14DC:  CLR.B   9C2
14DE:  MOV     #818,W4
14E0:  MOV     W4,9BE
14E2:  MOV     #15E,W4
14E4:  MOV     W4,9C0
14E6:  CALL    A3E
.................... 	printf("GET /TIMEGPRS/ONTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
14EA:  MOV     #0,W1
14EC:  MOV     W1,W0
14EE:  CALL    260
14F2:  INC     W1,W1
14F4:  MOV     W1,[W15++]
14F6:  BTSC.B  20F.1
14F8:  BRA     14F6
14FA:  MOV     W0,210
14FC:  MOV     [--W15],W1
14FE:  MOV     #14,W0
1500:  CPSGT   W1,W0
1502:  BRA     14EC
1504:  MOV     9A6,W0
1506:  MOV     #0,W4
1508:  CALL    D6A
150C:  MOV     #17,W1
150E:  MOV     W1,W0
1510:  CALL    260
1514:  INC     W1,W1
1516:  MOV     W1,[W15++]
1518:  BTSC.B  20F.1
151A:  BRA     1518
151C:  MOV     W0,210
151E:  MOV     [--W15],W1
1520:  MOV     #43,W0
1522:  CPSGT   W1,W0
1524:  BRA     150E
....................  
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
1526:  MOV     #818,W4
1528:  MOV     9AA,W3
152A:  ADD     W3,W4,W5
152C:  BTSS.B  20E.0
152E:  BRA     152C
1530:  MOV     212,W0
1532:  MOV.B   W0L,[W5]
.................... 		index++; 
1534:  INC     09AA
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
1536:  MOV     9AA,W4
1538:  MOV     #15E,W3
153A:  CP      W3,W4
153C:  BRA     LE,154C
153E:  MOV     9AA,W4
1540:  SUB     W4,#1,W5
1542:  MOV     #818,W4
1544:  ADD     W5,W4,W0
1546:  MOV.B   [W0],W4L
1548:  XOR.B   #24,W4L
154A:  BRA     NZ,1526
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
154C:  MOV     #818,W4
154E:  MOV     W4,9BA
1550:  PUSH    9AA
1552:  POP     9BC
1554:  CALL    ADE
1558:  MOV     W0,W5
155A:  CP      W5,#1
155C:  BRA     NZ,159A
.................... 		{ 
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
155E:  MOV     9A8,W4
1560:  ADD     W4,#3,W4
1562:  MOV     W4,W0
1564:  MOV     W0,W5
1566:  MOV.B   #68,W0L
1568:  MOV.B   W0L,9C2
156A:  MOV.B   #72,W0L
156C:  MOV.B   W0L,9C3
156E:  MOV     #818,W4
1570:  MOV     W4,9BE
1572:  PUSH    9AA
1574:  POP     9C0
1576:  CALL    E64
157A:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
157C:  MOV     9A8,W4
157E:  ADD     W4,#4,W4
1580:  MOV     W4,W0
1582:  MOV     W0,W5
1584:  MOV.B   #6D,W0L
1586:  MOV.B   W0L,9C2
1588:  MOV.B   #6E,W0L
158A:  MOV.B   W0L,9C3
158C:  MOV     #818,W4
158E:  MOV     W4,9BE
1590:  PUSH    9AA
1592:  POP     9C0
1594:  CALL    E64
1598:  MOV.B   W0L,[W5]
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
159A:  MOV     #32,W0
159C:  CALL    74E
.................... 	printf("+"); 
15A0:  BTSC.B  20F.1
15A2:  BRA     15A0
15A4:  MOV     #2B,W4
15A6:  MOV     W4,210
.................... 	printf("+"); 
15A8:  BTSC.B  20F.1
15AA:  BRA     15A8
15AC:  MOV     #2B,W4
15AE:  MOV     W4,210
.................... 	printf("+"); 
15B0:  BTSC.B  20F.1
15B2:  BRA     15B0
15B4:  MOV     #2B,W4
15B6:  MOV     W4,210
.................... 	OERR=16; 
15B8:  MOV.B   #10,W0L
15BA:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
15BC:  MOV     #818,W4
15BE:  MOV     W4,9BE
15C0:  CALL    A5E
.................... 	ClosePort(1); 
15C4:  MOV     #1,W4
15C6:  MOV     W4,9BA
15C8:  CALL    EDA
.................... } 
15CC:  MOV     [--W15],W5
15CE:  RETURN  
....................  
.................... /***********GetSunsetTime******************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current sunset time of the specified device      ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  hr11mn52$ (11:52 a.m)                               ** 
.................... *********************************************************/ 
.................... void GetOffTime(int Id, byte* DateTime) 
.................... { 
15D0:  MOV     W5,[W15++]
15D2:  CLR     9AA
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
15D4:  CLR.B   9C2
15D6:  MOV     #818,W4
15D8:  MOV     W4,9BE
15DA:  MOV     #15E,W4
15DC:  MOV     W4,9C0
15DE:  CALL    A3E
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
15E2:  MOV     #0,W1
15E4:  MOV     W1,W0
15E6:  CALL    1A4
15EA:  INC     W1,W1
15EC:  MOV     W1,[W15++]
15EE:  BTSC.B  20F.1
15F0:  BRA     15EE
15F2:  MOV     W0,210
15F4:  MOV     [--W15],W1
15F6:  MOV     #A,W0
15F8:  CPSGT   W1,W0
15FA:  BRA     15E4
.................... 	ReadBuffer(InputBuffer); 
15FC:  MOV     #818,W4
15FE:  MOV     W4,9BE
1600:  CALL    A5E
.................... 	delay_ms(ptime); 
1604:  MOV     976,W0
1606:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
160A:  CLR.B   9C2
160C:  MOV     #818,W4
160E:  MOV     W4,9BE
1610:  MOV     #15E,W4
1612:  MOV     W4,9C0
1614:  CALL    A3E
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
1618:  MOV     #0,W1
161A:  MOV     W1,W0
161C:  CALL    1BC
1620:  INC     W1,W1
1622:  MOV     W1,[W15++]
1624:  BTSC.B  20F.1
1626:  BRA     1624
1628:  MOV     W0,210
162A:  MOV     [--W15],W1
162C:  MOV     #30,W0
162E:  CPSGT   W1,W0
1630:  BRA     161A
.................... 	ReadBuffer(InputBuffer); 
1632:  MOV     #818,W4
1634:  MOV     W4,9BE
1636:  CALL    A5E
.................... 	delay_ms(ptime); 
163A:  MOV     976,W0
163C:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1640:  CLR.B   9C2
1642:  MOV     #818,W4
1644:  MOV     W4,9BE
1646:  MOV     #15E,W4
1648:  MOV     W4,9C0
164A:  CALL    A3E
.................... 	printf("GET /TIMEGPRS/OFFTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
164E:  MOV     #0,W1
1650:  MOV     W1,W0
1652:  CALL    2AA
1656:  INC     W1,W1
1658:  MOV     W1,[W15++]
165A:  BTSC.B  20F.1
165C:  BRA     165A
165E:  MOV     W0,210
1660:  MOV     [--W15],W1
1662:  MOV     #15,W0
1664:  CPSGT   W1,W0
1666:  BRA     1650
1668:  MOV     9A6,W0
166A:  MOV     #0,W4
166C:  CALL    D6A
1670:  MOV     #18,W1
1672:  MOV     W1,W0
1674:  CALL    2AA
1678:  INC     W1,W1
167A:  MOV     W1,[W15++]
167C:  BTSC.B  20F.1
167E:  BRA     167C
1680:  MOV     W0,210
1682:  MOV     [--W15],W1
1684:  MOV     #44,W0
1686:  CPSGT   W1,W0
1688:  BRA     1672
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
168A:  MOV     #818,W4
168C:  MOV     9AA,W3
168E:  ADD     W3,W4,W5
1690:  BTSS.B  20E.0
1692:  BRA     1690
1694:  MOV     212,W0
1696:  MOV.B   W0L,[W5]
.................... 		index++; 
1698:  INC     09AA
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
169A:  MOV     9AA,W4
169C:  MOV     #15E,W3
169E:  CP      W3,W4
16A0:  BRA     LE,16B0
16A2:  MOV     9AA,W4
16A4:  SUB     W4,#1,W5
16A6:  MOV     #818,W4
16A8:  ADD     W5,W4,W0
16AA:  MOV.B   [W0],W4L
16AC:  XOR.B   #24,W4L
16AE:  BRA     NZ,168A
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
16B0:  MOV     #818,W4
16B2:  MOV     W4,9BA
16B4:  PUSH    9AA
16B6:  POP     9BC
16B8:  CALL    ADE
16BC:  MOV     W0,W5
16BE:  CP      W5,#1
16C0:  BRA     NZ,16FE
.................... 		{ 
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
16C2:  MOV     9A8,W4
16C4:  ADD     W4,#3,W4
16C6:  MOV     W4,W0
16C8:  MOV     W0,W5
16CA:  MOV.B   #68,W0L
16CC:  MOV.B   W0L,9C2
16CE:  MOV.B   #72,W0L
16D0:  MOV.B   W0L,9C3
16D2:  MOV     #818,W4
16D4:  MOV     W4,9BE
16D6:  PUSH    9AA
16D8:  POP     9C0
16DA:  CALL    E64
16DE:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
16E0:  MOV     9A8,W4
16E2:  ADD     W4,#4,W4
16E4:  MOV     W4,W0
16E6:  MOV     W0,W5
16E8:  MOV.B   #6D,W0L
16EA:  MOV.B   W0L,9C2
16EC:  MOV.B   #6E,W0L
16EE:  MOV.B   W0L,9C3
16F0:  MOV     #818,W4
16F2:  MOV     W4,9BE
16F4:  PUSH    9AA
16F6:  POP     9C0
16F8:  CALL    E64
16FC:  MOV.B   W0L,[W5]
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
16FE:  MOV     #32,W0
1700:  CALL    74E
.................... 	printf("+"); 
1704:  BTSC.B  20F.1
1706:  BRA     1704
1708:  MOV     #2B,W4
170A:  MOV     W4,210
.................... 	printf("+"); 
170C:  BTSC.B  20F.1
170E:  BRA     170C
1710:  MOV     #2B,W4
1712:  MOV     W4,210
.................... 	printf("+"); 
1714:  BTSC.B  20F.1
1716:  BRA     1714
1718:  MOV     #2B,W4
171A:  MOV     W4,210
.................... 	OERR=16; 
171C:  MOV.B   #10,W0L
171E:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
1720:  MOV     #818,W4
1722:  MOV     W4,9BE
1724:  CALL    A5E
.................... 	delay_ms(50); 
1728:  MOV     #32,W0
172A:  CALL    74E
.................... 	ClosePort(1); 
172E:  MOV     #1,W4
1730:  MOV     W4,9BA
1732:  CALL    EDA
.................... } 
1736:  MOV     [--W15],W5
1738:  RETURN  
....................  
.................... /***********GetMode*************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void GetMode(int Id, int* mod,int state) 
.................... { 
*
1268:  MOV     W5,[W15++]
126A:  CLR     9AC
126C:  CLR     9AE
.................... 	int status=0; 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
126E:  CLR.B   9C2
1270:  MOV     #818,W4
1272:  MOV     W4,9BE
1274:  MOV     #15E,W4
1276:  MOV     W4,9C0
1278:  CALL    A3E
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
127C:  MOV     #0,W1
127E:  MOV     W1,W0
1280:  CALL    1A4
1284:  INC     W1,W1
1286:  MOV     W1,[W15++]
1288:  BTSC.B  20F.1
128A:  BRA     1288
128C:  MOV     W0,210
128E:  MOV     [--W15],W1
1290:  MOV     #A,W0
1292:  CPSGT   W1,W0
1294:  BRA     127E
.................... 	ReadBuffer(InputBuffer); 
1296:  MOV     #818,W4
1298:  MOV     W4,9BE
129A:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
129E:  MOV     976,W0
12A0:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
12A4:  CLR.B   9C2
12A6:  MOV     #818,W4
12A8:  MOV     W4,9BE
12AA:  MOV     #15E,W4
12AC:  MOV     W4,9C0
12AE:  CALL    A3E
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
12B2:  MOV     #0,W1
12B4:  MOV     W1,W0
12B6:  CALL    1BC
12BA:  INC     W1,W1
12BC:  MOV     W1,[W15++]
12BE:  BTSC.B  20F.1
12C0:  BRA     12BE
12C2:  MOV     W0,210
12C4:  MOV     [--W15],W1
12C6:  MOV     #30,W0
12C8:  CPSGT   W1,W0
12CA:  BRA     12B4
.................... 	ReadBuffer(InputBuffer); 
12CC:  MOV     #818,W4
12CE:  MOV     W4,9BE
12D0:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
12D4:  MOV     976,W0
12D6:  CALL    74E
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
12DA:  CLR.B   9C2
12DC:  MOV     #818,W4
12DE:  MOV     W4,9BE
12E0:  MOV     #15E,W4
12E2:  MOV     W4,9C0
12E4:  CALL    A3E
.................... 	printf("GET /DEVICEGPRS/GETMODE/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
12E8:  MOV     #0,W1
12EA:  MOV     W1,W0
12EC:  CALL    2F6
12F0:  INC     W1,W1
12F2:  MOV     W1,[W15++]
12F4:  BTSC.B  20F.1
12F6:  BRA     12F4
12F8:  MOV     W0,210
12FA:  MOV     [--W15],W1
12FC:  MOV     #17,W0
12FE:  CPSGT   W1,W0
1300:  BRA     12EA
1302:  MOV     9A6,W0
1304:  MOV     #0,W4
1306:  CALL    D6A
130A:  MOV     #1A,W1
130C:  MOV     W1,W0
130E:  CALL    2F6
1312:  INC     W1,W1
1314:  MOV     W1,[W15++]
1316:  BTSC.B  20F.1
1318:  BRA     1316
131A:  MOV     W0,210
131C:  MOV     [--W15],W1
131E:  MOV     #46,W0
1320:  CPSGT   W1,W0
1322:  BRA     130C
.................... 	while(getc()!='\n'); 
1324:  BTSS.B  20E.0
1326:  BRA     1324
1328:  MOV     212,W0
132A:  CP.B    W0L,#A
132C:  BRA     NZ,1324
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
132E:  MOV     #818,W4
1330:  MOV     9AE,W3
1332:  ADD     W3,W4,W5
1334:  BTSS.B  20E.0
1336:  BRA     1334
1338:  MOV     212,W0
133A:  MOV.B   W0L,[W5]
.................... 		index++; 
133C:  INC     09AE
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
133E:  MOV     9AE,W4
1340:  MOV     #15E,W3
1342:  CP      W3,W4
1344:  BRA     LE,1354
1346:  MOV     9AE,W4
1348:  SUB     W4,#1,W5
134A:  MOV     #818,W4
134C:  ADD     W5,W4,W0
134E:  MOV.B   [W0],W4L
1350:  XOR.B   #24,W4L
1352:  BRA     NZ,132E
....................  
.................... 	OERR=16; 
1354:  MOV.B   #10,W0L
1356:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1358:  MOV     #818,W4
135A:  MOV     W4,9BA
135C:  PUSH    9AE
135E:  POP     9BC
1360:  CALL    ADE
1364:  MOV     W0,W5
1366:  CP      W5,#1
1368:  BRA     NZ,1386
.................... 		{ 
.................... 			*mod=(int)GetDecVal(InputBuffer,index,'m','d'); 
136A:  MOV     9A8,W5
136C:  MOV.B   #6D,W0L
136E:  MOV.B   W0L,9C2
1370:  MOV.B   #64,W0L
1372:  MOV.B   W0L,9C3
1374:  MOV     #818,W4
1376:  MOV     W4,9BE
1378:  PUSH    9AE
137A:  POP     9C0
137C:  CALL    E64
1380:  MOV     W0,[W5]
.................... 			status=1; 
1382:  MOV     #1,W4
1384:  MOV     W4,9AC
.................... 		} 
....................  
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1386:  CLR.B   9C2
1388:  MOV     #818,W4
138A:  MOV     W4,9BE
138C:  MOV     #15E,W4
138E:  MOV     W4,9C0
1390:  CALL    A3E
.................... 	index=0; 
1394:  CLR     9AE
.................... 	printf("GET /DEVICEGPRS/GETSTATUS/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1396:  MOV     #0,W1
1398:  MOV     W1,W0
139A:  CALL    342
139E:  INC     W1,W1
13A0:  MOV     W1,[W15++]
13A2:  BTSC.B  20F.1
13A4:  BRA     13A2
13A6:  MOV     W0,210
13A8:  MOV     [--W15],W1
13AA:  MOV     #19,W0
13AC:  CPSGT   W1,W0
13AE:  BRA     1398
13B0:  MOV     9A6,W0
13B2:  MOV     #0,W4
13B4:  CALL    D6A
13B8:  MOV     #1C,W1
13BA:  MOV     W1,W0
13BC:  CALL    342
13C0:  INC     W1,W1
13C2:  MOV     W1,[W15++]
13C4:  BTSC.B  20F.1
13C6:  BRA     13C4
13C8:  MOV     W0,210
13CA:  MOV     [--W15],W1
13CC:  MOV     #48,W0
13CE:  CPSGT   W1,W0
13D0:  BRA     13BA
.................... 	while(getc()!='\n'); 
13D2:  BTSS.B  20E.0
13D4:  BRA     13D2
13D6:  MOV     212,W0
13D8:  CP.B    W0L,#A
13DA:  BRA     NZ,13D2
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
13DC:  MOV     #818,W4
13DE:  MOV     9AE,W3
13E0:  ADD     W3,W4,W5
13E2:  BTSS.B  20E.0
13E4:  BRA     13E2
13E6:  MOV     212,W0
13E8:  MOV.B   W0L,[W5]
.................... 		index++; 
13EA:  INC     09AE
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
13EC:  MOV     9AE,W4
13EE:  MOV     #15E,W3
13F0:  CP      W3,W4
13F2:  BRA     LE,1402
13F4:  MOV     9AE,W4
13F6:  SUB     W4,#1,W5
13F8:  MOV     #818,W4
13FA:  ADD     W5,W4,W0
13FC:  MOV.B   [W0],W4L
13FE:  XOR.B   #24,W4L
1400:  BRA     NZ,13DC
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1402:  MOV     #818,W4
1404:  MOV     W4,9BA
1406:  PUSH    9AE
1408:  POP     9BC
140A:  CALL    ADE
140E:  MOV     W0,W5
1410:  CP      W5,#1
1412:  BRA     NZ,1430
.................... 		{ 
.................... 			*state=(int)GetDecVal(InputBuffer,index,'s','t'); 
1414:  MOV     9AA,W5
1416:  MOV.B   #73,W0L
1418:  MOV.B   W0L,9C2
141A:  MOV.B   #74,W0L
141C:  MOV.B   W0L,9C3
141E:  MOV     #818,W4
1420:  MOV     W4,9BE
1422:  PUSH    9AE
1424:  POP     9C0
1426:  CALL    E64
142A:  MOV.B   W0L,[W5]
.................... 			status=1; 
142C:  MOV     #1,W4
142E:  MOV     W4,9AC
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1430:  MOV     #32,W0
1432:  CALL    74E
.................... 	printf("+"); 
1436:  BTSC.B  20F.1
1438:  BRA     1436
143A:  MOV     #2B,W4
143C:  MOV     W4,210
.................... 	printf("+"); 
143E:  BTSC.B  20F.1
1440:  BRA     143E
1442:  MOV     #2B,W4
1444:  MOV     W4,210
.................... 	printf("+"); 
1446:  BTSC.B  20F.1
1448:  BRA     1446
144A:  MOV     #2B,W4
144C:  MOV     W4,210
.................... 	OERR=16; 
144E:  MOV.B   #10,W0L
1450:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
1452:  MOV     #818,W4
1454:  MOV     W4,9BE
1456:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
145A:  MOV     #32,W0
145C:  CALL    74E
.................... 	ClosePort(1); 
1460:  MOV     #1,W4
1462:  MOV     W4,9BA
1464:  CALL    EDA
.................... } 
1468:  MOV     [--W15],W5
146A:  RETURN  
....................  
.................... /***********GetAutomated*************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void GetAutomated(int Id, int* setpoint,int* histeresys) 
.................... { 
*
19E8:  MOV     W5,[W15++]
19EA:  CLR     9AC
19EC:  CLR     9AE
.................... 	int status=0; 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
19EE:  CLR.B   9C2
19F0:  MOV     #818,W4
19F2:  MOV     W4,9BE
19F4:  MOV     #15E,W4
19F6:  MOV     W4,9C0
19F8:  CALL    A3E
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
19FC:  MOV     #0,W1
19FE:  MOV     W1,W0
1A00:  CALL    1A4
1A04:  INC     W1,W1
1A06:  MOV     W1,[W15++]
1A08:  BTSC.B  20F.1
1A0A:  BRA     1A08
1A0C:  MOV     W0,210
1A0E:  MOV     [--W15],W1
1A10:  MOV     #A,W0
1A12:  CPSGT   W1,W0
1A14:  BRA     19FE
.................... 	ReadBuffer(InputBuffer); 
1A16:  MOV     #818,W4
1A18:  MOV     W4,9BE
1A1A:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
1A1E:  MOV     976,W0
1A20:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1A24:  CLR.B   9C2
1A26:  MOV     #818,W4
1A28:  MOV     W4,9BE
1A2A:  MOV     #15E,W4
1A2C:  MOV     W4,9C0
1A2E:  CALL    A3E
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
1A32:  MOV     #0,W1
1A34:  MOV     W1,W0
1A36:  CALL    1BC
1A3A:  INC     W1,W1
1A3C:  MOV     W1,[W15++]
1A3E:  BTSC.B  20F.1
1A40:  BRA     1A3E
1A42:  MOV     W0,210
1A44:  MOV     [--W15],W1
1A46:  MOV     #30,W0
1A48:  CPSGT   W1,W0
1A4A:  BRA     1A34
.................... 	ReadBuffer(InputBuffer); 
1A4C:  MOV     #818,W4
1A4E:  MOV     W4,9BE
1A50:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
1A54:  MOV     976,W0
1A56:  CALL    74E
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1A5A:  CLR.B   9C2
1A5C:  MOV     #818,W4
1A5E:  MOV     W4,9BE
1A60:  MOV     #15E,W4
1A62:  MOV     W4,9C0
1A64:  CALL    A3E
.................... 	printf("GET /DEVICEGPRS/GETSETPOINT/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1A68:  MOV     #0,W1
1A6A:  MOV     W1,W0
1A6C:  CALL    390
1A70:  INC     W1,W1
1A72:  MOV     W1,[W15++]
1A74:  BTSC.B  20F.1
1A76:  BRA     1A74
1A78:  MOV     W0,210
1A7A:  MOV     [--W15],W1
1A7C:  MOV     #1B,W0
1A7E:  CPSGT   W1,W0
1A80:  BRA     1A6A
1A82:  MOV     9A6,W0
1A84:  MOV     #0,W4
1A86:  CALL    D6A
1A8A:  MOV     #1E,W1
1A8C:  MOV     W1,W0
1A8E:  CALL    390
1A92:  INC     W1,W1
1A94:  MOV     W1,[W15++]
1A96:  BTSC.B  20F.1
1A98:  BRA     1A96
1A9A:  MOV     W0,210
1A9C:  MOV     [--W15],W1
1A9E:  MOV     #4A,W0
1AA0:  CPSGT   W1,W0
1AA2:  BRA     1A8C
.................... 	while(getc()!='\n'); 
1AA4:  BTSS.B  20E.0
1AA6:  BRA     1AA4
1AA8:  MOV     212,W0
1AAA:  CP.B    W0L,#A
1AAC:  BRA     NZ,1AA4
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1AAE:  MOV     #818,W4
1AB0:  MOV     9AE,W3
1AB2:  ADD     W3,W4,W5
1AB4:  BTSS.B  20E.0
1AB6:  BRA     1AB4
1AB8:  MOV     212,W0
1ABA:  MOV.B   W0L,[W5]
.................... 		index++; 
1ABC:  INC     09AE
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1ABE:  MOV     9AE,W4
1AC0:  MOV     #15E,W3
1AC2:  CP      W3,W4
1AC4:  BRA     LE,1AD4
1AC6:  MOV     9AE,W4
1AC8:  SUB     W4,#1,W5
1ACA:  MOV     #818,W4
1ACC:  ADD     W5,W4,W0
1ACE:  MOV.B   [W0],W4L
1AD0:  XOR.B   #24,W4L
1AD2:  BRA     NZ,1AAE
....................  
.................... 	OERR=16; 
1AD4:  MOV.B   #10,W0L
1AD6:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1AD8:  MOV     #818,W4
1ADA:  MOV     W4,9BA
1ADC:  PUSH    9AE
1ADE:  POP     9BC
1AE0:  CALL    ADE
1AE4:  MOV     W0,W5
1AE6:  CP      W5,#1
1AE8:  BRA     NZ,1B06
.................... 		{ 
.................... 			*setpoint=(int)GetDecVal(InputBuffer,index,'s','t'); 
1AEA:  MOV     9A8,W5
1AEC:  MOV.B   #73,W0L
1AEE:  MOV.B   W0L,9C2
1AF0:  MOV.B   #74,W0L
1AF2:  MOV.B   W0L,9C3
1AF4:  MOV     #818,W4
1AF6:  MOV     W4,9BE
1AF8:  PUSH    9AE
1AFA:  POP     9C0
1AFC:  CALL    E64
1B00:  MOV     W0,[W5]
.................... 			status=1; 
1B02:  MOV     #1,W4
1B04:  MOV     W4,9AC
.................... 		} 
....................  
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1B06:  CLR.B   9C2
1B08:  MOV     #818,W4
1B0A:  MOV     W4,9BE
1B0C:  MOV     #15E,W4
1B0E:  MOV     W4,9C0
1B10:  CALL    A3E
.................... 	index=0; 
1B14:  CLR     9AE
.................... 	printf("GET /DEVICEGPRS/GETHIST/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1B16:  MOV     #0,W1
1B18:  MOV     W1,W0
1B1A:  CALL    3E0
1B1E:  INC     W1,W1
1B20:  MOV     W1,[W15++]
1B22:  BTSC.B  20F.1
1B24:  BRA     1B22
1B26:  MOV     W0,210
1B28:  MOV     [--W15],W1
1B2A:  MOV     #17,W0
1B2C:  CPSGT   W1,W0
1B2E:  BRA     1B18
1B30:  MOV     9A6,W0
1B32:  MOV     #0,W4
1B34:  CALL    D6A
1B38:  MOV     #1A,W1
1B3A:  MOV     W1,W0
1B3C:  CALL    3E0
1B40:  INC     W1,W1
1B42:  MOV     W1,[W15++]
1B44:  BTSC.B  20F.1
1B46:  BRA     1B44
1B48:  MOV     W0,210
1B4A:  MOV     [--W15],W1
1B4C:  MOV     #46,W0
1B4E:  CPSGT   W1,W0
1B50:  BRA     1B3A
.................... 	while(getc()!='\n'); 
1B52:  BTSS.B  20E.0
1B54:  BRA     1B52
1B56:  MOV     212,W0
1B58:  CP.B    W0L,#A
1B5A:  BRA     NZ,1B52
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1B5C:  MOV     #818,W4
1B5E:  MOV     9AE,W3
1B60:  ADD     W3,W4,W5
1B62:  BTSS.B  20E.0
1B64:  BRA     1B62
1B66:  MOV     212,W0
1B68:  MOV.B   W0L,[W5]
.................... 		index++; 
1B6A:  INC     09AE
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1B6C:  MOV     9AE,W4
1B6E:  MOV     #15E,W3
1B70:  CP      W3,W4
1B72:  BRA     LE,1B82
1B74:  MOV     9AE,W4
1B76:  SUB     W4,#1,W5
1B78:  MOV     #818,W4
1B7A:  ADD     W5,W4,W0
1B7C:  MOV.B   [W0],W4L
1B7E:  XOR.B   #24,W4L
1B80:  BRA     NZ,1B5C
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1B82:  MOV     #818,W4
1B84:  MOV     W4,9BA
1B86:  PUSH    9AE
1B88:  POP     9BC
1B8A:  CALL    ADE
1B8E:  MOV     W0,W5
1B90:  CP      W5,#1
1B92:  BRA     NZ,1BB0
.................... 		{ 
.................... 			*histeresys=(int)GetDecVal(InputBuffer,index,'s','t'); 
1B94:  MOV     9AA,W5
1B96:  MOV.B   #73,W0L
1B98:  MOV.B   W0L,9C2
1B9A:  MOV.B   #74,W0L
1B9C:  MOV.B   W0L,9C3
1B9E:  MOV     #818,W4
1BA0:  MOV     W4,9BE
1BA2:  PUSH    9AE
1BA4:  POP     9C0
1BA6:  CALL    E64
1BAA:  MOV     W0,[W5]
.................... 			status=1; 
1BAC:  MOV     #1,W4
1BAE:  MOV     W4,9AC
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1BB0:  MOV     #32,W0
1BB2:  CALL    74E
.................... 	printf("+"); 
1BB6:  BTSC.B  20F.1
1BB8:  BRA     1BB6
1BBA:  MOV     #2B,W4
1BBC:  MOV     W4,210
.................... 	printf("+"); 
1BBE:  BTSC.B  20F.1
1BC0:  BRA     1BBE
1BC2:  MOV     #2B,W4
1BC4:  MOV     W4,210
.................... 	printf("+"); 
1BC6:  BTSC.B  20F.1
1BC8:  BRA     1BC6
1BCA:  MOV     #2B,W4
1BCC:  MOV     W4,210
.................... 	OERR=16; 
1BCE:  MOV.B   #10,W0L
1BD0:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
1BD2:  MOV     #818,W4
1BD4:  MOV     W4,9BE
1BD6:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
1BDA:  MOV     #32,W0
1BDC:  CALL    74E
.................... 	ClosePort(1); 
1BE0:  MOV     #1,W4
1BE2:  MOV     W4,9BA
1BE4:  CALL    EDA
.................... } 
1BE8:  MOV     [--W15],W5
1BEA:  RETURN  
.................... /***********GetPort*************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void GetPort(int Id, int* porton,int* portoff,int* portin) 
.................... { 
*
173A:  MOV     W5,[W15++]
173C:  CLR     9AE
173E:  CLR     9B0
.................... 	int status=0; 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1740:  CLR.B   9C2
1742:  MOV     #818,W4
1744:  MOV     W4,9BE
1746:  MOV     #15E,W4
1748:  MOV     W4,9C0
174A:  CALL    A3E
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
174E:  MOV     #0,W1
1750:  MOV     W1,W0
1752:  CALL    1A4
1756:  INC     W1,W1
1758:  MOV     W1,[W15++]
175A:  BTSC.B  20F.1
175C:  BRA     175A
175E:  MOV     W0,210
1760:  MOV     [--W15],W1
1762:  MOV     #A,W0
1764:  CPSGT   W1,W0
1766:  BRA     1750
.................... 	ReadBuffer(InputBuffer); 
1768:  MOV     #818,W4
176A:  MOV     W4,9BE
176C:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
1770:  MOV     976,W0
1772:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1776:  CLR.B   9C2
1778:  MOV     #818,W4
177A:  MOV     W4,9BE
177C:  MOV     #15E,W4
177E:  MOV     W4,9C0
1780:  CALL    A3E
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
1784:  MOV     #0,W1
1786:  MOV     W1,W0
1788:  CALL    1BC
178C:  INC     W1,W1
178E:  MOV     W1,[W15++]
1790:  BTSC.B  20F.1
1792:  BRA     1790
1794:  MOV     W0,210
1796:  MOV     [--W15],W1
1798:  MOV     #30,W0
179A:  CPSGT   W1,W0
179C:  BRA     1786
.................... 	ReadBuffer(InputBuffer); 
179E:  MOV     #818,W4
17A0:  MOV     W4,9BE
17A2:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
17A6:  MOV     976,W0
17A8:  CALL    74E
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
17AC:  CLR.B   9C2
17AE:  MOV     #818,W4
17B0:  MOV     W4,9BE
17B2:  MOV     #15E,W4
17B4:  MOV     W4,9C0
17B6:  CALL    A3E
.................... 	printf("GET /DEVICEGPRS/GETPORTON/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
17BA:  MOV     #0,W1
17BC:  MOV     W1,W0
17BE:  CALL    42C
17C2:  INC     W1,W1
17C4:  MOV     W1,[W15++]
17C6:  BTSC.B  20F.1
17C8:  BRA     17C6
17CA:  MOV     W0,210
17CC:  MOV     [--W15],W1
17CE:  MOV     #19,W0
17D0:  CPSGT   W1,W0
17D2:  BRA     17BC
17D4:  MOV     9A6,W0
17D6:  MOV     #0,W4
17D8:  CALL    D6A
17DC:  MOV     #1C,W1
17DE:  MOV     W1,W0
17E0:  CALL    42C
17E4:  INC     W1,W1
17E6:  MOV     W1,[W15++]
17E8:  BTSC.B  20F.1
17EA:  BRA     17E8
17EC:  MOV     W0,210
17EE:  MOV     [--W15],W1
17F0:  MOV     #48,W0
17F2:  CPSGT   W1,W0
17F4:  BRA     17DE
.................... 	while(getc()!='\n'); 
17F6:  BTSS.B  20E.0
17F8:  BRA     17F6
17FA:  MOV     212,W0
17FC:  CP.B    W0L,#A
17FE:  BRA     NZ,17F6
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1800:  MOV     #818,W4
1802:  MOV     9B0,W3
1804:  ADD     W3,W4,W5
1806:  BTSS.B  20E.0
1808:  BRA     1806
180A:  MOV     212,W0
180C:  MOV.B   W0L,[W5]
.................... 		index++; 
180E:  INC     09B0
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1810:  MOV     9B0,W4
1812:  MOV     #15E,W3
1814:  CP      W3,W4
1816:  BRA     LE,1826
1818:  MOV     9B0,W4
181A:  SUB     W4,#1,W5
181C:  MOV     #818,W4
181E:  ADD     W5,W4,W0
1820:  MOV.B   [W0],W4L
1822:  XOR.B   #24,W4L
1824:  BRA     NZ,1800
....................  
.................... 	OERR=16; 
1826:  MOV.B   #10,W0L
1828:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
182A:  MOV     #818,W4
182C:  MOV     W4,9BA
182E:  PUSH    9B0
1830:  POP     9BC
1832:  CALL    ADE
1836:  MOV     W0,W5
1838:  CP      W5,#1
183A:  BRA     NZ,1858
.................... 		{ 
.................... 			*porton=(int)GetDecVal(InputBuffer,index,'s','t'); 
183C:  MOV     9A8,W5
183E:  MOV.B   #73,W0L
1840:  MOV.B   W0L,9C2
1842:  MOV.B   #74,W0L
1844:  MOV.B   W0L,9C3
1846:  MOV     #818,W4
1848:  MOV     W4,9BE
184A:  PUSH    9B0
184C:  POP     9C0
184E:  CALL    E64
1852:  MOV     W0,[W5]
.................... 			status=1; 
1854:  MOV     #1,W4
1856:  MOV     W4,9AE
.................... 		} 
....................  
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1858:  CLR.B   9C2
185A:  MOV     #818,W4
185C:  MOV     W4,9BE
185E:  MOV     #15E,W4
1860:  MOV     W4,9C0
1862:  CALL    A3E
.................... 	index=0; 
1866:  CLR     9B0
.................... 	printf("GET /DEVICEGPRS/GETPORTOFF/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1868:  MOV     #0,W1
186A:  MOV     W1,W0
186C:  CALL    47A
1870:  INC     W1,W1
1872:  MOV     W1,[W15++]
1874:  BTSC.B  20F.1
1876:  BRA     1874
1878:  MOV     W0,210
187A:  MOV     [--W15],W1
187C:  MOV     #1A,W0
187E:  CPSGT   W1,W0
1880:  BRA     186A
1882:  MOV     9A6,W0
1884:  MOV     #0,W4
1886:  CALL    D6A
188A:  MOV     #1D,W1
188C:  MOV     W1,W0
188E:  CALL    47A
1892:  INC     W1,W1
1894:  MOV     W1,[W15++]
1896:  BTSC.B  20F.1
1898:  BRA     1896
189A:  MOV     W0,210
189C:  MOV     [--W15],W1
189E:  MOV     #49,W0
18A0:  CPSGT   W1,W0
18A2:  BRA     188C
.................... 	while(getc()!='\n'); 
18A4:  BTSS.B  20E.0
18A6:  BRA     18A4
18A8:  MOV     212,W0
18AA:  CP.B    W0L,#A
18AC:  BRA     NZ,18A4
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
18AE:  MOV     #818,W4
18B0:  MOV     9B0,W3
18B2:  ADD     W3,W4,W5
18B4:  BTSS.B  20E.0
18B6:  BRA     18B4
18B8:  MOV     212,W0
18BA:  MOV.B   W0L,[W5]
.................... 		index++; 
18BC:  INC     09B0
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
18BE:  MOV     9B0,W4
18C0:  MOV     #15E,W3
18C2:  CP      W3,W4
18C4:  BRA     LE,18D4
18C6:  MOV     9B0,W4
18C8:  SUB     W4,#1,W5
18CA:  MOV     #818,W4
18CC:  ADD     W5,W4,W0
18CE:  MOV.B   [W0],W4L
18D0:  XOR.B   #24,W4L
18D2:  BRA     NZ,18AE
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
18D4:  MOV     #818,W4
18D6:  MOV     W4,9BA
18D8:  PUSH    9B0
18DA:  POP     9BC
18DC:  CALL    ADE
18E0:  MOV     W0,W5
18E2:  CP      W5,#1
18E4:  BRA     NZ,1902
.................... 		{ 
.................... 			*portoff=(int)GetDecVal(InputBuffer,index,'s','t'); 
18E6:  MOV     9AA,W5
18E8:  MOV.B   #73,W0L
18EA:  MOV.B   W0L,9C2
18EC:  MOV.B   #74,W0L
18EE:  MOV.B   W0L,9C3
18F0:  MOV     #818,W4
18F2:  MOV     W4,9BE
18F4:  PUSH    9B0
18F6:  POP     9C0
18F8:  CALL    E64
18FC:  MOV     W0,[W5]
.................... 			status=1; 
18FE:  MOV     #1,W4
1900:  MOV     W4,9AE
.................... 		} 
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1902:  CLR.B   9C2
1904:  MOV     #818,W4
1906:  MOV     W4,9BE
1908:  MOV     #15E,W4
190A:  MOV     W4,9C0
190C:  CALL    A3E
.................... 	index=0; 
1910:  CLR     9B0
.................... 	printf("GET /DEVICEGPRS/GETPORTIN/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1912:  MOV     #0,W1
1914:  MOV     W1,W0
1916:  CALL    4C8
191A:  INC     W1,W1
191C:  MOV     W1,[W15++]
191E:  BTSC.B  20F.1
1920:  BRA     191E
1922:  MOV     W0,210
1924:  MOV     [--W15],W1
1926:  MOV     #19,W0
1928:  CPSGT   W1,W0
192A:  BRA     1914
192C:  MOV     9A6,W0
192E:  MOV     #0,W4
1930:  CALL    D6A
1934:  MOV     #1C,W1
1936:  MOV     W1,W0
1938:  CALL    4C8
193C:  INC     W1,W1
193E:  MOV     W1,[W15++]
1940:  BTSC.B  20F.1
1942:  BRA     1940
1944:  MOV     W0,210
1946:  MOV     [--W15],W1
1948:  MOV     #48,W0
194A:  CPSGT   W1,W0
194C:  BRA     1936
.................... 	while(getc()!='\n'); 
194E:  BTSS.B  20E.0
1950:  BRA     194E
1952:  MOV     212,W0
1954:  CP.B    W0L,#A
1956:  BRA     NZ,194E
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1958:  MOV     #818,W4
195A:  MOV     9B0,W3
195C:  ADD     W3,W4,W5
195E:  BTSS.B  20E.0
1960:  BRA     195E
1962:  MOV     212,W0
1964:  MOV.B   W0L,[W5]
.................... 		index++; 
1966:  INC     09B0
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1968:  MOV     9B0,W4
196A:  MOV     #15E,W3
196C:  CP      W3,W4
196E:  BRA     LE,197E
1970:  MOV     9B0,W4
1972:  SUB     W4,#1,W5
1974:  MOV     #818,W4
1976:  ADD     W5,W4,W0
1978:  MOV.B   [W0],W4L
197A:  XOR.B   #24,W4L
197C:  BRA     NZ,1958
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
197E:  MOV     #818,W4
1980:  MOV     W4,9BA
1982:  PUSH    9B0
1984:  POP     9BC
1986:  CALL    ADE
198A:  MOV     W0,W5
198C:  CP      W5,#1
198E:  BRA     NZ,19AC
.................... 		{ 
.................... 			*portin=(int)GetDecVal(InputBuffer,index,'s','t'); 
1990:  MOV     9AC,W5
1992:  MOV.B   #73,W0L
1994:  MOV.B   W0L,9C2
1996:  MOV.B   #74,W0L
1998:  MOV.B   W0L,9C3
199A:  MOV     #818,W4
199C:  MOV     W4,9BE
199E:  PUSH    9B0
19A0:  POP     9C0
19A2:  CALL    E64
19A6:  MOV     W0,[W5]
.................... 			status=1; 
19A8:  MOV     #1,W4
19AA:  MOV     W4,9AE
.................... 		} 
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
19AC:  MOV     #32,W0
19AE:  CALL    74E
.................... 	printf("+"); 
19B2:  BTSC.B  20F.1
19B4:  BRA     19B2
19B6:  MOV     #2B,W4
19B8:  MOV     W4,210
.................... 	printf("+"); 
19BA:  BTSC.B  20F.1
19BC:  BRA     19BA
19BE:  MOV     #2B,W4
19C0:  MOV     W4,210
.................... 	printf("+"); 
19C2:  BTSC.B  20F.1
19C4:  BRA     19C2
19C6:  MOV     #2B,W4
19C8:  MOV     W4,210
.................... 	OERR=16; 
19CA:  MOV.B   #10,W0L
19CC:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
19CE:  MOV     #818,W4
19D0:  MOV     W4,9BE
19D2:  CALL    A5E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
19D6:  MOV     #32,W0
19D8:  CALL    74E
.................... 	ClosePort(1); 
19DC:  MOV     #1,W4
19DE:  MOV     W4,9BA
19E0:  CALL    EDA
.................... } 
19E4:  MOV     [--W15],W5
19E6:  RETURN  
.................... /***********ReportData************************************ 
.................... **   Description: Connects to server to report the      ** 
.................... **     current consuptions of current and voltage       ** 
.................... **                                                      ** 
.................... *********************************************************/ 
....................  
.................... void ReportData(int Id, int status) 
.................... { 
*
2884:  MOV     W5,[W15++]
2886:  CLR     9AA
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
2888:  CLR.B   9C2
288A:  MOV     #818,W4
288C:  MOV     W4,9BE
288E:  MOV     #15E,W4
2890:  MOV     W4,9C0
2892:  CALL    A3E
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
2896:  MOV     #0,W1
2898:  MOV     W1,W0
289A:  CALL    1A4
289E:  INC     W1,W1
28A0:  MOV     W1,[W15++]
28A2:  BTSC.B  20F.1
28A4:  BRA     28A2
28A6:  MOV     W0,210
28A8:  MOV     [--W15],W1
28AA:  MOV     #A,W0
28AC:  CPSGT   W1,W0
28AE:  BRA     2898
.................... 	ReadBuffer(InputBuffer); 
28B0:  MOV     #818,W4
28B2:  MOV     W4,9BE
28B4:  CALL    A5E
.................... 	delay_ms(ptime); 
28B8:  MOV     976,W0
28BA:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
28BE:  CLR.B   9C2
28C0:  MOV     #818,W4
28C2:  MOV     W4,9BE
28C4:  MOV     #15E,W4
28C6:  MOV     W4,9C0
28C8:  CALL    A3E
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
28CC:  MOV     #0,W1
28CE:  MOV     W1,W0
28D0:  CALL    1BC
28D4:  INC     W1,W1
28D6:  MOV     W1,[W15++]
28D8:  BTSC.B  20F.1
28DA:  BRA     28D8
28DC:  MOV     W0,210
28DE:  MOV     [--W15],W1
28E0:  MOV     #30,W0
28E2:  CPSGT   W1,W0
28E4:  BRA     28CE
.................... 	ReadBuffer(InputBuffer); 
28E6:  MOV     #818,W4
28E8:  MOV     W4,9BE
28EA:  CALL    A5E
.................... 	delay_ms(ptime); 
28EE:  MOV     976,W0
28F0:  CALL    74E
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer /monitoringgprs/create?id=14&status=0&current=1&voltage=2 
28F4:  CLR.B   9C2
28F6:  MOV     #818,W4
28F8:  MOV     W4,9BE
28FA:  MOV     #15E,W4
28FC:  MOV     W4,9C0
28FE:  CALL    A3E
.................... 	printf("GET /MONITORINGGPRS/CREATE2?ID=%d&STATUS=%d",Id,status); 
2902:  MOV     #0,W1
2904:  MOV     W1,W0
2906:  CALL    516
290A:  INC     W1,W1
290C:  MOV     W1,[W15++]
290E:  BTSC.B  20F.1
2910:  BRA     290E
2912:  MOV     W0,210
2914:  MOV     [--W15],W1
2916:  MOV     #1E,W0
2918:  CPSGT   W1,W0
291A:  BRA     2904
291C:  MOV     9A6,W0
291E:  MOV     #0,W4
2920:  CALL    D6A
2924:  MOV     #21,W1
2926:  MOV     W1,W0
2928:  CALL    516
292C:  INC     W1,W1
292E:  MOV     W1,[W15++]
2930:  BTSC.B  20F.1
2932:  BRA     2930
2934:  MOV     W0,210
2936:  MOV     [--W15],W1
2938:  MOV     #28,W0
293A:  CPSGT   W1,W0
293C:  BRA     2926
293E:  MOV     9A8,W0
2940:  MOV     #0,W4
2942:  CALL    D6A
.................... 	printf("&CURRENT=%f",current); 
2946:  MOV     #0,W1
2948:  MOV     W1,W0
294A:  CALL    550
294E:  INC     W1,W1
2950:  MOV     W1,[W15++]
2952:  BTSC.B  20F.1
2954:  BRA     2952
2956:  MOV     W0,210
2958:  MOV     [--W15],W1
295A:  MOV     #8,W0
295C:  CPSGT   W1,W0
295E:  BRA     2948
2960:  MOV     802,W2
2962:  MOV     800,W1
2964:  MOV     #0,W0
2966:  CALL    215A
296A:  MOV     #2,W9
296C:  MOV     #8008,W10
296E:  CALL    2702
.................... 	printf("&VOLTAGE=%.2f",battery); 
2972:  MOV     #0,W1
2974:  MOV     W1,W0
2976:  CALL    568
297A:  INC     W1,W1
297C:  MOV     W1,[W15++]
297E:  BTSC.B  20F.1
2980:  BRA     297E
2982:  MOV     W0,210
2984:  MOV     [--W15],W1
2986:  MOV     #8,W0
2988:  CPSGT   W1,W0
298A:  BRA     2974
298C:  MOV     806,W2
298E:  MOV     804,W1
2990:  MOV     #0,W0
2992:  CALL    215A
2996:  MOV     #2,W9
2998:  MOV     #8009,W10
299A:  CALL    2702
.................... 	printf("&VAR1=%f",s1); 
299E:  MOV     #0,W1
29A0:  MOV     W1,W0
29A2:  CALL    582
29A6:  INC     W1,W1
29A8:  MOV     W1,[W15++]
29AA:  BTSC.B  20F.1
29AC:  BRA     29AA
29AE:  MOV     W0,210
29B0:  MOV     [--W15],W1
29B2:  MOV     #5,W0
29B4:  CPSGT   W1,W0
29B6:  BRA     29A0
29B8:  MOV     80E,W2
29BA:  MOV     80C,W1
29BC:  MOV     #0,W0
29BE:  CALL    215A
29C2:  MOV     #2,W9
29C4:  MOV     #8008,W10
29C6:  CALL    2702
.................... 	printf("&VAR2=%f HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",s2); 
29CA:  MOV     #0,W1
29CC:  MOV     W1,W0
29CE:  CALL    598
29D2:  INC     W1,W1
29D4:  MOV     W1,[W15++]
29D6:  BTSC.B  20F.1
29D8:  BRA     29D6
29DA:  MOV     W0,210
29DC:  MOV     [--W15],W1
29DE:  MOV     #5,W0
29E0:  CPSGT   W1,W0
29E2:  BRA     29CC
29E4:  MOV     812,W2
29E6:  MOV     810,W1
29E8:  MOV     #0,W0
29EA:  CALL    215A
29EE:  MOV     #2,W9
29F0:  MOV     #8008,W10
29F2:  CALL    2702
29F6:  MOV     #8,W1
29F8:  MOV     W1,W0
29FA:  CALL    598
29FE:  INC     W1,W1
2A00:  MOV     W1,[W15++]
2A02:  BTSC.B  20F.1
2A04:  BRA     2A02
2A06:  MOV     W0,210
2A08:  MOV     [--W15],W1
2A0A:  MOV     #34,W0
2A0C:  CPSGT   W1,W0
2A0E:  BRA     29F8
.................... 		//printf("GET /MONITORINGGPRS/CREATE?ID=9&STATUS=1&CURRENT=6&VOLTAGE=6 HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n"); 
.................... 	while(getc()!='\n'); 
2A10:  BTSS.B  20E.0
2A12:  BRA     2A10
2A14:  MOV     212,W0
2A16:  CP.B    W0L,#A
2A18:  BRA     NZ,2A10
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
2A1A:  MOV     #818,W4
2A1C:  MOV     9AA,W3
2A1E:  ADD     W3,W4,W5
2A20:  BTSS.B  20E.0
2A22:  BRA     2A20
2A24:  MOV     212,W0
2A26:  MOV.B   W0L,[W5]
.................... 		index++; 
2A28:  INC     09AA
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
2A2A:  MOV     9AA,W4
2A2C:  MOV     #15E,W3
2A2E:  CP      W3,W4
2A30:  BRA     LE,2A40
2A32:  MOV     9AA,W4
2A34:  SUB     W4,#1,W5
2A36:  MOV     #818,W4
2A38:  ADD     W5,W4,W0
2A3A:  MOV.B   [W0],W4L
2A3C:  XOR.B   #24,W4L
2A3E:  BRA     NZ,2A1A
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
2A40:  MOV     #32,W0
2A42:  CALL    74E
.................... 	printf("+"); 
2A46:  BTSC.B  20F.1
2A48:  BRA     2A46
2A4A:  MOV     #2B,W4
2A4C:  MOV     W4,210
.................... 	printf("+"); 
2A4E:  BTSC.B  20F.1
2A50:  BRA     2A4E
2A52:  MOV     #2B,W4
2A54:  MOV     W4,210
.................... 	printf("+"); 
2A56:  BTSC.B  20F.1
2A58:  BRA     2A56
2A5A:  MOV     #2B,W4
2A5C:  MOV     W4,210
.................... 	OERR=16; 
2A5E:  MOV.B   #10,W0L
2A60:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
2A62:  MOV     #818,W4
2A64:  MOV     W4,9BE
2A66:  CALL    A5E
.................... 	delay_ms(50); 
2A6A:  MOV     #32,W0
2A6C:  CALL    74E
.................... 	ClosePort(1); 
2A70:  MOV     #1,W4
2A72:  MOV     W4,9BA
2A74:  CALL    EDA
.................... 	delay_ms(5000); 
2A78:  MOV     #1388,W0
2A7A:  CALL    74E
.................... } 
2A7E:  MOV     [--W15],W5
2A80:  RETURN  
....................  
.................... /***********CreateAlert*********************************** 
.................... **   Description: Connects to server to report the      ** 
.................... **     current alert detected by the device             ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void CreateAlert(int Id, int type) 
.................... { 
*
251A:  MOV     W5,[W15++]
251C:  CLR     9AA
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
251E:  CLR.B   9C2
2520:  MOV     #818,W4
2522:  MOV     W4,9BE
2524:  MOV     #15E,W4
2526:  MOV     W4,9C0
2528:  CALL    A3E
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
252C:  MOV     #0,W1
252E:  MOV     W1,W0
2530:  CALL    1A4
2534:  INC     W1,W1
2536:  MOV     W1,[W15++]
2538:  BTSC.B  20F.1
253A:  BRA     2538
253C:  MOV     W0,210
253E:  MOV     [--W15],W1
2540:  MOV     #A,W0
2542:  CPSGT   W1,W0
2544:  BRA     252E
.................... 	ReadBuffer(InputBuffer); 
2546:  MOV     #818,W4
2548:  MOV     W4,9BE
254A:  CALL    A5E
.................... 	PrintBuffer(InputBuffer,ptime); 
254E:  MOV     #818,W4
2550:  MOV     W4,9B0
2552:  PUSH    976
2554:  POP     9B2
2556:  CALL    AA4
.................... 	if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
255A:  MOV     #1E,W4
255C:  MOV     W4,9BC
255E:  MOV     #818,W4
2560:  MOV     W4,9BA
2562:  CALL    ADE
2566:  MOV     W0,W5
2568:  CP      W5,#1
256A:  BRA     NZ,2586
256C:  MOV     #0,W5
256E:  MOV     W5,W0
2570:  CALL    136
2574:  IOR.B   #0,W0L
2576:  BTSC.B  42.1
2578:  BRA     2584
257A:  INC     W5,W5
257C:  MOV.B   W0L,9BC
257E:  CALL    9F2
2582:  BRA     256E
.................... 	else lcd_putc("\fCMD BAD"); 
2584:  BRA     259E
2586:  MOV     #0,W5
2588:  MOV     W5,W0
258A:  CALL    14A
258E:  IOR.B   #0,W0L
2590:  BTSC.B  42.1
2592:  BRA     259E
2594:  INC     W5,W5
2596:  MOV.B   W0L,9BC
2598:  CALL    9F2
259C:  BRA     2588
.................... 	delay_ms(ptime); 
259E:  MOV     976,W0
25A0:  CALL    74E
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
25A4:  CLR.B   9C2
25A6:  MOV     #818,W4
25A8:  MOV     W4,9BE
25AA:  MOV     #15E,W4
25AC:  MOV     W4,9C0
25AE:  CALL    A3E
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
25B2:  MOV     #0,W1
25B4:  MOV     W1,W0
25B6:  CALL    1BC
25BA:  INC     W1,W1
25BC:  MOV     W1,[W15++]
25BE:  BTSC.B  20F.1
25C0:  BRA     25BE
25C2:  MOV     W0,210
25C4:  MOV     [--W15],W1
25C6:  MOV     #30,W0
25C8:  CPSGT   W1,W0
25CA:  BRA     25B4
.................... 	ReadBuffer(InputBuffer); 
25CC:  MOV     #818,W4
25CE:  MOV     W4,9BE
25D0:  CALL    A5E
.................... 	PrintBuffer(InputBuffer,ptime); 
25D4:  MOV     #818,W4
25D6:  MOV     W4,9B0
25D8:  PUSH    976
25DA:  POP     9B2
25DC:  CALL    AA4
.................... 	if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
25E0:  MOV     #1E,W4
25E2:  MOV     W4,9BC
25E4:  MOV     #818,W4
25E6:  MOV     W4,9BA
25E8:  CALL    ADE
25EC:  MOV     W0,W5
25EE:  CP      W5,#1
25F0:  BRA     NZ,260C
25F2:  MOV     #0,W5
25F4:  MOV     W5,W0
25F6:  CALL    136
25FA:  IOR.B   #0,W0L
25FC:  BTSC.B  42.1
25FE:  BRA     260A
2600:  INC     W5,W5
2602:  MOV.B   W0L,9BC
2604:  CALL    9F2
2608:  BRA     25F4
.................... 	else lcd_putc("\fCMD BAD"); 
260A:  BRA     2624
260C:  MOV     #0,W5
260E:  MOV     W5,W0
2610:  CALL    14A
2614:  IOR.B   #0,W0L
2616:  BTSC.B  42.1
2618:  BRA     2624
261A:  INC     W5,W5
261C:  MOV.B   W0L,9BC
261E:  CALL    9F2
2622:  BRA     260E
.................... 	delay_ms(ptime); 
2624:  MOV     976,W0
2626:  CALL    74E
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer /monitoringgprs/create?id=14&status=0&current=1&voltage=2 
262A:  CLR.B   9C2
262C:  MOV     #818,W4
262E:  MOV     W4,9BE
2630:  MOV     #15E,W4
2632:  MOV     W4,9C0
2634:  CALL    A3E
.................... 	printf("GET /ALERTGPRS/CREATE?ID=%d&TYPE=%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id,type); 
2638:  MOV     #0,W1
263A:  MOV     W1,W0
263C:  CALL    5D8
2640:  INC     W1,W1
2642:  MOV     W1,[W15++]
2644:  BTSC.B  20F.1
2646:  BRA     2644
2648:  MOV     W0,210
264A:  MOV     [--W15],W1
264C:  MOV     #18,W0
264E:  CPSGT   W1,W0
2650:  BRA     263A
2652:  MOV     9A6,W0
2654:  MOV     #0,W4
2656:  CALL    D6A
265A:  MOV     #1B,W1
265C:  MOV     W1,W0
265E:  CALL    5D8
2662:  INC     W1,W1
2664:  MOV     W1,[W15++]
2666:  BTSC.B  20F.1
2668:  BRA     2666
266A:  MOV     W0,210
266C:  MOV     [--W15],W1
266E:  MOV     #20,W0
2670:  CPSGT   W1,W0
2672:  BRA     265C
2674:  MOV     9A8,W0
2676:  MOV     #0,W4
2678:  CALL    D6A
267C:  MOV     #23,W1
267E:  MOV     W1,W0
2680:  CALL    5D8
2684:  INC     W1,W1
2686:  MOV     W1,[W15++]
2688:  BTSC.B  20F.1
268A:  BRA     2688
268C:  MOV     W0,210
268E:  MOV     [--W15],W1
2690:  MOV     #4F,W0
2692:  CPSGT   W1,W0
2694:  BRA     267E
.................... 	while(getc()!='\n'); 
2696:  BTSS.B  20E.0
2698:  BRA     2696
269A:  MOV     212,W0
269C:  CP.B    W0L,#A
269E:  BRA     NZ,2696
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
26A0:  MOV     #818,W4
26A2:  MOV     9AA,W3
26A4:  ADD     W3,W4,W5
26A6:  BTSS.B  20E.0
26A8:  BRA     26A6
26AA:  MOV     212,W0
26AC:  MOV.B   W0L,[W5]
.................... 		index++; 
26AE:  INC     09AA
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
26B0:  MOV     9AA,W4
26B2:  MOV     #15E,W3
26B4:  CP      W3,W4
26B6:  BRA     LE,26C6
26B8:  MOV     9AA,W4
26BA:  SUB     W4,#1,W5
26BC:  MOV     #818,W4
26BE:  ADD     W5,W4,W0
26C0:  MOV.B   [W0],W4L
26C2:  XOR.B   #24,W4L
26C4:  BRA     NZ,26A0
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
26C6:  MOV     #32,W0
26C8:  CALL    74E
.................... 	printf("+++\r\n"); 
26CC:  MOV     #0,W1
26CE:  MOV     W1,W0
26D0:  CALL    62A
26D4:  INC     W1,W1
26D6:  MOV     W1,[W15++]
26D8:  BTSC.B  20F.1
26DA:  BRA     26D8
26DC:  MOV     W0,210
26DE:  MOV     [--W15],W1
26E0:  MOV     #4,W0
26E2:  CPSGT   W1,W0
26E4:  BRA     26CE
.................... 	OERR=16; 
26E6:  MOV.B   #10,W0L
26E8:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	PrintBuffer(InputBuffer,1000); 
26EA:  MOV     #818,W4
26EC:  MOV     W4,9B0
26EE:  MOV     #3E8,W4
26F0:  MOV     W4,9B2
26F2:  CALL    AA4
....................  
.................... 	ClosePort(1); 
26F6:  MOV     #1,W4
26F8:  MOV     W4,9BA
26FA:  CALL    EDA
.................... } 
26FE:  MOV     [--W15],W5
2700:  RETURN  
.................... /***********Read ADC************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int16 ReadADC(int channel,int delay, int16 samples) 
.................... { 
*
1F9A:  CLR     9AC
1F9C:  CLR     9AE
.................... 	int sample=0; 
.................... 	int16 measure=0; 
.................... 	set_adc_channel(channel); 
1F9E:  PUSH    9A6
1FA0:  POP     2A6
.................... 	for(sample=0;sample<samples;sample++)	 
1FA2:  CLR     9AC
1FA4:  MOV     9AC,W0
1FA6:  MOV     9AA,W4
1FA8:  CP      W4,W0
1FAA:  BRA     LE,1FC2
.................... 	{ 
.................... 		measure=measure+read_ADC(); 
1FAC:  BCLR.B  2A0.0
1FAE:  BSET.B  2A0.1
1FB0:  BTSS.B  2A0.0
1FB2:  BRA     1FB0
1FB4:  MOV     280,W0
1FB6:  ADD     9AE
.................... 		delay_us(delay); 
1FB8:  MOV     9A8,W0
1FBA:  CALL    1F88
.................... 	} 
1FBE:  INC     09AC
1FC0:  BRA     1FA4
.................... 	measure=measure/samples; 
1FC2:  MOV     9AE,W4
1FC4:  MOV     9AA,W3
1FC6:  REPEAT  #11
1FC8:  DIV.S   W4,W3
1FCA:  MOV     W0,9AE
.................... return measure;	 
1FCC:  PUSH    9AE
1FCE:  POP     0
.................... } 
1FD0:  RETURN  
....................  
....................  
.................... /******************Global variables***********************/ 
.................... int operation_mode=0,lamp_status=0,lamp_statusw=0,alert_status=0;//,alert_type; 
.................... int port_on=0,port_off=0,port_in=0; //New variables used in new operation mode 
.................... int lamp1=0,lamp2=0; 
.................... int set_point=0,histeresys=0; 
.................... int16 Device_Id=21,loops=0; 
....................  
.................... float current=0,battery=0,temp=0,s1=0,s2=0,reference=0; 
....................  
.................... byte DateTime[6]={0,2,13,8,30,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
*
2C32:  MOV     #200,W4
2C34:  MOV     W4,992
2C36:  MOV     #80D,W4
2C38:  MOV     W4,994
2C3A:  MOV     #1E,W4
2C3C:  MOV     W4,996
.................... //byte RiseTime[6]={25,2,13,19,27,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
.................... //byte SetTime[6]={25,2,13,19,29,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
.................... byte dow1=0; 
....................  
.................... /*struct ADC_Channels 
.................... { 
.................... 	float value; 
.................... 	char  name[10]; 
.................... 	char  unit[4];	 
....................  
.................... }ADC_Channels[7];*/ 
....................  
.................... //new datetime variables for new operation mode 
.................... byte OnTime[6]={25,2,13,19,27,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
2C3E:  MOV     #219,W4
2C40:  MOV     W4,99A
2C42:  MOV     #130D,W4
2C44:  MOV     W4,99C
2C46:  MOV     #1B,W4
2C48:  MOV     W4,99E
.................... byte OffTime[6]={25,2,13,19,29,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
2C4A:  MOV     #219,W4
2C4C:  MOV     W4,9A0
2C4E:  MOV     #130D,W4
2C50:  MOV     W4,9A2
2C52:  MOV     #1D,W4
2C54:  MOV     W4,9A4
....................  
.................... /******************Main function, program****************/ 
.................... void main(void) 
.................... {	 
*
2A82:  BSET.B  81.7
2A84:  MOV     #8000,W4
2A86:  MOV     W4,20C
2A88:  MOV     #400,W4
2A8A:  MOV     W4,20E
2A8C:  MOV     #3,W4
2A8E:  MOV     W4,214
2A90:  MOV     #64,W4
2A92:  MOV     W4,976
2A94:  CLR     978
2A96:  CLR     97A
2A98:  CLR     97C
2A9A:  CLR     97E
2A9C:  CLR     980
2A9E:  CLR     982
2AA0:  CLR     984
2AA2:  CLR     986
2AA4:  CLR     988
2AA6:  CLR     98A
2AA8:  CLR     98C
2AAA:  MOV     #15,W4
2AAC:  MOV     W4,98E
2AAE:  CLR     990
2AB0:  CLR     800
2AB2:  CLR     802
2AB4:  CLR     804
2AB6:  CLR     806
2AB8:  CLR     808
2ABA:  CLR     80A
2ABC:  CLR     80C
2ABE:  CLR     80E
2AC0:  CLR     810
2AC2:  CLR     812
2AC4:  CLR     814
2AC6:  CLR     816
2AC8:  CLR.B   998
2ACA:  SETM    2A8
2ACC:  MOV     #F80,W15
2ACE:  MOV     #FFF,W0
2AD0:  MOV     W0,20
2AD2:  NOP     
.................... 	//***Component initializers**** 
.................... 	lcd_init();        //LCD INITIALIZE 
*
2C56:  CALL    880
.................... 	//init_dac();      //MPC4921 DAC INITIALIZE 
.................... 	rtc_init();		   //DS1302 RTC INITIALIZE 
2C5A:  CALL    984
.................... 	//***Device initialize********* 
.................... 	lcd_putc("\fTelegestion UTCH"); 
2C5E:  MOV     #0,W5
2C60:  MOV     W5,W0
2C62:  CALL    63C
2C66:  IOR.B   #0,W0L
2C68:  BTSC.B  42.1
2C6A:  BRA     2C76
2C6C:  INC     W5,W5
2C6E:  MOV.B   W0L,9BC
2C70:  CALL    9F2
2C74:  BRA     2C60
.................... 	delay_ms(100); 
2C76:  MOV     #64,W0
2C78:  CALL    74E
.................... 	setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN5|sAN6);//*******Setup CH0-CH6 as ADC 
2C7C:  MOV     #FF80,W4
2C7E:  MOV     W4,2A8
2C80:  CLR     2A2
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
2C82:  MOV     #80,W4
2C84:  MOV     W4,2A4
2C86:  MOV     #80E0,W4
2C88:  MOV     W4,2A0
.................... 	//******Configure PORTB*********** 
.................... 	SET_TRIS_B(0x007F);   //PB0-PB6 as input, PB7-PB15 as output 
2C8A:  MOV     #7F,W4
2C8C:  MOV     W4,2C6
.................... 	//******Clear RS232 error********** 
.................... 	OERR=16; 
2C8E:  MOV.B   #10,W0L
2C90:  MOV.B   W0L,20E
.................... 	//******Configure GPRS device****** 
.................... 	ConfigureGPRS();	 
2C92:  CALL    B18
.................... 	//******Set datetime***************** 
.................... 	switch(ConfigureDatetime(Device_Id, DateTime)) 
.................... 	{ 
2C96:  PUSH    98E
2C98:  POP     9A6
2C9A:  MOV     #992,W4
2C9C:  MOV     W4,9A8
2C9E:  CALL    F24
2CA2:  XOR     #0,W0
2CA4:  BRA     Z,2CAC
2CA6:  XOR     #1,W0
2CA8:  BRA     Z,2CC6
2CAA:  BRA     2D7C
.................... 		case 0: 
.................... 			lcd_putc("\fCMD BAD"); 
2CAC:  MOV     #0,W5
2CAE:  MOV     W5,W0
2CB0:  CALL    14A
2CB4:  IOR.B   #0,W0L
2CB6:  BTSC.B  42.1
2CB8:  BRA     2CC4
2CBA:  INC     W5,W5
2CBC:  MOV.B   W0L,9BC
2CBE:  CALL    9F2
2CC2:  BRA     2CAE
.................... 		break; 
2CC4:  BRA     2D96
.................... 		case 1: 
.................... 			rtc_set_datetime(DateTime[day_],DateTime[month_],DateTime[year_],dow1,DateTime[hour_],DateTime[min_]); 
2CC6:  MOV.B   992,W0L
2CC8:  MOV.B   W0L,9A6
2CCA:  MOV.B   993,W0L
2CCC:  MOV.B   W0L,9A7
2CCE:  MOV.B   994,W0L
2CD0:  MOV.B   W0L,9A8
2CD2:  MOV.B   998,W0L
2CD4:  MOV.B   W0L,9A9
2CD6:  MOV.B   995,W0L
2CD8:  MOV.B   W0L,9AA
2CDA:  MOV.B   996,W0L
2CDC:  MOV.B   W0L,9AB
2CDE:  CALL    10D0
.................... 			lcd_putc("\f"); 
2CE2:  MOV     #0,W5
2CE4:  MOV     W5,W0
2CE6:  CALL    110
2CEA:  IOR.B   #0,W0L
2CEC:  BTSC.B  42.1
2CEE:  BRA     2CFA
2CF0:  INC     W5,W5
2CF2:  MOV.B   W0L,9BC
2CF4:  CALL    9F2
2CF8:  BRA     2CE4
.................... 			lcd_putc("Datetime:\n"); 
2CFA:  MOV     #0,W5
2CFC:  MOV     W5,W0
2CFE:  CALL    65A
2D02:  IOR.B   #0,W0L
2D04:  BTSC.B  42.1
2D06:  BRA     2D12
2D08:  INC     W5,W5
2D0A:  MOV.B   W0L,9BC
2D0C:  CALL    9F2
2D10:  BRA     2CFC
.................... 			printf(lcd_putc,"%d/%d/20%d %02d:%02d",DateTime[day_],DateTime[month_],DateTime[year_],DateTime[hour_],DateTime[min_]); 
2D12:  MOV.B   992,W0L
2D14:  SE      W0,W0
2D16:  MOV     #0,W4
2D18:  CALL    116E
2D1C:  MOV.B   #2F,W0L
2D1E:  MOV.B   W0L,9BC
2D20:  CALL    9F2
2D24:  MOV.B   993,W0L
2D26:  SE      W0,W0
2D28:  MOV     #0,W4
2D2A:  CALL    116E
2D2E:  MOV.B   #2F,W0L
2D30:  MOV.B   W0L,9BC
2D32:  CALL    9F2
2D36:  MOV.B   #32,W0L
2D38:  MOV.B   W0L,9BC
2D3A:  CALL    9F2
2D3E:  MOV.B   #30,W0L
2D40:  MOV.B   W0L,9BC
2D42:  CALL    9F2
2D46:  MOV.B   994,W0L
2D48:  SE      W0,W0
2D4A:  MOV     #0,W4
2D4C:  CALL    116E
2D50:  MOV.B   #20,W0L
2D52:  MOV.B   W0L,9BC
2D54:  CALL    9F2
2D58:  MOV.B   995,W0L
2D5A:  SE      W0,W0
2D5C:  MOV     #8002,W4
2D5E:  CALL    116E
2D62:  MOV.B   #3A,W0L
2D64:  MOV.B   W0L,9BC
2D66:  CALL    9F2
2D6A:  MOV.B   996,W0L
2D6C:  SE      W0,W0
2D6E:  MOV     #8002,W4
2D70:  CALL    116E
.................... 			delay_ms(1000); 
2D74:  MOV     #3E8,W0
2D76:  CALL    74E
.................... 		break; 
2D7A:  BRA     2D96
.................... 		default: 
.................... 			lcd_putc("\fCMD BAD"); 
2D7C:  MOV     #0,W5
2D7E:  MOV     W5,W0
2D80:  CALL    14A
2D84:  IOR.B   #0,W0L
2D86:  BTSC.B  42.1
2D88:  BRA     2D94
2D8A:  INC     W5,W5
2D8C:  MOV.B   W0L,9BC
2D8E:  CALL    9F2
2D92:  BRA     2D7E
.................... 		break; 
2D94:  BRA     2D96
....................  
.................... 	} 
.................... 	//ClosePort(1); 
.................... 	//***While loop, main program starts here*** 
.................... 	while(TRUE) 
.................... 	{//*****Start of while loop**************        
.................... 		for(loops=0;loops<2;loops++) 
2D96:  CLR     990
2D98:  MOV     990,W4
2D9A:  CP      W4,#2
2D9C:  BRA     GE,3456
.................... 		{//*****Start of for loop************** 
.................... 			//**********BUZZER******************** 
.................... 			output_bit(PIN_D9,alert_status);  //BUZZER depend of alert state 
2D9E:  CP0     97E
2DA0:  BRA     NZ,2DA6
2DA2:  BCLR.B  2D7.1
2DA4:  BRA     2DA8
2DA6:  BSET.B  2D7.1
2DA8:  BCLR.B  2D3.1
.................... 			//**********GPO*********************** 
.................... 			//******Get status/mode*********************** 
.................... 			lcd_putc("\fGetting data\nfrom server.+."); 
2DAA:  MOV     #0,W5
2DAC:  MOV     W5,W0
2DAE:  CALL    672
2DB2:  IOR.B   #0,W0L
2DB4:  BTSC.B  42.1
2DB6:  BRA     2DC2
2DB8:  INC     W5,W5
2DBA:  MOV.B   W0L,9BC
2DBC:  CALL    9F2
2DC0:  BRA     2DAC
.................... 			GetMode(Device_Id,&operation_mode,&lamp_statusw);	 
2DC2:  PUSH    98E
2DC4:  POP     9A6
2DC6:  MOV     #978,W4
2DC8:  MOV     W4,9A8
2DCA:  MOV     #97C,W4
2DCC:  MOV     W4,9AA
2DCE:  CALL    1268
.................... 			delay_ms(1500);		 
2DD2:  MOV     #5DC,W0
2DD4:  CALL    74E
.................... 			switch(operation_mode) 
.................... 			{ 
2DD8:  MOV     978,W0
2DDA:  XOR     #1,W0
2DDC:  BRA     Z,2DE8
2DDE:  XOR     #2,W0
2DE0:  BRA     Z,2E6A
2DE2:  XOR     #1,W0
2DE4:  BRA     Z,2F64
2DE6:  BRA     2F78
.................... 				case Timmer_Mode: 
.................... 					GetOnTime(Device_Id,OnTime); 
2DE8:  PUSH    98E
2DEA:  POP     9A6
2DEC:  MOV     #99A,W4
2DEE:  MOV     W4,9A8
2DF0:  CALL    146C
.................... 					GetOffTime(Device_Id,OffTime); 
2DF4:  PUSH    98E
2DF6:  POP     9A6
2DF8:  MOV     #9A0,W4
2DFA:  MOV     W4,9A8
2DFC:  CALL    15D0
.................... 					GetPort(Device_Id,&port_on,&port_off,&port_in); 
2E00:  PUSH    98E
2E02:  POP     9A6
2E04:  MOV     #980,W4
2E06:  MOV     W4,9A8
2E08:  MOV     #982,W4
2E0A:  MOV     W4,9AA
2E0C:  MOV     #984,W4
2E0E:  MOV     W4,9AC
2E10:  CALL    173A
.................... 					if(DateTime[hour_]==OnTime[hour_]&&((DateTime[min_]>=(OnTime[min_]-1))&&(DateTime[min_]<=(OnTime[min_]+1)))) lamp_status=port_on; 
2E14:  MOV.B   995,W0L
2E16:  CP.B    99D
2E18:  BRA     NZ,2E38
2E1A:  MOV     99E,W4
2E1C:  SUB.B   W4L,#1,W0L
2E1E:  MOV     996,W4
2E20:  CP.B    W4L,W0L
2E22:  BRA     NC,2E38
2E24:  MOV     99E,W4
2E26:  ADD.B   W4L,#1,W4L
2E28:  MOV.B   W4L,W0L
2E2A:  MOV.B   W0L,0
2E2C:  MOV     996,W4
2E2E:  CP.B    W4L,W0L
2E30:  BRA     GTU,2E38
2E32:  PUSH    980
2E34:  POP     97A
.................... 					else if(DateTime[hour_]==OffTime[hour_]&&((DateTime[min_]>=(OffTime[min_]-1))&&(DateTime[min_]<=(OffTime[min_]+1)))) lamp_status=port_off; 
2E36:  BRA     2E5A
2E38:  MOV.B   995,W0L
2E3A:  CP.B    9A3
2E3C:  BRA     NZ,2E5A
2E3E:  MOV     9A4,W4
2E40:  SUB.B   W4L,#1,W0L
2E42:  MOV     996,W4
2E44:  CP.B    W4L,W0L
2E46:  BRA     NC,2E5A
2E48:  MOV     9A4,W4
2E4A:  ADD.B   W4L,#1,W4L
2E4C:  MOV.B   W4L,W0L
2E4E:  MOV.B   W0L,0
2E50:  MOV     996,W4
2E52:  CP.B    W4L,W0L
2E54:  BRA     GTU,2E5A
2E56:  PUSH    982
2E58:  POP     97A
.................... 					//else lamp_status=0; 
.................... 					lamp1= (lamp_status&0x01); lamp2=(lamp_status&0x02)>>1; 
2E5A:  MOV     97A,W0
2E5C:  AND     W0,#1,W0
2E5E:  MOV     W0,986
2E60:  MOV     97A,W0
2E62:  AND     W0,#2,W5
2E64:  MOV     W5,988
2E66:  LSR     988
.................... 				break;	 
2E68:  BRA     2F7A
.................... 				case Automated_Mode: 
.................... 					GetAutomated(Device_Id,&set_point,&histeresys); 
2E6A:  PUSH    98E
2E6C:  POP     9A6
2E6E:  MOV     #98A,W4
2E70:  MOV     W4,9A8
2E72:  MOV     #98C,W4
2E74:  MOV     W4,9AA
2E76:  CALL    19E8
.................... 					GetPort(Device_Id,&port_on,&port_off,&port_in); 
2E7A:  PUSH    98E
2E7C:  POP     9A6
2E7E:  MOV     #980,W4
2E80:  MOV     W4,9A8
2E82:  MOV     #982,W4
2E84:  MOV     W4,9AA
2E86:  MOV     #984,W4
2E88:  MOV     W4,9AC
2E8A:  CALL    173A
.................... 					if(S1>set_point+histeresys) lamp_status=port_on; 
2E8E:  MOV     98A,W0
2E90:  ADD     98C,W0
2E92:  CALL    1BEC
2E96:  MOV     80C,W2
2E98:  MOV     80E,W3
2E9A:  CALL    1C36
2E9E:  BRA     NC,2EA6
2EA0:  PUSH    980
2EA2:  POP     97A
.................... 					else if(S1<set_point-histeresys) lamp_status=port_off; 
2EA4:  BRA     2F54
2EA6:  MOV     98A,W4
2EA8:  MOV     98C,W3
2EAA:  SUB     W4,W3,W0
2EAC:  CALL    1BEC
2EB0:  MOV     W0,W2
2EB2:  MOV     W1,W3
2EB4:  MOV     80C,W0
2EB6:  MOV     80E,W1
2EB8:  CALL    1C36
2EBC:  BRA     NC,2EC4
2EBE:  PUSH    982
2EC0:  POP     97A
.................... 					else if((S1<set_point+0.9)&&(S1>set_point-0.9)) lamp_status=port_off;	 
2EC2:  BRA     2F54
2EC4:  MOV     98A,W5
2EC6:  MOV     W5,W0
2EC8:  CLR     W3
2ECA:  BTSC    W0.F
2ECC:  SETM    W3
2ECE:  MOV     W3,W1
2ED0:  MOV     W3,W2
2ED2:  CALL    1C9E
2ED6:  BCLR.B  43.0
2ED8:  MOV     W5,[W15++]
2EDA:  MOV     #CCCD,W4
2EDC:  MOV     #CCCC,W5
2EDE:  MOV     #CCCC,W6
2EE0:  MOV     #3FEC,W7
2EE2:  CALL    1D02
2EE6:  MOV     [--W15],W5
2EE8:  MOV     80C,W5
2EEA:  MOV     80E,W6
2EEC:  CLR     W8
2EEE:  BTSC    W6.F
2EF0:  SETM    W8
2EF2:  MOV     W8,W7
2EF4:  MOV     W5,[W15++]
2EF6:  MOV     W0,W4
2EF8:  MOV     W5,W0
2EFA:  MOV     W1,W5
2EFC:  MOV     W6,W1
2EFE:  MOV     W2,W6
2F00:  MOV     W7,W2
2F02:  MOV     W3,W7
2F04:  MOV     W8,W3
2F06:  CALL    1EDE
2F0A:  MOV     [--W15],W5
2F0C:  BRA     NC,2F54
2F0E:  MOV     98A,W5
2F10:  MOV     W5,W0
2F12:  CLR     W3
2F14:  BTSC    W0.F
2F16:  SETM    W3
2F18:  MOV     W3,W1
2F1A:  MOV     W3,W2
2F1C:  CALL    1C9E
2F20:  BSET.B  43.0
2F22:  MOV     W5,[W15++]
2F24:  MOV     #CCCD,W4
2F26:  MOV     #CCCC,W5
2F28:  MOV     #CCCC,W6
2F2A:  MOV     #3FEC,W7
2F2C:  CALL    1D02
2F30:  MOV     [--W15],W5
2F32:  MOV     80C,W5
2F34:  MOV     80E,W6
2F36:  CLR     W8
2F38:  BTSC    W6.F
2F3A:  SETM    W8
2F3C:  MOV     W8,W7
2F3E:  MOV     W5,[W15++]
2F40:  MOV     W5,W4
2F42:  MOV     W6,W5
2F44:  MOV     W7,W6
2F46:  MOV     W8,W7
2F48:  CALL    1EDE
2F4C:  MOV     [--W15],W5
2F4E:  BRA     NC,2F54
2F50:  PUSH    982
2F52:  POP     97A
.................... 					lamp1= (lamp_status&0x01); lamp2=(lamp_status&0x02)>>1;				 
2F54:  MOV     97A,W0
2F56:  AND     W0,#1,W0
2F58:  MOV     W0,986
2F5A:  MOV     97A,W0
2F5C:  AND     W0,#2,W5
2F5E:  MOV     W5,988
2F60:  LSR     988
.................... 				break;	 
2F62:  BRA     2F7A
.................... 				case Manual_Mode: 
.................... 					lamp_status=lamp_statusw; 
2F64:  PUSH    97C
2F66:  POP     97A
.................... 					lamp1= (lamp_status&0x01); lamp2=(lamp_status&0x02)>>1; 
2F68:  MOV     97A,W0
2F6A:  AND     W0,#1,W0
2F6C:  MOV     W0,986
2F6E:  MOV     97A,W0
2F70:  AND     W0,#2,W5
2F72:  MOV     W5,988
2F74:  LSR     988
.................... 				break;	 
2F76:  BRA     2F7A
.................... 				default: 
.................... 				break; 
2F78:  BRA     2F7A
.................... 			}						 
.................... 			output_bit(PIN_B7,lamp1);	output_bit(PIN_B8,lamp2);					 
2F7A:  CP0     986
2F7C:  BRA     NZ,2F82
2F7E:  BCLR.B  2CA.7
2F80:  BRA     2F84
2F82:  BSET.B  2CA.7
2F84:  MOV     #7E,W4
2F86:  MOV     W4,2C6
2F88:  CP0     988
2F8A:  BRA     NZ,2F90
2F8C:  BCLR.B  2CB.0
2F8E:  BRA     2F92
2F90:  BSET.B  2CB.0
2F92:  MOV     #7E,W4
2F94:  MOV     W4,2C6
.................... 			//******RTC Get and show datetime***** 
.................... 			lcd_putc("\f"); 
2F96:  MOV     #0,W5
2F98:  MOV     W5,W0
2F9A:  CALL    110
2F9E:  IOR.B   #0,W0L
2FA0:  BTSC.B  42.1
2FA2:  BRA     2FAE
2FA4:  INC     W5,W5
2FA6:  MOV.B   W0L,9BC
2FA8:  CALL    9F2
2FAC:  BRA     2F98
.................... 			lcd_putc("Datetime:\n"); 
2FAE:  MOV     #0,W5
2FB0:  MOV     W5,W0
2FB2:  CALL    65A
2FB6:  IOR.B   #0,W0L
2FB8:  BTSC.B  42.1
2FBA:  BRA     2FC6
2FBC:  INC     W5,W5
2FBE:  MOV.B   W0L,9BC
2FC0:  CALL    9F2
2FC4:  BRA     2FB0
.................... 			rtc_get_date(DateTime[day_],DateTime[month_],DateTime[year_],dow1); 
.................... 			rtc_get_time(DateTime[hour_],DateTime[min_],DateTime[sec_]); 
.................... 			printf(lcd_putc,"%d/%d/20%d %02d:%02d",DateTime[day_],DateTime[month_],DateTime[year_],DateTime[hour_],DateTime[min_]); 
*
3060:  MOV.B   992,W0L
3062:  SE      W0,W0
3064:  MOV     #0,W4
3066:  CALL    116E
306A:  MOV.B   #2F,W0L
306C:  MOV.B   W0L,9BC
306E:  CALL    9F2
3072:  MOV.B   993,W0L
3074:  SE      W0,W0
3076:  MOV     #0,W4
3078:  CALL    116E
307C:  MOV.B   #2F,W0L
307E:  MOV.B   W0L,9BC
3080:  CALL    9F2
3084:  MOV.B   #32,W0L
3086:  MOV.B   W0L,9BC
3088:  CALL    9F2
308C:  MOV.B   #30,W0L
308E:  MOV.B   W0L,9BC
3090:  CALL    9F2
3094:  MOV.B   994,W0L
3096:  SE      W0,W0
3098:  MOV     #0,W4
309A:  CALL    116E
309E:  MOV.B   #20,W0L
30A0:  MOV.B   W0L,9BC
30A2:  CALL    9F2
30A6:  MOV.B   995,W0L
30A8:  SE      W0,W0
30AA:  MOV     #8002,W4
30AC:  CALL    116E
30B0:  MOV.B   #3A,W0L
30B2:  MOV.B   W0L,9BC
30B4:  CALL    9F2
30B8:  MOV.B   996,W0L
30BA:  SE      W0,W0
30BC:  MOV     #8002,W4
30BE:  CALL    116E
.................... 			delay_ms(2000); 
30C2:  MOV     #7D0,W0
30C4:  CALL    74E
....................  
.................... 			//******Get and show status/mode******* 
.................... 			lcd_putc("\f"); 
30C8:  MOV     #0,W5
30CA:  MOV     W5,W0
30CC:  CALL    110
30D0:  IOR.B   #0,W0L
30D2:  BTSC.B  42.1
30D4:  BRA     30E0
30D6:  INC     W5,W5
30D8:  MOV.B   W0L,9BC
30DA:  CALL    9F2
30DE:  BRA     30CA
.................... 			printf(lcd_putc,"Mode: %d\nStatus: %d",operation_mode,lamp_status); 
30E0:  MOV     #0,W1
30E2:  MOV     W1,W0
30E4:  CALL    69C
30E8:  INC     W1,W1
30EA:  MOV     W1,[W15++]
30EC:  MOV.B   W0L,9BC
30EE:  CALL    9F2
30F2:  MOV     [--W15],W1
30F4:  MOV     #5,W0
30F6:  CPSGT   W1,W0
30F8:  BRA     30E2
30FA:  MOV     978,W0
30FC:  MOV     #0,W4
30FE:  CALL    116E
3102:  MOV     #8,W1
3104:  MOV     W1,W0
3106:  CALL    69C
310A:  INC     W1,W1
310C:  MOV     W1,[W15++]
310E:  MOV.B   W0L,9BC
3110:  CALL    9F2
3114:  MOV     [--W15],W1
3116:  MOV     #10,W0
3118:  CPSGT   W1,W0
311A:  BRA     3104
311C:  MOV     97A,W0
311E:  MOV     #0,W4
3120:  CALL    116E
.................... 			delay_ms(2000); 
3124:  MOV     #7D0,W0
3126:  CALL    74E
....................  
.................... 			//******Get and show ADC values*** 
.................... 			temp=ReadADC(TEMP_ch,100,10); 
312A:  CLR     9A6
312C:  MOV     #64,W4
312E:  MOV     W4,9A8
3130:  MOV     #A,W4
3132:  MOV     W4,9AA
3134:  CALL    1F9A
3138:  CALL    1BEC
313C:  MOV     W0,808
313E:  MOV     W1,80A
.................... 			current=ReadADC(CURRENT_ch,100,10); 
3140:  MOV     #1,W4
3142:  MOV     W4,9A6
3144:  MOV     #64,W4
3146:  MOV     W4,9A8
3148:  MOV     #A,W4
314A:  MOV     W4,9AA
314C:  CALL    1F9A
3150:  CALL    1BEC
3154:  MOV     W0,800
3156:  MOV     W1,802
.................... 			s1=ReadADC(SENSOR1_ch,100,10); 
3158:  MOV     #3,W4
315A:  MOV     W4,9A6
315C:  MOV     #64,W4
315E:  MOV     W4,9A8
3160:  MOV     #A,W4
3162:  MOV     W4,9AA
3164:  CALL    1F9A
3168:  CALL    1BEC
316C:  MOV     W0,80C
316E:  MOV     W1,80E
.................... 			s2=ReadADC(SENSOR2_ch,100,10); 
3170:  MOV     #4,W4
3172:  MOV     W4,9A6
3174:  MOV     #64,W4
3176:  MOV     W4,9A8
3178:  MOV     #A,W4
317A:  MOV     W4,9AA
317C:  CALL    1F9A
3180:  CALL    1BEC
3184:  MOV     W0,810
3186:  MOV     W1,812
.................... 			reference=ReadADC(REFERENCE_ch,100,10); 
3188:  MOV     #6,W4
318A:  MOV     W4,9A6
318C:  MOV     #64,W4
318E:  MOV     W4,9A8
3190:  MOV     #A,W4
3192:  MOV     W4,9AA
3194:  CALL    1F9A
3198:  CALL    1BEC
319C:  MOV     W0,814
319E:  MOV     W1,816
.................... 			battery=ReadADC(POWER_ch,100,10); 
31A0:  MOV     #5,W4
31A2:  MOV     W4,9A6
31A4:  MOV     #64,W4
31A6:  MOV     W4,9A8
31A8:  MOV     #A,W4
31AA:  MOV     W4,9AA
31AC:  CALL    1F9A
31B0:  CALL    1BEC
31B4:  MOV     W0,804
31B6:  MOV     W1,806
....................  
.................... 			reference=0.412/reference; 
31B8:  MOV     #F1AA,W0
31BA:  MOV     #3ED2,W1
31BC:  MOV     814,W2
31BE:  MOV     816,W3
31C0:  CALL    1FD2
31C4:  MOV     W0,814
31C6:  MOV     W1,816
.................... 			temp=(temp*reference)*1000; 
31C8:  MOV     808,W0
31CA:  MOV     80A,W1
31CC:  MOV     814,W2
31CE:  MOV     816,W3
31D0:  CALL    209C
31D4:  MOV     W0,W5
31D6:  MOV     W1,W6
31D8:  MOV     W5,W0
31DA:  MOV     W6,W1
31DC:  MOV     #0,W2
31DE:  MOV     #447A,W3
31E0:  CALL    209C
31E4:  MOV     W0,808
31E6:  MOV     W1,80A
.................... 			current=(current*reference)*8; 
31E8:  MOV     800,W0
31EA:  MOV     802,W1
31EC:  MOV     814,W2
31EE:  MOV     816,W3
31F0:  CALL    209C
31F4:  MOV     W0,W5
31F6:  MOV     W1,W6
31F8:  MOV     W5,W0
31FA:  MOV     W6,W1
31FC:  MOV     #0,W2
31FE:  MOV     #4100,W3
3200:  CALL    209C
3204:  MOV     W0,800
3206:  MOV     W1,802
.................... 			battery=(battery*reference)*3.11;	 
3208:  MOV     804,W0
320A:  MOV     806,W1
320C:  MOV     814,W2
320E:  MOV     816,W3
3210:  CALL    209C
3214:  MOV     W0,W5
3216:  MOV     W1,W6
3218:  MOV     W5,W0
321A:  MOV     W6,W1
321C:  MOV     #A3D,W2
321E:  MOV     #4047,W3
3220:  CALL    209C
3224:  MOV     W0,804
3226:  MOV     W1,806
.................... 			s1=s1*reference/.165; 	//165 Ohms resitor in serie with sensor, (v/165)*1000 (in mA) 
3228:  MOV     80C,W0
322A:  MOV     80E,W1
322C:  MOV     814,W2
322E:  MOV     816,W3
3230:  CALL    209C
3234:  MOV     W0,W5
3236:  MOV     W1,W6
3238:  MOV     W5,W0
323A:  MOV     W6,W1
323C:  MOV     #F5C3,W2
323E:  MOV     #3E28,W3
3240:  CALL    1FD2
3244:  MOV     W0,80C
3246:  MOV     W1,80E
.................... 			s2=s2*reference/.165;	//165 Ohms resitor in serie with sensor, (v/165)*1000 (in mA) 
3248:  MOV     810,W0
324A:  MOV     812,W1
324C:  MOV     814,W2
324E:  MOV     816,W3
3250:  CALL    209C
3254:  MOV     W0,W5
3256:  MOV     W1,W6
3258:  MOV     W5,W0
325A:  MOV     W6,W1
325C:  MOV     #F5C3,W2
325E:  MOV     #3E28,W3
3260:  CALL    1FD2
3264:  MOV     W0,810
3266:  MOV     W1,812
....................  
.................... 			lcd_putc("\f"); 
3268:  MOV     #0,W5
326A:  MOV     W5,W0
326C:  CALL    110
3270:  IOR.B   #0,W0L
3272:  BTSC.B  42.1
3274:  BRA     3280
3276:  INC     W5,W5
3278:  MOV.B   W0L,9BC
327A:  CALL    9F2
327E:  BRA     326A
.................... 			printf(lcd_putc,"Battery= %6.3fV",battery); 
3280:  MOV     #0,W1
3282:  MOV     W1,W0
3284:  CALL    6BC
3288:  INC     W1,W1
328A:  MOV     W1,[W15++]
328C:  MOV.B   W0L,9BC
328E:  CALL    9F2
3292:  MOV     [--W15],W1
3294:  MOV     #8,W0
3296:  CPSGT   W1,W0
3298:  BRA     3282
329A:  MOV     806,W2
329C:  MOV     804,W1
329E:  MOV     #0,W0
32A0:  CALL    215A
32A4:  MOV     #3,W9
32A6:  MOV     #5,W10
32A8:  CALL    2398
32AC:  MOV.B   #56,W0L
32AE:  MOV.B   W0L,9BC
32B0:  CALL    9F2
.................... 			delay_ms(LCD_Delay); 
32B4:  MOV     #7D0,W0
32B6:  CALL    74E
.................... 			lcd_putc("\f"); 
32BA:  MOV     #0,W5
32BC:  MOV     W5,W0
32BE:  CALL    110
32C2:  IOR.B   #0,W0L
32C4:  BTSC.B  42.1
32C6:  BRA     32D2
32C8:  INC     W5,W5
32CA:  MOV.B   W0L,9BC
32CC:  CALL    9F2
32D0:  BRA     32BC
.................... 			printf(lcd_putc,"Current: %6.3fA\nTemperature: %6.3fmV",current,temp);//1.1,1.1);//current,temp); 
32D2:  MOV     #0,W1
32D4:  MOV     W1,W0
32D6:  CALL    6D8
32DA:  INC     W1,W1
32DC:  MOV     W1,[W15++]
32DE:  MOV.B   W0L,9BC
32E0:  CALL    9F2
32E4:  MOV     [--W15],W1
32E6:  MOV     #8,W0
32E8:  CPSGT   W1,W0
32EA:  BRA     32D4
32EC:  MOV     802,W2
32EE:  MOV     800,W1
32F0:  MOV     #0,W0
32F2:  CALL    215A
32F6:  MOV     #3,W9
32F8:  MOV     #5,W10
32FA:  CALL    2398
32FE:  MOV     #E,W1
3300:  MOV     W1,W0
3302:  CALL    6D8
3306:  INC     W1,W1
3308:  MOV     W1,[W15++]
330A:  MOV.B   W0L,9BC
330C:  CALL    9F2
3310:  MOV     [--W15],W1
3312:  MOV     #1C,W0
3314:  CPSGT   W1,W0
3316:  BRA     3300
3318:  MOV     80A,W2
331A:  MOV     808,W1
331C:  MOV     #0,W0
331E:  CALL    215A
3322:  MOV     #3,W9
3324:  MOV     #5,W10
3326:  CALL    2398
332A:  MOV.B   #6D,W0L
332C:  MOV.B   W0L,9BC
332E:  CALL    9F2
3332:  MOV.B   #56,W0L
3334:  MOV.B   W0L,9BC
3336:  CALL    9F2
.................... 			delay_ms(LCD_Delay); 
333A:  MOV     #7D0,W0
333C:  CALL    74E
.................... 			lcd_putc("\f"); 
3340:  MOV     #0,W5
3342:  MOV     W5,W0
3344:  CALL    110
3348:  IOR.B   #0,W0L
334A:  BTSC.B  42.1
334C:  BRA     3358
334E:  INC     W5,W5
3350:  MOV.B   W0L,9BC
3352:  CALL    9F2
3356:  BRA     3342
.................... 			printf(lcd_putc,"Reference= \n%6.3fmV",(reference*1000)); 
3358:  MOV     814,W0
335A:  MOV     816,W1
335C:  MOV     #0,W2
335E:  MOV     #447A,W3
3360:  CALL    209C
3364:  MOV     W0,W5
3366:  MOV     W1,W6
3368:  MOV     #0,W1
336A:  MOV     W1,W0
336C:  CALL    70A
3370:  INC     W1,W1
3372:  MOV     W1,[W15++]
3374:  MOV.B   W0L,9BC
3376:  CALL    9F2
337A:  MOV     [--W15],W1
337C:  MOV     #B,W0
337E:  CPSGT   W1,W0
3380:  BRA     336A
3382:  MOV     W6,W2
3384:  MOV     W5,W1
3386:  MOV     #0,W0
3388:  CALL    215A
338C:  MOV     #3,W9
338E:  MOV     #5,W10
3390:  CALL    2398
3394:  MOV.B   #6D,W0L
3396:  MOV.B   W0L,9BC
3398:  CALL    9F2
339C:  MOV.B   #56,W0L
339E:  MOV.B   W0L,9BC
33A0:  CALL    9F2
.................... 			delay_ms(LCD_Delay); 
33A4:  MOV     #7D0,W0
33A6:  CALL    74E
.................... 			lcd_putc("\f"); 
33AA:  MOV     #0,W5
33AC:  MOV     W5,W0
33AE:  CALL    110
33B2:  IOR.B   #0,W0L
33B4:  BTSC.B  42.1
33B6:  BRA     33C2
33B8:  INC     W5,W5
33BA:  MOV.B   W0L,9BC
33BC:  CALL    9F2
33C0:  BRA     33AC
.................... 			printf(lcd_putc,"S1: %6.3fmA\nS2: %6.3fmA",s1,s2); 
33C2:  MOV     #0,W1
33C4:  MOV     W1,W0
33C6:  CALL    72A
33CA:  INC     W1,W1
33CC:  MOV     W1,[W15++]
33CE:  MOV.B   W0L,9BC
33D0:  CALL    9F2
33D4:  MOV     [--W15],W1
33D6:  MOV     #3,W0
33D8:  CPSGT   W1,W0
33DA:  BRA     33C4
33DC:  MOV     80E,W2
33DE:  MOV     80C,W1
33E0:  MOV     #0,W0
33E2:  CALL    215A
33E6:  MOV     #3,W9
33E8:  MOV     #5,W10
33EA:  CALL    2398
33EE:  MOV     #9,W1
33F0:  MOV     W1,W0
33F2:  CALL    72A
33F6:  INC     W1,W1
33F8:  MOV     W1,[W15++]
33FA:  MOV.B   W0L,9BC
33FC:  CALL    9F2
3400:  MOV     [--W15],W1
3402:  MOV     #F,W0
3404:  CPSGT   W1,W0
3406:  BRA     33F0
3408:  MOV     812,W2
340A:  MOV     810,W1
340C:  MOV     #0,W0
340E:  CALL    215A
3412:  MOV     #3,W9
3414:  MOV     #5,W10
3416:  CALL    2398
341A:  MOV.B   #6D,W0L
341C:  MOV.B   W0L,9BC
341E:  CALL    9F2
3422:  MOV.B   #41,W0L
3424:  MOV.B   W0L,9BC
3426:  CALL    9F2
.................... 			delay_ms(LCD_Delay); 
342A:  MOV     #7D0,W0
342C:  CALL    74E
....................  
.................... 			if(battery<6.3) {alert_status=1; CreateAlert(Device_Id,2);} 
3430:  MOV     804,W0
3432:  MOV     806,W1
3434:  MOV     #999A,W2
3436:  MOV     #40C9,W3
3438:  CALL    1C36
343C:  BRA     NC,3450
343E:  MOV     #1,W4
3440:  MOV     W4,97E
3442:  MOV     #2,W4
3444:  MOV     W4,9A8
3446:  PUSH    98E
3448:  POP     9A6
344A:  CALL    251A
.................... 			else alert_status=0; 
344E:  BRA     3452
3450:  CLR     97E
.................... 		}//*****End of for loop************** 
3452:  INC     0990
3454:  BRA     2D98
.................... 		ReportData(Device_Id,lamp_status);//1,1.1,1.1); 
3456:  PUSH    98E
3458:  POP     9A6
345A:  PUSH    97A
345C:  POP     9A8
345E:  CALL    2884
.................... 	}//*****End of while loop************** 
3462:  BRA     2D96
.................... } 
3464:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C701   NOCKSFSM FRC_PLL4 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 0733   PUT64 NOBROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN NOMCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  
