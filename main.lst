CCS PCD C Compiler, Version 4.104, 5967               04-Aug-15 18:17

               Filename: C:\Users\e882742\Documents\TELEGESTION\dsPIC software\main.lst

               ROM used: 9326 bytes (21%)
                         Largest free fragment is 35730
               RAM used: 550 (27%) at main() level
                         590 (29%) worst case
               Stack:    7 locations

*
0000:  GOTO    1C12
.................... /******************Configuration file********************/ 
.................... #include "Config.h" 
.................... #include <30f5015.h> 
.................... //////// Standard Header file for the DSPIC30F5015 device //////////////// 
.................... #device DSPIC30F5015 
.................... #list 
....................  
....................  
.................... #device ADC=10 
.................... #fuses FRC_PLL4, NOWRT, NOPROTECT, NOWDT, NOBROWNOUT, NOMCLR 
.................... #use delay(clock=29480000)  
*
0484:  CP0     W0
0486:  BTSC.B  42.1
0488:  BRA     492
048A:  REPEAT  #1CC3
048C:  NOP     
048E:  DEC     W0,W0
0490:  BRA     484
0492:  RETURN  
.................... #use rs232(baud=115200,bits=8, xmit=PIN_F3,rcv=PIN_F2, parity=N)//, timeout=2000) 
.................... #byte OERR=0x020E 
.................... #USE FIXED_IO(B_OUTPUTS=PIN_B7,PIN_B8) 
....................  
.................... #define Timmer_Mode     0	//new mode  operation 
.................... #define Automated_Mode  1 
.................... #define Manual_Mode     2 
....................  
.................... #define Lamp_On         1 
.................... #define Lamp_Off        0 
....................  
.................... #define day_             0 
.................... #define month_           1 
.................... #define year_            2 
.................... #define hour_            3 
.................... #define min_             4 
.................... #define sec_             5 
....................  
.................... #define RoboCable        0 
.................... #define RoboEnergia      1 
.................... #define LamparaFundida   2 
....................  
.................... /******************Include files*************************/ 
.................... #include "DS1302_2.c" 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_D5 
.................... #define RTC_IO   PIN_D6 
.................... #define RTC_RST  PIN_D4 
....................  
.................... #endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
0630:  CLR.B   9B0
0632:  MOV     9B0,W4
0634:  CP.B    W4L,#7
0636:  BRA     GTU,652
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
0638:  BCLR.B  42.0
063A:  RRC.B   9AF
063C:  BRA     C,642
063E:  BCLR.B  2D6.6
0640:  BRA     644
0642:  BSET.B  2D6.6
0644:  BCLR.B  2D2.6
....................       output_high(RTC_SCLK); 
0646:  BCLR.B  2D2.5
0648:  BSET.B  2D6.5
....................       output_low(RTC_SCLK); 
064A:  BCLR.B  2D2.5
064C:  BCLR.B  2D6.5
....................    } 
064E:  INC.B   09B0
0650:  BRA     632
.................... } 
0652:  RETURN  
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
0654:  BCLR.B  2D2.4
0656:  BSET.B  2D6.4
....................    write_ds1302_byte(cmd); 
0658:  MOV.B   9AB,W0L
065A:  MOV.B   W0L,9AF
065C:  CALL    630
....................    write_ds1302_byte(data); 
0660:  MOV.B   9AC,W0L
0662:  MOV.B   W0L,9AF
0664:  CALL    630
....................    output_low(RTC_RST); 
0668:  BCLR.B  2D2.4
066A:  BCLR.B  2D6.4
.................... } 
066C:  RETURN  
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
066E:  BCLR.B  2D2.4
0670:  BSET.B  2D6.4
....................    write_ds1302_byte(cmd); 
0672:  MOV.B   9A1,W0L
0674:  MOV.B   W0L,9AF
0676:  CALL    630
....................     
....................    input(RTC_IO); 
067A:  BSET.B  2D2.6
....................    delay_us(1); 
067C:  REPEAT  #5
067E:  NOP     
....................           
....................    for(i=0;i<=7;++i) { 
0680:  CLR.B   9A2
0682:  MOV     9A2,W4
0684:  CP.B    W4L,#7
0686:  BRA     GTU,6AA
....................       shift_right(&data,1,input(RTC_IO)); 
0688:  BSET.B  2D2.6
068A:  BTSC.B  2D4.6
068C:  BRA     692
068E:  BCLR.B  42.0
0690:  BRA     694
0692:  BSET.B  42.0
0694:  RRC.B   9A3
....................       output_high(RTC_SCLK); 
0696:  BCLR.B  2D2.5
0698:  BSET.B  2D6.5
....................       delay_us(2); 
069A:  REPEAT  #C
069C:  NOP     
....................       output_low(RTC_SCLK); 
069E:  BCLR.B  2D2.5
06A0:  BCLR.B  2D6.5
....................       delay_us(2); 
06A2:  REPEAT  #C
06A4:  NOP     
....................    } 
06A6:  INC.B   09A2
06A8:  BRA     682
....................    output_low(RTC_RST); 
06AA:  BCLR.B  2D2.4
06AC:  BCLR.B  2D6.4
....................  
....................    return(data); 
06AE:  MOV.B   9A3,W0L
.................... } 
06B0:  RETURN  
....................  
.................... void rtc_init() { 
06B2:  MOV     W5,[W15++]
....................    BYTE x; 
....................    output_low(RTC_RST); 
06B4:  BCLR.B  2D2.4
06B6:  BCLR.B  2D6.4
....................    delay_us(2); 
06B8:  REPEAT  #C
06BA:  NOP     
....................    output_low(RTC_SCLK); 
06BC:  BCLR.B  2D2.5
06BE:  BCLR.B  2D6.5
....................    write_ds1302(0x8e,0); 
06C0:  MOV.B   #8E,W0L
06C2:  MOV.B   W0L,9AB
06C4:  CLR.B   9AC
06C6:  CALL    654
....................    write_ds1302(0x90,0xa4); 
06CA:  MOV.B   #90,W0L
06CC:  MOV.B   W0L,9AB
06CE:  MOV.B   #A4,W0L
06D0:  MOV.B   W0L,9AC
06D2:  CALL    654
....................    x=read_ds1302(0x81); 
06D6:  MOV.B   #81,W0L
06D8:  MOV.B   W0L,9A1
06DA:  CALL    66E
06DE:  MOV.B   W0L,99D
....................    if((x & 0x80)!=0) 
06E0:  MOV.B   99D,W0L
06E2:  AND.B   #80,W0L
06E4:  CP0.B   W0L
06E6:  BRA     Z,6F2
....................      write_ds1302(0x80,0); 
06E8:  MOV.B   #80,W0L
06EA:  MOV.B   W0L,9AB
06EC:  CLR.B   9AC
06EE:  CALL    654
.................... } 
06F2:  MOV     [--W15],W5
06F4:  RETURN  
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
*
0D88:  MOV     W5,[W15++]
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
0D8A:  MOV.B   9A9,W0L
0D8C:  CLR.B   1
0D8E:  CLR.B   1
0D90:  MOV     #A,W4
0D92:  REPEAT  #11
0D94:  DIV.U   W0,W4
0D96:  MOV.B   W0L,9AA
....................    nibl=data-(nibh*10); 
0D98:  MOV     9AA,W4
0D9A:  CLR.B   9
0D9C:  MUL.UU  W4,#A,W0
0D9E:  MOV     9A8,W4
0DA0:  LSR     W4,#8,W4
0DA2:  SUB.B   W4L,W0L,W0L
0DA4:  MOV.B   W0L,9AB
....................  
....................    return((nibh<<4)|nibl); 
0DA6:  MOV.B   9AA,W0L
0DA8:  SL      W0,#4,W0
0DAA:  IOR.B   9AB,W0L
.................... } 
0DAC:  MOV     [--W15],W5
0DAE:  RETURN  
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
*
11A4:  MOV     W5,[W15++]
....................    byte i; 
....................  
....................    i=data; 
11A6:  MOV.B   9A3,W0L
11A8:  MOV.B   W0L,9A4
....................    data=(i>>4)*10; 
11AA:  MOV.B   9A4,W0L
11AC:  CLR.B   1
11AE:  LSR     W0,#4,W0
11B0:  MOV.B   W0L,W4L
11B2:  CLR.B   9
11B4:  MUL.UU  W4,#A,W0
11B6:  MOV.B   W0L,9A3
....................    data=data+(i<<4>>4); 
11B8:  MOV.B   9A4,W0L
11BA:  SL      W0,#4,W0
11BC:  CLR.B   1
11BE:  LSR     W0,#4,W0
11C0:  ADD.B   9A3
....................  
....................    return data; 
11C2:  MOV.B   9A3,W0L
.................... } 
11C4:  MOV     [--W15],W5
11C6:  RETURN  
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
*
0DB0:  MOV     W5,[W15++]
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
0DB2:  MOV.B   99D,W0L
0DB4:  MOV.B   W0L,9A9
0DB6:  CALL    D88
0DBA:  MOV.B   W0L,W5L
0DBC:  MOV.B   #86,W0L
0DBE:  MOV.B   W0L,9AB
0DC0:  PUSH    9AC
0DC2:  MOV.B   W5L,[W15-#2]
0DC4:  POP     9AC
0DC6:  CALL    654
....................    write_ds1302(0x88,get_bcd(mth)); 
0DCA:  MOV.B   99E,W0L
0DCC:  MOV.B   W0L,9A9
0DCE:  CALL    D88
0DD2:  MOV.B   W0L,W5L
0DD4:  MOV.B   #88,W0L
0DD6:  MOV.B   W0L,9AB
0DD8:  PUSH    9AC
0DDA:  MOV.B   W5L,[W15-#2]
0DDC:  POP     9AC
0DDE:  CALL    654
....................    write_ds1302(0x8c,get_bcd(year)); 
0DE2:  MOV.B   99F,W0L
0DE4:  MOV.B   W0L,9A9
0DE6:  CALL    D88
0DEA:  MOV.B   W0L,W5L
0DEC:  MOV.B   #8C,W0L
0DEE:  MOV.B   W0L,9AB
0DF0:  PUSH    9AC
0DF2:  MOV.B   W5L,[W15-#2]
0DF4:  POP     9AC
0DF6:  CALL    654
....................    write_ds1302(0x8a,get_bcd(dow)); 
0DFA:  MOV.B   9A0,W0L
0DFC:  MOV.B   W0L,9A9
0DFE:  CALL    D88
0E02:  MOV.B   W0L,W5L
0E04:  MOV.B   #8A,W0L
0E06:  MOV.B   W0L,9AB
0E08:  PUSH    9AC
0E0A:  MOV.B   W5L,[W15-#2]
0E0C:  POP     9AC
0E0E:  CALL    654
....................    write_ds1302(0x84,get_bcd(hr)); 
0E12:  MOV.B   9A1,W0L
0E14:  MOV.B   W0L,9A9
0E16:  CALL    D88
0E1A:  MOV.B   W0L,W5L
0E1C:  MOV.B   #84,W0L
0E1E:  MOV.B   W0L,9AB
0E20:  PUSH    9AC
0E22:  MOV.B   W5L,[W15-#2]
0E24:  POP     9AC
0E26:  CALL    654
....................    write_ds1302(0x82,get_bcd(min)); 
0E2A:  MOV.B   9A2,W0L
0E2C:  MOV.B   W0L,9A9
0E2E:  CALL    D88
0E32:  MOV.B   W0L,W5L
0E34:  MOV.B   #82,W0L
0E36:  MOV.B   W0L,9AB
0E38:  PUSH    9AC
0E3A:  MOV.B   W5L,[W15-#2]
0E3C:  POP     9AC
0E3E:  CALL    654
....................    write_ds1302(0x80,get_bcd(0)); 
0E42:  CLR.B   9A9
0E44:  CALL    D88
0E48:  MOV.B   W0L,W5L
0E4A:  MOV.B   #80,W0L
0E4C:  MOV.B   W0L,9AB
0E4E:  PUSH    9AC
0E50:  MOV.B   W5L,[W15-#2]
0E52:  POP     9AC
0E54:  CALL    654
.................... } 
0E58:  MOV     [--W15],W5
0E5A:  RETURN  
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
200C:  MOV.B   #87,W0L
200E:  MOV.B   W0L,9A1
2010:  CALL    66E
2014:  MOV.B   W0L,W5L
2016:  MOV.B   W5L,W0L
2018:  MOV.B   W0L,9A3
201A:  CALL    11A4
201E:  MOV.B   W0L,98A
....................    mth = rm_bcd(read_ds1302(0x89)); 
2020:  MOV.B   #89,W0L
2022:  MOV.B   W0L,9A1
2024:  CALL    66E
2028:  MOV.B   W0L,W5L
202A:  MOV.B   W5L,W0L
202C:  MOV.B   W0L,9A3
202E:  CALL    11A4
2032:  MOV.B   W0L,98B
....................    year = rm_bcd(read_ds1302(0x8d)); 
2034:  MOV.B   #8D,W0L
2036:  MOV.B   W0L,9A1
2038:  CALL    66E
203C:  MOV.B   W0L,W5L
203E:  MOV.B   W5L,W0L
2040:  MOV.B   W0L,9A3
2042:  CALL    11A4
2046:  MOV.B   W0L,98C
....................    dow = rm_bcd(read_ds1302(0x8b)); 
2048:  MOV.B   #8B,W0L
204A:  MOV.B   W0L,9A1
204C:  CALL    66E
2050:  MOV.B   W0L,W5L
2052:  MOV.B   W5L,W0L
2054:  MOV.B   W0L,9A3
2056:  CALL    11A4
205A:  MOV.B   W0L,99C
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
205C:  MOV.B   #85,W0L
205E:  MOV.B   W0L,9A1
2060:  CALL    66E
2064:  MOV.B   W0L,W5L
2066:  MOV.B   W5L,W0L
2068:  MOV.B   W0L,9A3
206A:  CALL    11A4
206E:  MOV.B   W0L,98D
....................    min = rm_bcd(read_ds1302(0x83)); 
2070:  MOV.B   #83,W0L
2072:  MOV.B   W0L,9A1
2074:  CALL    66E
2078:  MOV.B   W0L,W5L
207A:  MOV.B   W5L,W0L
207C:  MOV.B   W0L,9A3
207E:  CALL    11A4
2082:  MOV.B   W0L,98E
....................    sec = rm_bcd(read_ds1302(0x81)); 
2084:  MOV.B   #81,W0L
2086:  MOV.B   W0L,9A1
2088:  CALL    66E
208C:  MOV.B   W0L,W5L
208E:  MOV.B   W5L,W0L
2090:  MOV.B   W0L,9A3
2092:  CALL    11A4
2096:  MOV.B   W0L,98F
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... #include "mcp4921_DSPIC.c" 
.................... //////////////// Driver for MCP4921 D/A Converter /////////////////////// 
.................... ////                                                                 //// 
.................... ////  init_dac()    Call this before using a MCP4921 DAC             //// 
.................... ////                                                                 //// 
.................... ////  write_dac( long int )   Writes command and 12 bit resolution   //// 
.................... ////                          to the MCP4921 which converts it to a  //// 
.................... ////                          voltage                                //// 
.................... ////                          0-4095 input represents 0-vref V out.  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EEPROM_SELECT 
....................  
.................... #define DAC_CS     PIN_E0 
.................... #define DAC_CLK    PIN_E1 
.................... #define DAC_DI     PIN_E2 
.................... #define DAC_LDAC   PIN_E3 
....................  
.................... #endif 
....................  
.................... void init_dac() 
.................... { 
....................    output_high(DAC_CS); 
....................    output_high(DAC_LDAC); 
....................    output_high(DAC_CLK); 
....................    output_high(DAC_DI); 
.................... } 
....................  
.................... void write_dac(int16 data) { 
....................    BYTE cmd[3]; 
....................    BYTE i; 
....................  
....................    cmd[0]=data; 
....................    cmd[1]=(data>>8); 
....................    cmd[2]=0x03;                            
....................     
....................    output_high(DAC_LDAC); 
....................    output_low(DAC_CLK); 
....................    output_low(DAC_CS); 
....................  
....................    for(i=0; i<=23; ++i) 
....................    { 
....................       if(i<4 || (i>7 && i<12)) 
....................          shift_left(cmd,3,0); 
....................       else 
....................       { 
....................          output_bit(DAC_DI, shift_left(cmd,3,0)); 
....................  
....................          output_high(DAC_CLK); 
....................          output_low(DAC_CLK); 
....................       } 
....................    } 
....................    output_high(DAC_CS); 
....................  
....................    output_low(DAC_LDAC); 
....................    delay_us(10); 
....................     
....................    output_HIGH(DAC_LDAC); 
.................... } 
....................  
.................... #include "lcd_2.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
....................      #define LCD_ENABLE_PIN  PIN_B12                                   //// 
....................      #define LCD_RS_PIN      PIN_B10                                    ////     
....................      #define LCD_RW_PIN      PIN_B11                                    //// 
....................      #define LCD_DATA4       PIN_D0                                    //// 
....................      #define LCD_DATA5       PIN_D1                                    //// 
....................      #define LCD_DATA6       PIN_D2                                    //// 
....................      #define LCD_DATA7       PIN_D3  
....................  
....................  
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
*
0510:  MOV     W5,[W15++]
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
0512:  BSET.B  2D2.0
....................    output_float(LCD_DATA5); 
0514:  BSET.B  2D2.1
....................    output_float(LCD_DATA6); 
0516:  BSET.B  2D2.2
....................    output_float(LCD_DATA7); 
0518:  BSET.B  2D2.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
051A:  BSET.B  2CB.3
051C:  MOV     #7E,W4
051E:  MOV     W4,2C6
....................    delay_cycles(1); 
0520:  NOP     
....................    lcd_output_enable(1); 
0522:  BSET.B  2CB.4
0524:  MOV     #7E,W4
0526:  MOV     W4,2C6
....................    delay_cycles(1); 
0528:  NOP     
....................    high = lcd_read_nibble(); 
052A:  CALL    4D8
052E:  MOV.B   W0L,9BC
....................        
....................    lcd_output_enable(0); 
0530:  BCLR.B  2CB.4
0532:  MOV     #7E,W4
0534:  MOV     W4,2C6
....................    delay_cycles(1); 
0536:  NOP     
....................    lcd_output_enable(1); 
0538:  BSET.B  2CB.4
053A:  MOV     #7E,W4
053C:  MOV     W4,2C6
....................    delay_us(1); 
053E:  REPEAT  #5
0540:  NOP     
....................    low = lcd_read_nibble(); 
0542:  CALL    4D8
0546:  MOV.B   W0L,9BB
....................        
....................    lcd_output_enable(0); 
0548:  BCLR.B  2CB.4
054A:  MOV     #7E,W4
054C:  MOV     W4,2C6
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
054E:  BCLR.B  2D2.0
....................    output_drive(LCD_DATA5); 
0550:  BCLR.B  2D2.1
....................    output_drive(LCD_DATA6); 
0552:  BCLR.B  2D2.2
....................    output_drive(LCD_DATA7); 
0554:  BCLR.B  2D2.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
0556:  MOV.B   9BC,W0L
0558:  SL      W0,#4,W0
055A:  IOR.B   9BB,W0L
.................... } 
055C:  MOV     [--W15],W5
055E:  RETURN  
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
04D8:  MOV     W5,[W15++]
04DA:  CLR.B   9BD
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
04DC:  BSET.B  2D2.0
04DE:  CLR.B   W0
04E0:  BTSC.B  2D4.0
04E2:  INC     W0,W0
04E4:  IOR.B   9BD
....................    n |= input(LCD_DATA5) << 1; 
04E6:  BSET.B  2D2.1
04E8:  CLR.B   W0
04EA:  BTSC.B  2D4.1
04EC:  INC     W0,W0
04EE:  SL      W0,#1,W0
04F0:  IOR.B   9BD
....................    n |= input(LCD_DATA6) << 2; 
04F2:  BSET.B  2D2.2
04F4:  CLR.B   W0
04F6:  BTSC.B  2D4.2
04F8:  INC     W0,W0
04FA:  SL      W0,#2,W0
04FC:  IOR.B   9BD
....................    n |= input(LCD_DATA7) << 3; 
04FE:  BSET.B  2D2.3
0500:  CLR.B   W0
0502:  BTSC.B  2D4.3
0504:  INC     W0,W0
0506:  SL      W0,#3,W0
0508:  IOR.B   9BD
....................     
....................    return(n); 
050A:  MOV.B   9BD,W0L
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
050C:  MOV     [--W15],W5
050E:  RETURN  
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0494:  BTSC.B  9BD.0
0496:  BRA     49C
0498:  BCLR.B  2D6.0
049A:  BRA     49E
049C:  BSET.B  2D6.0
049E:  BCLR.B  2D2.0
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
04A0:  BTSC.B  9BD.1
04A2:  BRA     4A8
04A4:  BCLR.B  2D6.1
04A6:  BRA     4AA
04A8:  BSET.B  2D6.1
04AA:  BCLR.B  2D2.1
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
04AC:  BTSC.B  9BD.2
04AE:  BRA     4B4
04B0:  BCLR.B  2D6.2
04B2:  BRA     4B6
04B4:  BSET.B  2D6.2
04B6:  BCLR.B  2D2.2
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
04B8:  BTSC.B  9BD.3
04BA:  BRA     4C0
04BC:  BCLR.B  2D6.3
04BE:  BRA     4C2
04C0:  BSET.B  2D6.3
04C2:  BCLR.B  2D2.3
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
04C4:  NOP     
....................    lcd_output_enable(1); 
04C6:  BSET.B  2CB.4
04C8:  MOV     #7E,W4
04CA:  MOV     W4,2C6
....................    delay_us(2); 
04CC:  REPEAT  #C
04CE:  NOP     
....................    lcd_output_enable(0); 
04D0:  BCLR.B  2CB.4
04D2:  MOV     #7E,W4
04D4:  MOV     W4,2C6
.................... } 
04D6:  RETURN  
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
*
0560:  MOV     W5,[W15++]
....................    lcd_output_rs(0); 
0562:  BCLR.B  2CB.2
0564:  MOV     #7E,W4
0566:  MOV     W4,2C6
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
0568:  CALL    510
056C:  MOV.B   W0L,W5L
056E:  BTSC    W5.7
0570:  BRA     568
....................    lcd_output_rs(address); 
0572:  CP0.B   9B7
0574:  BRA     NZ,57A
0576:  BCLR.B  2CB.2
0578:  BRA     57C
057A:  BSET.B  2CB.2
057C:  MOV     #7E,W4
057E:  MOV     W4,2C6
....................    delay_cycles(1); 
0580:  NOP     
....................    lcd_output_rw(0); 
0582:  BCLR.B  2CB.3
0584:  MOV     #7E,W4
0586:  MOV     W4,2C6
....................    delay_cycles(1); 
0588:  NOP     
....................    lcd_output_enable(0); 
058A:  BCLR.B  2CB.4
058C:  MOV     #7E,W4
058E:  MOV     W4,2C6
....................    lcd_send_nibble(n >> 4); 
0590:  MOV     9B8,W5
0592:  CLR.B   B
0594:  LSR     W5,#4,W5
0596:  MOV.B   W5L,W0L
0598:  MOV.B   W0L,9BD
059A:  CALL    494
....................    lcd_send_nibble(n & 0xf); 
059E:  MOV.B   9B8,W0L
05A0:  AND.B   W0L,#F,W5L
05A2:  MOV.B   W5L,W0L
05A4:  MOV.B   W0L,9BD
05A6:  CALL    494
.................... } 
05AA:  MOV     [--W15],W5
05AC:  RETURN  
....................  
.................... void lcd_init(void)  
.................... { 
05AE:  MOV     W5,[W15++]
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
05B0:  BCLR.B  2D2.0
....................    output_drive(LCD_DATA5); 
05B2:  BCLR.B  2D2.1
....................    output_drive(LCD_DATA6); 
05B4:  BCLR.B  2D2.2
....................    output_drive(LCD_DATA7); 
05B6:  BCLR.B  2D2.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
05B8:  MOV     #7E,W4
05BA:  MOV     W4,2C6
....................    lcd_rs_tris(); 
05BC:  MOV     #7E,W4
05BE:  MOV     W4,2C6
....................    lcd_rw_tris(); 
05C0:  MOV     #7E,W4
05C2:  MOV     W4,2C6
....................  #endif 
....................  
....................    lcd_output_rs(0); 
05C4:  BCLR.B  2CB.2
05C6:  MOV     #7E,W4
05C8:  MOV     W4,2C6
....................    lcd_output_rw(0); 
05CA:  BCLR.B  2CB.3
05CC:  MOV     #7E,W4
05CE:  MOV     W4,2C6
....................    lcd_output_enable(0); 
05D0:  BCLR.B  2CB.4
05D2:  MOV     #7E,W4
05D4:  MOV     W4,2C6
....................      
....................    delay_ms(15); 
05D6:  MOV     #F,W0
05D8:  CALL    484
....................    for(i=1;i<=3;++i) 
05DC:  MOV.B   #1,W0L
05DE:  MOV.B   W0L,99D
05E0:  MOV     99C,W4
05E2:  LSR     W4,#8,W4
05E4:  CP.B    W4L,#3
05E6:  BRA     GTU,600
....................    { 
....................        lcd_send_nibble(3); 
05E8:  MOV.B   #3,W0L
05EA:  MOV.B   W0L,9BD
05EC:  CALL    494
....................        delay_ms(5); 
05F0:  REPEAT  #FF0
05F2:  NOP     
05F4:  REPEAT  #3FFF
05F6:  NOP     
05F8:  REPEAT  #3FFF
05FA:  NOP     
....................    } 
05FC:  INC.B   099D
05FE:  BRA     5E0
....................      
....................    lcd_send_nibble(2); 
0600:  MOV.B   #2,W0L
0602:  MOV.B   W0L,9BD
0604:  CALL    494
....................    for(i=0;i<=3;++i) 
0608:  CLR.B   99D
060A:  MOV     99C,W4
060C:  LSR     W4,#8,W4
060E:  CP.B    W4L,#3
0610:  BRA     GTU,62C
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0612:  MOV.B   99D,W0L
0614:  CLR.B   1
0616:  CALL    100
061A:  MOV.B   W0L,W5L
061C:  CLR.B   9B7
061E:  PUSH    9B8
0620:  MOV.B   W5L,[W15-#2]
0622:  POP     9B8
0624:  CALL    560
0628:  INC.B   099D
062A:  BRA     60A
.................... } 
062C:  MOV     [--W15],W5
062E:  RETURN  
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
*
06F6:  MOV     W5,[W15++]
....................    BYTE address; 
....................  
....................    if(y!=1) 
06F8:  MOV     9B2,W4
06FA:  CP.B    W4L,#1
06FC:  BRA     Z,704
....................       address=LCD_LINE_TWO; 
06FE:  MOV.B   #40,W0L
0700:  MOV.B   W0L,9B3
....................    else 
0702:  BRA     706
....................       address=0; 
0704:  CLR.B   9B3
....................       
....................    address+=x-1; 
0706:  MOV     9B0,W4
0708:  LSR     W4,#8,W4
070A:  SUB.B   W4L,#1,W0L
070C:  ADD.B   9B3
....................    lcd_send_byte(0,0x80|address); 
070E:  MOV     9B2,W5
0710:  LSR     W5,#8,W5
0712:  IOR.B   #80,W5L
0714:  CLR.B   9B7
0716:  PUSH    9B8
0718:  MOV.B   W5L,[W15-#2]
071A:  POP     9B8
071C:  CALL    560
.................... } 
0720:  MOV     [--W15],W5
0722:  RETURN  
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
0724:  MOV.B   9AF,W0L
0726:  CLR.B   1
0728:  XOR     #C,W0
072A:  BRA     Z,736
072C:  XOR     #6,W0
072E:  BRA     Z,746
0730:  XOR     #2,W0
0732:  BRA     Z,754
0734:  BRA     760
....................       case '\f'   :  lcd_send_byte(0,1); 
0736:  CLR.B   9B7
0738:  MOV.B   #1,W0L
073A:  MOV.B   W0L,9B8
073C:  CALL    560
....................                      delay_ms(2); 
0740:  REPEAT  #3992
0742:  NOP     
....................                      break; 
0744:  BRA     76E
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
0746:  MOV.B   #1,W0L
0748:  MOV.B   W0L,9B1
074A:  MOV.B   #2,W0L
074C:  MOV.B   W0L,9B2
074E:  CALL    6F6
0752:  BRA     76E
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0754:  CLR.B   9B7
0756:  MOV.B   #10,W0L
0758:  MOV.B   W0L,9B8
075A:  CALL    560
075E:  BRA     76E
....................       
....................       default     : lcd_send_byte(1,c);     break; 
0760:  MOV.B   #1,W0L
0762:  MOV.B   W0L,9B7
0764:  MOV.B   9AF,W0L
0766:  MOV.B   W0L,9B8
0768:  CALL    560
076C:  BRA     76E
....................    } 
.................... } 
076E:  RETURN  
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... #include "ADH8066.c" 
.................... /******************Global definitions********************/ 
.................... #define AT "AT+" 
.................... #define CPIN "CPIN?\r\n" 
.................... #define AIPDCONT "AIPDCONT=\"INTERNET.MOVISTAR.MX\",\"MOVISTAR\",\"MOVISTAR\"\r\n" 
.................... #define AIPO "AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1\r\n" 
....................  
.................... /******************Variable and constant definitions*****/ 
.................... const char hexcode[17]="0123456789abcdef"; 
....................  
.................... char InputBuffer[350]={0}; 
*
1C60:  CLR     800
1C62:  CLR     802
1C64:  CLR     804
1C66:  CLR     806
1C68:  CLR     808
1C6A:  CLR     80A
1C6C:  CLR     80C
1C6E:  CLR     80E
1C70:  CLR     810
1C72:  CLR     812
1C74:  CLR     814
1C76:  CLR     816
1C78:  CLR     818
1C7A:  CLR     81A
1C7C:  CLR     81C
1C7E:  CLR     81E
1C80:  CLR     820
1C82:  CLR     822
1C84:  CLR     824
1C86:  CLR     826
1C88:  CLR     828
1C8A:  CLR     82A
1C8C:  CLR     82C
1C8E:  CLR     82E
1C90:  CLR     830
1C92:  CLR     832
1C94:  CLR     834
1C96:  CLR     836
1C98:  CLR     838
1C9A:  CLR     83A
1C9C:  CLR     83C
1C9E:  CLR     83E
1CA0:  CLR     840
1CA2:  CLR     842
1CA4:  CLR     844
1CA6:  CLR     846
1CA8:  CLR     848
1CAA:  CLR     84A
1CAC:  CLR     84C
1CAE:  CLR     84E
1CB0:  CLR     850
1CB2:  CLR     852
1CB4:  CLR     854
1CB6:  CLR     856
1CB8:  CLR     858
1CBA:  CLR     85A
1CBC:  CLR     85C
1CBE:  CLR     85E
1CC0:  CLR     860
1CC2:  CLR     862
1CC4:  CLR     864
1CC6:  CLR     866
1CC8:  CLR     868
1CCA:  CLR     86A
1CCC:  CLR     86C
1CCE:  CLR     86E
1CD0:  CLR     870
1CD2:  CLR     872
1CD4:  CLR     874
1CD6:  CLR     876
1CD8:  CLR     878
1CDA:  CLR     87A
1CDC:  CLR     87C
1CDE:  CLR     87E
1CE0:  CLR     880
1CE2:  CLR     882
1CE4:  CLR     884
1CE6:  CLR     886
1CE8:  CLR     888
1CEA:  CLR     88A
1CEC:  CLR     88C
1CEE:  CLR     88E
1CF0:  CLR     890
1CF2:  CLR     892
1CF4:  CLR     894
1CF6:  CLR     896
1CF8:  CLR     898
1CFA:  CLR     89A
1CFC:  CLR     89C
1CFE:  CLR     89E
1D00:  CLR     8A0
1D02:  CLR     8A2
1D04:  CLR     8A4
1D06:  CLR     8A6
1D08:  CLR     8A8
1D0A:  CLR     8AA
1D0C:  CLR     8AC
1D0E:  CLR     8AE
1D10:  CLR     8B0
1D12:  CLR     8B2
1D14:  CLR     8B4
1D16:  CLR     8B6
1D18:  CLR     8B8
1D1A:  CLR     8BA
1D1C:  CLR     8BC
1D1E:  CLR     8BE
1D20:  CLR     8C0
1D22:  CLR     8C2
1D24:  CLR     8C4
1D26:  CLR     8C6
1D28:  CLR     8C8
1D2A:  CLR     8CA
1D2C:  CLR     8CC
1D2E:  CLR     8CE
1D30:  CLR     8D0
1D32:  CLR     8D2
1D34:  CLR     8D4
1D36:  CLR     8D6
1D38:  CLR     8D8
1D3A:  CLR     8DA
1D3C:  CLR     8DC
1D3E:  CLR     8DE
1D40:  CLR     8E0
1D42:  CLR     8E2
1D44:  CLR     8E4
1D46:  CLR     8E6
1D48:  CLR     8E8
1D4A:  CLR     8EA
1D4C:  CLR     8EC
1D4E:  CLR     8EE
1D50:  CLR     8F0
1D52:  CLR     8F2
1D54:  CLR     8F4
1D56:  CLR     8F6
1D58:  CLR     8F8
1D5A:  CLR     8FA
1D5C:  CLR     8FC
1D5E:  CLR     8FE
1D60:  CLR     900
1D62:  CLR     902
1D64:  CLR     904
1D66:  CLR     906
1D68:  CLR     908
1D6A:  CLR     90A
1D6C:  CLR     90C
1D6E:  CLR     90E
1D70:  CLR     910
1D72:  CLR     912
1D74:  CLR     914
1D76:  CLR     916
1D78:  CLR     918
1D7A:  CLR     91A
1D7C:  CLR     91C
1D7E:  CLR     91E
1D80:  CLR     920
1D82:  CLR     922
1D84:  CLR     924
1D86:  CLR     926
1D88:  CLR     928
1D8A:  CLR     92A
1D8C:  CLR     92C
1D8E:  CLR     92E
1D90:  CLR     930
1D92:  CLR     932
1D94:  CLR     934
1D96:  CLR     936
1D98:  CLR     938
1D9A:  CLR     93A
1D9C:  CLR     93C
1D9E:  CLR     93E
1DA0:  CLR     940
1DA2:  CLR     942
1DA4:  CLR     944
1DA6:  CLR     946
1DA8:  CLR     948
1DAA:  CLR     94A
1DAC:  CLR     94C
1DAE:  CLR     94E
1DB0:  CLR     950
1DB2:  CLR     952
1DB4:  CLR     954
1DB6:  CLR     956
1DB8:  CLR     958
1DBA:  CLR     95A
1DBC:  CLR     95C
.................... int16 ptime=100; 
....................  
.................... /***********StringToHex*********************************** 
.................... **   Description: This function converts a string in    ** 
.................... **     their hex codification                           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void StringToHex(char* Str,unsigned int size,char* result) 
.................... { 
.................... 	int index=0,aux=0,aux2=0; 
.................... 	for(index=0;index<size;index++) 
.................... 		{ 
.................... 			aux=*(Str+index); 
.................... 			aux2=aux/16; 
.................... 			*(result+(index*2))=hexcode[aux2]; 
.................... 			if(aux>15) 
.................... 				{ 
.................... 					aux=aux-(aux2*16); 
.................... 				} 
.................... 			*(result+((index*2)+1))=hexcode[aux];	 
.................... 		} 
.................... } 
....................  
.................... /***********FillArray************************************* 
.................... **   Description: Function used to fill an array with   ** 
.................... **     value of (val) variable                          ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void FillArray(char* arrayval,int size,char val) 
.................... { 
*
0770:  MOV     W5,[W15++]
0772:  CLR     9CC
.................... 	int index=0; 
.................... 	for(index=0;index<size;index++) 
0774:  CLR     9CC
0776:  MOV     9CC,W0
0778:  MOV     9CA,W4
077A:  CP      W4,W0
077C:  BRA     LE,78C
.................... 	{ 
.................... 		*(arrayval+index)=val; 
077E:  MOV     9C8,W0
0780:  ADD     9CC,W0
0782:  MOV     W0,W5
0784:  MOV.B   9C7,W0L
0786:  MOV.B   W0L,[W5]
.................... 	} 
0788:  INC     09CC
078A:  BRA     776
.................... } 
078C:  MOV     [--W15],W5
078E:  RETURN  
....................  
.................... /***********ReadBuffer************************************ 
.................... **   Description: Reads incoming characters until arrive** 
.................... **     a carriage return '\r' and save the buffer in    ** 
.................... **       *buffer array                                  ** 
.................... *********************************************************/ 
.................... void ReadBuffer(char* buffer) 
.................... { 
0790:  MOV     W5,[W15++]
0792:  CLR     9CA
.................... 	int16 index=0; 
.................... 	OERR=16; 
0794:  MOV.B   #10,W0L
0796:  MOV.B   W0L,20E
.................... 	//******Get incoming buffer data****** 
.................... 	while(getc()!='\n'); 
0798:  BTSS.B  20E.0
079A:  BRA     798
079C:  MOV     212,W0
079E:  CP.B    W0L,#A
07A0:  BRA     NZ,798
....................     do 
....................     { 
....................        *(buffer+index)=getc();	 
07A2:  MOV     9C8,W0
07A4:  ADD     9CA,W0
07A6:  MOV     W0,W5
07A8:  BTSS.B  20E.0
07AA:  BRA     7A8
07AC:  MOV     212,W0
07AE:  MOV.B   W0L,[W5]
.................... 		index++; 
07B0:  INC     09CA
....................     }while(index<350 && *(buffer+index-1)!='\r'); 
07B2:  MOV     9CA,W4
07B4:  MOV     #15E,W3
07B6:  CP      W3,W4
07B8:  BRA     LE,7C8
07BA:  MOV     9C8,W0
07BC:  ADD     9CA,W0
07BE:  MOV     W0,W5
07C0:  SUB     W5,#1,W0
07C2:  MOV.B   [W0],W4L
07C4:  CP.B    W4L,#D
07C6:  BRA     NZ,7A2
....................  
.................... 	//***Buzzer sound when receive******** 
....................     output_bit(PIN_D9,1); 
07C8:  BSET.B  2D7.1
07CA:  BCLR.B  2D3.1
.................... 	delay_ms(100); 
07CC:  MOV     #64,W0
07CE:  CALL    484
.................... 	output_bit(PIN_D9,0); 
07D2:  BCLR.B  2D7.1
07D4:  BCLR.B  2D3.1
.................... 	OERR=16; 
07D6:  MOV.B   #10,W0L
07D8:  MOV.B   W0L,20E
....................  
.................... } 
07DA:  MOV     [--W15],W5
07DC:  RETURN  
....................  
.................... /***********PrintBuffer*********************************** 
.................... **   Description: Prints in LCD the specified buffer    ** 
.................... **     of characters with a permanency of ms            ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void PrintBuffer(char* buffer,int16 permanency) 
.................... { 
07DE:  MOV     W5,[W15++]
.................... 	lcd_putc("\f"); 
07E0:  MOV     #0,W5
07E2:  MOV     W5,W0
07E4:  CALL    110
07E8:  IOR.B   #0,W0L
07EA:  BTSC.B  42.1
07EC:  BRA     7F8
07EE:  INC     W5,W5
07F0:  MOV.B   W0L,9AF
07F2:  CALL    724
07F6:  BRA     7E2
....................     printf(lcd_putc,"%s",buffer); 
07F8:  MOV     9A4,W1
07FA:  CP0.B   [W1]
07FC:  BRA     Z,80E
07FE:  MOV     W1,[W15++]
0800:  MOV.B   [W1],W0L
0802:  MOV.B   W0L,9AF
0804:  CALL    724
0808:  MOV     [--W15],W1
080A:  INC     W1,W1
080C:  BRA     7FA
.................... 	delay_ms(permanency); 
080E:  MOV     9A6,W0
0810:  CALL    484
.................... } 
0814:  MOV     [--W15],W5
0816:  RETURN  
....................  
.................... /***********ValidateCommand******************************* 
.................... **   Description: Validate that input string does not   ** 
.................... **     contains an ERROR                                ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int ValidateCommand(char* cmdstr,int size) 
.................... { 
0818:  MOV     W5,[W15++]
081A:  CLR     9B4
081C:  MOV     #1,W4
081E:  MOV     W4,9B6
.................... 	int index=0,result=1; 
.................... 	for(index=0;index<size;index++) 
0820:  CLR     9B4
0822:  MOV     9B4,W0
0824:  MOV     9B2,W4
0826:  CP      W4,W0
0828:  BRA     LE,84A
.................... 	{ 
.................... 		if(*(cmdstr+index)=='E' && *(cmdstr+(index+1))=='R')  
082A:  MOV     9B0,W0
082C:  ADD     9B4,W0
082E:  MOV.B   [W0],W4L
0830:  XOR.B   #45,W4L
0832:  BRA     NZ,846
0834:  MOV     9B4,W4
0836:  ADD     W4,#1,W4
0838:  MOV     W4,W0
083A:  MOV     9B0,W4
083C:  ADD     W0,W4,W0
083E:  MOV.B   [W0],W4L
0840:  XOR.B   #52,W4L
0842:  BRA     NZ,846
.................... 		{ 
.................... 			result=0; 
0844:  CLR     9B6
.................... 		} 
.................... 	} 
0846:  INC     09B4
0848:  BRA     822
....................  
....................     return result; 
084A:  PUSH    9B6
084C:  POP     0
.................... } 
084E:  MOV     [--W15],W5
0850:  RETURN  
....................  
.................... /***********GetDecVal************************************* 
.................... **   Description: Function used to find a decimal value ** 
.................... **     into string                                      ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int GetDecVal(char* arrayval,int16 size,char stch1,char stch2) 
.................... { 
*
0B9E:  MOV     W5,[W15++]
0BA0:  CLR     9B8
0BA2:  SETM    9BA
.................... 	int16 ind=0; 
....................     int16  value=-1; 
....................  
.................... 	while(ind<size && *(arrayval+ind)!='$')// && value==-1) 
.................... 	{ 
0BA4:  MOV     9B8,W0
0BA6:  MOV     9B4,W4
0BA8:  CP      W4,W0
0BAA:  BRA     LE,C0C
0BAC:  MOV     9B2,W0
0BAE:  ADD     9B8,W0
0BB0:  MOV.B   [W0],W4L
0BB2:  XOR.B   #24,W4L
0BB4:  BRA     Z,C0C
....................  
.................... 		if(*(arrayval+ind)==stch1 && *(arrayval+(ind+1))==stch2) 
0BB6:  MOV     9B2,W0
0BB8:  ADD     9B8,W0
0BBA:  MOV.B   [W0],W0L
0BBC:  CP.B    9B1
0BBE:  BRA     NZ,C08
0BC0:  MOV     9B8,W4
0BC2:  ADD     W4,#1,W4
0BC4:  MOV     W4,W0
0BC6:  MOV     9B2,W4
0BC8:  ADD     W0,W4,W0
0BCA:  MOV.B   [W0],W0L
0BCC:  CP.B    9B6
0BCE:  BRA     NZ,C08
.................... 			{ 
.................... 				ind+=2; 
0BD0:  MOV     9B8,W4
0BD2:  ADD     W4,#2,W4
0BD4:  MOV     W4,9B8
.................... 				value=0; 
0BD6:  CLR     9BA
.................... 				while(*(arrayval+ind)>47 && *(arrayval+ind)<58) 
.................... 					{ 
0BD8:  MOV     9B2,W0
0BDA:  ADD     9B8,W0
0BDC:  MOV     #2F,W4
0BDE:  CP.B    W4L,[W0]
0BE0:  BRA     C,C08
0BE2:  MOV     9B2,W0
0BE4:  ADD     9B8,W0
0BE6:  MOV.B   [W0],W4L
0BE8:  MOV     #3A,W3
0BEA:  CP.B    W3L,W4L
0BEC:  BRA     LEU,C08
.................... 						value*=10; 
0BEE:  MOV     9BA,W4
0BF0:  MUL.UU  W4,#A,W0
0BF2:  MOV     W0,9BA
.................... 						value+=(*(arrayval+ind)-48); 
0BF4:  MOV     9B2,W0
0BF6:  ADD     9B8,W0
0BF8:  MOV.B   [W0],W4L
0BFA:  SUB.B   #30,W4L
0BFC:  MOV.B   W4L,W0L
0BFE:  MOV.B   W0L,0
0C00:  ZE      W0,W0
0C02:  ADD     9BA
.................... 						ind++; 
0C04:  INC     09B8
.................... 					} 
0C06:  BRA     BD8
.................... 			} 
.................... 		ind++; 
0C08:  INC     09B8
.................... 	} 
0C0A:  BRA     BA4
....................  
.................... 	return value; 
0C0C:  PUSH    9BA
0C0E:  POP     0
.................... } 
0C10:  MOV     [--W15],W5
0C12:  RETURN  
....................  
.................... /***********ConfigureGPRS********************************* 
.................... **   Description: Function used to configure the GPRS   ** 
.................... **     module to conect it to internet                  ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ConfigureGPRS() 
.................... { 
*
0852:  MOV     W5,[W15++]
0854:  CLR     99E
0856:  CLR     9A0
.................... 	int status=0,count=0; 
....................  
.................... 	while(status==0 && count<5) 
.................... 		{ 
0858:  CP0     99E
085A:  BRA     NZ,AA0
085C:  MOV     9A0,W4
085E:  CP      W4,#5
0860:  BRA     GE,AA0
.................... 			FillArray(InputBuffer,350,0);  //Clear input_buffer 
0862:  CLR.B   9C7
0864:  MOV     #800,W4
0866:  MOV     W4,9C8
0868:  MOV     #15E,W4
086A:  MOV     W4,9CA
086C:  CALL    770
.................... 			printf("AT+CPIN?\r\n");         //Verify chip 
0870:  MOV     #0,W1
0872:  MOV     W1,W0
0874:  CALL    11E
0878:  INC     W1,W1
087A:  MOV     W1,[W15++]
087C:  BTSC.B  20F.1
087E:  BRA     87C
0880:  MOV     W0,210
0882:  MOV     [--W15],W1
0884:  MOV     #9,W0
0886:  CPSGT   W1,W0
0888:  BRA     872
.................... 			ReadBuffer(InputBuffer); 
088A:  MOV     #800,W4
088C:  MOV     W4,9C8
088E:  CALL    790
.................... 			PrintBuffer(InputBuffer,100); 
0892:  MOV     #64,W4
0894:  MOV     W4,9A6
0896:  MOV     #800,W4
0898:  MOV     W4,9A4
089A:  CALL    7DE
.................... 			status=ValidateCommand(InputBuffer,30); 
089E:  MOV     #1E,W4
08A0:  MOV     W4,9B2
08A2:  MOV     #800,W4
08A4:  MOV     W4,9B0
08A6:  CALL    818
08AA:  MOV     W0,99E
.................... 			if(status==1) lcd_putc("\fCMD OK"); 
08AC:  MOV     99E,W4
08AE:  CP      W4,#1
08B0:  BRA     NZ,8CC
08B2:  MOV     #0,W5
08B4:  MOV     W5,W0
08B6:  CALL    136
08BA:  IOR.B   #0,W0L
08BC:  BTSC.B  42.1
08BE:  BRA     8CA
08C0:  INC     W5,W5
08C2:  MOV.B   W0L,9AF
08C4:  CALL    724
08C8:  BRA     8B4
.................... 			else  
08CA:  BRA     8E6
.................... 				{	 
.................... 					lcd_putc("\fCMD BAD"); 
08CC:  MOV     #0,W5
08CE:  MOV     W5,W0
08D0:  CALL    14A
08D4:  IOR.B   #0,W0L
08D6:  BTSC.B  42.1
08D8:  BRA     8E4
08DA:  INC     W5,W5
08DC:  MOV.B   W0L,9AF
08DE:  CALL    724
08E2:  BRA     8CE
.................... 					status=0; 
08E4:  CLR     99E
.................... 				} 
.................... 			delay_ms(500); 
08E6:  MOV     #1F4,W0
08E8:  CALL    484
.................... 	 
.................... 			if(status==1) 
08EC:  MOV     99E,W4
08EE:  CP      W4,#1
08F0:  BRA     NZ,97C
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
08F2:  CLR.B   9C7
08F4:  MOV     #800,W4
08F6:  MOV     W4,9C8
08F8:  MOV     #15E,W4
08FA:  MOV     W4,9CA
08FC:  CALL    770
.................... 					printf("AT+AIPDCONT=\"internet.movistar.mx\",\"movistar\",\"movistar\"\r\n");  //Configure internet 
0900:  MOV     #0,W1
0902:  MOV     W1,W0
0904:  CALL    160
0908:  INC     W1,W1
090A:  MOV     W1,[W15++]
090C:  BTSC.B  20F.1
090E:  BRA     90C
0910:  MOV     W0,210
0912:  MOV     [--W15],W1
0914:  MOV     #39,W0
0916:  CPSGT   W1,W0
0918:  BRA     902
.................... 					ReadBuffer(InputBuffer); 
091A:  MOV     #800,W4
091C:  MOV     W4,9C8
091E:  CALL    790
.................... 					PrintBuffer(InputBuffer,1000); 
0922:  MOV     #800,W4
0924:  MOV     W4,9A4
0926:  MOV     #3E8,W4
0928:  MOV     W4,9A6
092A:  CALL    7DE
.................... 					status=ValidateCommand(InputBuffer,30); 
092E:  MOV     #1E,W4
0930:  MOV     W4,9B2
0932:  MOV     #800,W4
0934:  MOV     W4,9B0
0936:  CALL    818
093A:  MOV     W0,99E
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
093C:  MOV     99E,W4
093E:  CP      W4,#1
0940:  BRA     NZ,95C
0942:  MOV     #0,W5
0944:  MOV     W5,W0
0946:  CALL    136
094A:  IOR.B   #0,W0L
094C:  BTSC.B  42.1
094E:  BRA     95A
0950:  INC     W5,W5
0952:  MOV.B   W0L,9AF
0954:  CALL    724
0958:  BRA     944
.................... 					else  
095A:  BRA     976
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
095C:  MOV     #0,W5
095E:  MOV     W5,W0
0960:  CALL    14A
0964:  IOR.B   #0,W0L
0966:  BTSC.B  42.1
0968:  BRA     974
096A:  INC     W5,W5
096C:  MOV.B   W0L,9AF
096E:  CALL    724
0972:  BRA     95E
.................... 							status=0; 
0974:  CLR     99E
.................... 						} 
.................... 					delay_ms(500); 
0976:  MOV     #1F4,W0
0978:  CALL    484
.................... 				}		 
....................  
.................... 			if(status==1) 
097C:  MOV     99E,W4
097E:  CP      W4,#1
0980:  BRA     NZ,A0C
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0982:  CLR.B   9C7
0984:  MOV     #800,W4
0986:  MOV     W4,9C8
0988:  MOV     #15E,W4
098A:  MOV     W4,9CA
098C:  CALL    770
.................... 					printf("AT+AIPA=1\r\n");        //Conect to internet 
0990:  MOV     #0,W1
0992:  MOV     W1,W0
0994:  CALL    1A4
0998:  INC     W1,W1
099A:  MOV     W1,[W15++]
099C:  BTSC.B  20F.1
099E:  BRA     99C
09A0:  MOV     W0,210
09A2:  MOV     [--W15],W1
09A4:  MOV     #A,W0
09A6:  CPSGT   W1,W0
09A8:  BRA     992
.................... 					ReadBuffer(InputBuffer); 
09AA:  MOV     #800,W4
09AC:  MOV     W4,9C8
09AE:  CALL    790
.................... 					PrintBuffer(InputBuffer,1000); 
09B2:  MOV     #800,W4
09B4:  MOV     W4,9A4
09B6:  MOV     #3E8,W4
09B8:  MOV     W4,9A6
09BA:  CALL    7DE
.................... 					status=ValidateCommand(InputBuffer,30); 
09BE:  MOV     #1E,W4
09C0:  MOV     W4,9B2
09C2:  MOV     #800,W4
09C4:  MOV     W4,9B0
09C6:  CALL    818
09CA:  MOV     W0,99E
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
09CC:  MOV     99E,W4
09CE:  CP      W4,#1
09D0:  BRA     NZ,9EC
09D2:  MOV     #0,W5
09D4:  MOV     W5,W0
09D6:  CALL    136
09DA:  IOR.B   #0,W0L
09DC:  BTSC.B  42.1
09DE:  BRA     9EA
09E0:  INC     W5,W5
09E2:  MOV.B   W0L,9AF
09E4:  CALL    724
09E8:  BRA     9D4
.................... 					else  
09EA:  BRA     A06
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
09EC:  MOV     #0,W5
09EE:  MOV     W5,W0
09F0:  CALL    14A
09F4:  IOR.B   #0,W0L
09F6:  BTSC.B  42.1
09F8:  BRA     A04
09FA:  INC     W5,W5
09FC:  MOV.B   W0L,9AF
09FE:  CALL    724
0A02:  BRA     9EE
.................... 							status=0; 
0A04:  CLR     99E
.................... 						} 
.................... 					delay_ms(500); 
0A06:  MOV     #1F4,W0
0A08:  CALL    484
.................... 				} 
....................  
.................... 			if(status==1) 
0A0C:  MOV     99E,W4
0A0E:  CP      W4,#1
0A10:  BRA     NZ,A9C
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0A12:  CLR.B   9C7
0A14:  MOV     #800,W4
0A16:  MOV     W4,9C8
0A18:  MOV     #15E,W4
0A1A:  MOV     W4,9CA
0A1C:  CALL    770
.................... 					printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
0A20:  MOV     #0,W1
0A22:  MOV     W1,W0
0A24:  CALL    1BC
0A28:  INC     W1,W1
0A2A:  MOV     W1,[W15++]
0A2C:  BTSC.B  20F.1
0A2E:  BRA     A2C
0A30:  MOV     W0,210
0A32:  MOV     [--W15],W1
0A34:  MOV     #30,W0
0A36:  CPSGT   W1,W0
0A38:  BRA     A22
.................... 					ReadBuffer(InputBuffer); 
0A3A:  MOV     #800,W4
0A3C:  MOV     W4,9C8
0A3E:  CALL    790
.................... 					PrintBuffer(InputBuffer,1000); 
0A42:  MOV     #800,W4
0A44:  MOV     W4,9A4
0A46:  MOV     #3E8,W4
0A48:  MOV     W4,9A6
0A4A:  CALL    7DE
.................... 					status=ValidateCommand(InputBuffer,30); 
0A4E:  MOV     #1E,W4
0A50:  MOV     W4,9B2
0A52:  MOV     #800,W4
0A54:  MOV     W4,9B0
0A56:  CALL    818
0A5A:  MOV     W0,99E
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0A5C:  MOV     99E,W4
0A5E:  CP      W4,#1
0A60:  BRA     NZ,A7C
0A62:  MOV     #0,W5
0A64:  MOV     W5,W0
0A66:  CALL    136
0A6A:  IOR.B   #0,W0L
0A6C:  BTSC.B  42.1
0A6E:  BRA     A7A
0A70:  INC     W5,W5
0A72:  MOV.B   W0L,9AF
0A74:  CALL    724
0A78:  BRA     A64
.................... 					else  
0A7A:  BRA     A96
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0A7C:  MOV     #0,W5
0A7E:  MOV     W5,W0
0A80:  CALL    14A
0A84:  IOR.B   #0,W0L
0A86:  BTSC.B  42.1
0A88:  BRA     A94
0A8A:  INC     W5,W5
0A8C:  MOV.B   W0L,9AF
0A8E:  CALL    724
0A92:  BRA     A7E
.................... 							status=0; 
0A94:  CLR     99E
.................... 						} 
.................... 					delay_ms(500); 
0A96:  MOV     #1F4,W0
0A98:  CALL    484
.................... 				} 
.................... 			count++; 
0A9C:  INC     09A0
.................... 		} 
0A9E:  BRA     858
.................... 	//return status; 
.................... } 
0AA0:  MOV     [--W15],W5
0AA2:  RETURN  
....................  
.................... /***********OpenPort************************************** 
.................... **   Description: Open a TCP port in domain name and    ** 
.................... **     specified in dname and rport variables           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int OpenPort(int socket, int lport,char dname[100], int rport) 
.................... { 
.................... 	int state=0; 
.................... 	printf("AT+AIPO=%d,%d,\"%s\",%d,0,,1,2\r\n",socket,lport,dname,rport);  //Conect to server 
.................... 	//******Get incoming buffer data****** 
.................... 	ReadBuffer(InputBuffer); 
.................... 	//***Validate ok command************** 
.................... 	state=ValidateCommand(InputBuffer,30); 
.................... 	if(state==1) lcd_putc("\fCMD OK"); 
.................... 	else 
.................... 		{ 
.................... 			 lcd_putc("\fCMD BAD"); 
.................... 			 state=0; 
.................... 		} 
.................... 	delay_ms(ptime); 
.................... 	return state; 
.................... } 
....................  
.................... /***********ClosePort************************************* 
.................... **   Description: Close a TCP port in domain name and   ** 
.................... **     specified in dname and rport variables           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ClosePort(int socket) 
.................... { 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
*
0F56:  CLR.B   9C7
0F58:  MOV     #800,W4
0F5A:  MOV     W4,9C8
0F5C:  MOV     #15E,W4
0F5E:  MOV     W4,9CA
0F60:  CALL    770
.................... 	printf("AT+AIPC=%d\r\n",socket);  //Disconnect 
0F64:  MOV     #0,W1
0F66:  MOV     W1,W0
0F68:  CALL    1FA
0F6C:  INC     W1,W1
0F6E:  MOV     W1,[W15++]
0F70:  BTSC.B  20F.1
0F72:  BRA     F70
0F74:  MOV     W0,210
0F76:  MOV     [--W15],W1
0F78:  MOV     #7,W0
0F7A:  CPSGT   W1,W0
0F7C:  BRA     F66
0F7E:  MOV     9C2,W0
0F80:  MOV     #0,W4
0F82:  CALL    AA4
0F86:  BTSC.B  20F.1
0F88:  BRA     F86
0F8A:  MOV     #D,W4
0F8C:  MOV     W4,210
0F8E:  BTSC.B  20F.1
0F90:  BRA     F8E
0F92:  MOV     #A,W4
0F94:  MOV     W4,210
.................... 	ReadBuffer(InputBuffer); 
0F96:  MOV     #800,W4
0F98:  MOV     W4,9C8
0F9A:  CALL    790
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	//delay_ms(ptime); 
.................... } 
0F9E:  RETURN  
....................  
.................... /***********ConfigureDatetime***************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  dy24mt3yr2014hr11mn52$ (24/marzo/2014 11:52 a.m)    ** 
.................... *********************************************************/ 
.................... int ConfigureDatetime(int Id, byte* DateTime) 
.................... { 
*
0C14:  MOV     W5,[W15++]
0C16:  MOV     W6,[W15++]
0C18:  CLR     9A2
0C1A:  CLR     9A4
.................... 	int status=0; 
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
0C1C:  CLR.B   9C7
0C1E:  MOV     #800,W4
0C20:  MOV     W4,9C8
0C22:  MOV     #15E,W4
0C24:  MOV     W4,9CA
0C26:  CALL    770
.................... 	printf("GET /TIMEGPRS/NOWTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
0C2A:  MOV     #0,W1
0C2C:  MOV     W1,W0
0C2E:  CALL    214
0C32:  INC     W1,W1
0C34:  MOV     W1,[W15++]
0C36:  BTSC.B  20F.1
0C38:  BRA     C36
0C3A:  MOV     W0,210
0C3C:  MOV     [--W15],W1
0C3E:  MOV     #15,W0
0C40:  CPSGT   W1,W0
0C42:  BRA     C2C
0C44:  MOV     99E,W0
0C46:  MOV     #0,W4
0C48:  CALL    AA4
0C4C:  MOV     #18,W1
0C4E:  MOV     W1,W0
0C50:  CALL    214
0C54:  INC     W1,W1
0C56:  MOV     W1,[W15++]
0C58:  BTSC.B  20F.1
0C5A:  BRA     C58
0C5C:  MOV     W0,210
0C5E:  MOV     [--W15],W1
0C60:  MOV     #44,W0
0C62:  CPSGT   W1,W0
0C64:  BRA     C4E
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
0C66:  MOV     #800,W4
0C68:  MOV     9A4,W3
0C6A:  ADD     W3,W4,W5
0C6C:  BTSS.B  20E.0
0C6E:  BRA     C6C
0C70:  MOV     212,W0
0C72:  MOV.B   W0L,[W5]
.................... 		index++; 
0C74:  INC     09A4
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
0C76:  MOV     9A4,W4
0C78:  MOV     #15E,W3
0C7A:  CP      W3,W4
0C7C:  BRA     LE,C8C
0C7E:  MOV     9A4,W4
0C80:  SUB     W4,#1,W5
0C82:  MOV     #800,W4
0C84:  ADD     W5,W4,W0
0C86:  MOV.B   [W0],W4L
0C88:  XOR.B   #24,W4L
0C8A:  BRA     NZ,C66
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
0C8C:  MOV     #32,W0
0C8E:  CALL    484
.................... 	printf("+++\r\n"); 
0C92:  MOV     #0,W1
0C94:  MOV     W1,W0
0C96:  CALL    260
0C9A:  INC     W1,W1
0C9C:  MOV     W1,[W15++]
0C9E:  BTSC.B  20F.1
0CA0:  BRA     C9E
0CA2:  MOV     W0,210
0CA4:  MOV     [--W15],W1
0CA6:  MOV     #4,W0
0CA8:  CPSGT   W1,W0
0CAA:  BRA     C94
.................... 	OERR=16; 
0CAC:  MOV.B   #10,W0L
0CAE:  MOV.B   W0L,20E
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
0CB0:  MOV     #800,W4
0CB2:  MOV     W4,9B0
0CB4:  PUSH    9A4
0CB6:  POP     9B2
0CB8:  CALL    818
0CBC:  MOV     W0,W5
0CBE:  CP      W5,#1
0CC0:  BRA     NZ,D7C
.................... 		{ 
.................... 			lcd_putc("\fCMD OK"); 
0CC2:  MOV     #0,W5
0CC4:  MOV     W5,W0
0CC6:  CALL    136
0CCA:  IOR.B   #0,W0L
0CCC:  BTSC.B  42.1
0CCE:  BRA     CDA
0CD0:  INC     W5,W5
0CD2:  MOV.B   W0L,9AF
0CD4:  CALL    724
0CD8:  BRA     CC4
.................... 			delay_ms(ptime); 
0CDA:  MOV     95E,W0
0CDC:  CALL    484
....................  
.................... 			*(DateTime)=(int)GetDecVal(InputBuffer,index,'d','y'); 
0CE0:  MOV     9A0,W5
0CE2:  MOV.B   #64,W0L
0CE4:  MOV.B   W0L,9B1
0CE6:  MOV.B   #79,W0L
0CE8:  MOV.B   W0L,9B6
0CEA:  MOV     #800,W4
0CEC:  MOV     W4,9B2
0CEE:  PUSH    9A4
0CF0:  POP     9B4
0CF2:  CALL    B9E
0CF6:  MOV.B   W0L,[W5]
.................... 			*(DateTime+1)=(int)GetDecVal(InputBuffer,index,'m','t'); 
0CF8:  MOV     9A0,W4
0CFA:  ADD     W4,#1,W4
0CFC:  MOV     W4,W0
0CFE:  MOV     W0,W5
0D00:  MOV.B   #6D,W0L
0D02:  MOV.B   W0L,9B1
0D04:  MOV.B   #74,W0L
0D06:  MOV.B   W0L,9B6
0D08:  MOV     #800,W4
0D0A:  MOV     W4,9B2
0D0C:  PUSH    9A4
0D0E:  POP     9B4
0D10:  CALL    B9E
0D14:  MOV.B   W0L,[W5]
.................... 			*(DateTime+2)=(int)(GetDecVal(InputBuffer,index,'y','r')-2000); 
0D16:  MOV     9A0,W4
0D18:  ADD     W4,#2,W4
0D1A:  MOV     W4,W0
0D1C:  MOV     W0,W5
0D1E:  MOV.B   #79,W0L
0D20:  MOV.B   W0L,9B1
0D22:  MOV.B   #72,W0L
0D24:  MOV.B   W0L,9B6
0D26:  MOV     #800,W4
0D28:  MOV     W4,9B2
0D2A:  PUSH    9A4
0D2C:  POP     9B4
0D2E:  CALL    B9E
0D32:  MOV     W0,W6
0D34:  MOV     #7D0,W4
0D36:  SUB     W6,W4,W0
0D38:  MOV.B   W0L,[W5]
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
0D3A:  MOV     9A0,W4
0D3C:  ADD     W4,#3,W4
0D3E:  MOV     W4,W0
0D40:  MOV     W0,W5
0D42:  MOV.B   #68,W0L
0D44:  MOV.B   W0L,9B1
0D46:  MOV.B   #72,W0L
0D48:  MOV.B   W0L,9B6
0D4A:  MOV     #800,W4
0D4C:  MOV     W4,9B2
0D4E:  PUSH    9A4
0D50:  POP     9B4
0D52:  CALL    B9E
0D56:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
0D58:  MOV     9A0,W4
0D5A:  ADD     W4,#4,W4
0D5C:  MOV     W4,W0
0D5E:  MOV     W0,W5
0D60:  MOV.B   #6D,W0L
0D62:  MOV.B   W0L,9B1
0D64:  MOV.B   #6E,W0L
0D66:  MOV.B   W0L,9B6
0D68:  MOV     #800,W4
0D6A:  MOV     W4,9B2
0D6C:  PUSH    9A4
0D6E:  POP     9B4
0D70:  CALL    B9E
0D74:  MOV.B   W0L,[W5]
....................  
.................... 			status=1; 
0D76:  MOV     #1,W4
0D78:  MOV     W4,9A2
.................... 		} 
....................  
.................... 	else  
0D7A:  BRA     D7E
.................... 		{ 
.................... 			status=0; 
0D7C:  CLR     9A2
.................... 		} 
.................... 	return status; 
0D7E:  PUSH    9A2
0D80:  POP     0
.................... } 
0D82:  MOV     [--W15],W6
0D84:  MOV     [--W15],W5
0D86:  RETURN  
....................  
.................... /***********GetSunriseTime******************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current sunrise time of the specified device     ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  hr11mn52$ (11:52 a.m)                               ** 
.................... *********************************************************/ 
.................... void GetSunriseTime(int Id, byte* DateTime) 
.................... { 
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
.................... 	ReadBuffer(InputBuffer); 
.................... 	delay_ms(ptime); 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
.................... 	ReadBuffer(InputBuffer); 
.................... 	delay_ms(ptime); 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("GET /TIMEGPRS/GETSUNRISE/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
....................  
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
.................... 		index++; 
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
.................... 		{ 
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
.................... 	printf("+"); 
.................... 	printf("+"); 
.................... 	printf("+"); 
.................... 	OERR=16; 
.................... 	ReadBuffer(InputBuffer); 
.................... 	ClosePort(1); 
.................... } 
....................  
.................... /***********GetSunsetTime******************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current sunset time of the specified device      ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  hr11mn52$ (11:52 a.m)                               ** 
.................... *********************************************************/ 
.................... void GetSunsetTime(int Id, byte* DateTime) 
.................... { 
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
.................... 	ReadBuffer(InputBuffer); 
.................... 	delay_ms(ptime); 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
.................... 	ReadBuffer(InputBuffer); 
.................... 	delay_ms(ptime); 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("GET /TIMEGPRS/GETSUNSET/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
.................... 		index++; 
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
.................... 		{ 
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
.................... 	printf("+"); 
.................... 	printf("+"); 
.................... 	printf("+"); 
.................... 	OERR=16; 
.................... 	ReadBuffer(InputBuffer); 
.................... 	delay_ms(50); 
.................... 	ClosePort(1); 
.................... } 
....................  
.................... /***********GetMode*************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void GetMode(int Id, int* mod,int state) 
.................... { 
*
0FA0:  MOV     W5,[W15++]
0FA2:  CLR     9A4
0FA4:  CLR     9A6
.................... 	int status=0; 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
0FA6:  CLR.B   9C7
0FA8:  MOV     #800,W4
0FAA:  MOV     W4,9C8
0FAC:  MOV     #15E,W4
0FAE:  MOV     W4,9CA
0FB0:  CALL    770
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
0FB4:  MOV     #0,W1
0FB6:  MOV     W1,W0
0FB8:  CALL    1A4
0FBC:  INC     W1,W1
0FBE:  MOV     W1,[W15++]
0FC0:  BTSC.B  20F.1
0FC2:  BRA     FC0
0FC4:  MOV     W0,210
0FC6:  MOV     [--W15],W1
0FC8:  MOV     #A,W0
0FCA:  CPSGT   W1,W0
0FCC:  BRA     FB6
.................... 	ReadBuffer(InputBuffer); 
0FCE:  MOV     #800,W4
0FD0:  MOV     W4,9C8
0FD2:  CALL    790
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
0FD6:  MOV     95E,W0
0FD8:  CALL    484
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
0FDC:  CLR.B   9C7
0FDE:  MOV     #800,W4
0FE0:  MOV     W4,9C8
0FE2:  MOV     #15E,W4
0FE4:  MOV     W4,9CA
0FE6:  CALL    770
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
0FEA:  MOV     #0,W1
0FEC:  MOV     W1,W0
0FEE:  CALL    1BC
0FF2:  INC     W1,W1
0FF4:  MOV     W1,[W15++]
0FF6:  BTSC.B  20F.1
0FF8:  BRA     FF6
0FFA:  MOV     W0,210
0FFC:  MOV     [--W15],W1
0FFE:  MOV     #30,W0
1000:  CPSGT   W1,W0
1002:  BRA     FEC
.................... 	ReadBuffer(InputBuffer); 
1004:  MOV     #800,W4
1006:  MOV     W4,9C8
1008:  CALL    790
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
100C:  MOV     95E,W0
100E:  CALL    484
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1012:  CLR.B   9C7
1014:  MOV     #800,W4
1016:  MOV     W4,9C8
1018:  MOV     #15E,W4
101A:  MOV     W4,9CA
101C:  CALL    770
.................... 	printf("GET /DEVICEGPRS/GETMODE/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1020:  MOV     #0,W1
1022:  MOV     W1,W0
1024:  CALL    272
1028:  INC     W1,W1
102A:  MOV     W1,[W15++]
102C:  BTSC.B  20F.1
102E:  BRA     102C
1030:  MOV     W0,210
1032:  MOV     [--W15],W1
1034:  MOV     #17,W0
1036:  CPSGT   W1,W0
1038:  BRA     1022
103A:  MOV     99E,W0
103C:  MOV     #0,W4
103E:  CALL    AA4
1042:  MOV     #1A,W1
1044:  MOV     W1,W0
1046:  CALL    272
104A:  INC     W1,W1
104C:  MOV     W1,[W15++]
104E:  BTSC.B  20F.1
1050:  BRA     104E
1052:  MOV     W0,210
1054:  MOV     [--W15],W1
1056:  MOV     #46,W0
1058:  CPSGT   W1,W0
105A:  BRA     1044
.................... 	while(getc()!='\n'); 
105C:  BTSS.B  20E.0
105E:  BRA     105C
1060:  MOV     212,W0
1062:  CP.B    W0L,#A
1064:  BRA     NZ,105C
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1066:  MOV     #800,W4
1068:  MOV     9A6,W3
106A:  ADD     W3,W4,W5
106C:  BTSS.B  20E.0
106E:  BRA     106C
1070:  MOV     212,W0
1072:  MOV.B   W0L,[W5]
.................... 		index++; 
1074:  INC     09A6
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1076:  MOV     9A6,W4
1078:  MOV     #15E,W3
107A:  CP      W3,W4
107C:  BRA     LE,108C
107E:  MOV     9A6,W4
1080:  SUB     W4,#1,W5
1082:  MOV     #800,W4
1084:  ADD     W5,W4,W0
1086:  MOV.B   [W0],W4L
1088:  XOR.B   #24,W4L
108A:  BRA     NZ,1066
....................  
.................... 	OERR=16; 
108C:  MOV.B   #10,W0L
108E:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1090:  MOV     #800,W4
1092:  MOV     W4,9B0
1094:  PUSH    9A6
1096:  POP     9B2
1098:  CALL    818
109C:  MOV     W0,W5
109E:  CP      W5,#1
10A0:  BRA     NZ,10BE
.................... 		{ 
.................... 			*mod=(int)GetDecVal(InputBuffer,index,'m','d'); 
10A2:  MOV     9A0,W5
10A4:  MOV.B   #6D,W0L
10A6:  MOV.B   W0L,9B1
10A8:  MOV.B   #64,W0L
10AA:  MOV.B   W0L,9B6
10AC:  MOV     #800,W4
10AE:  MOV     W4,9B2
10B0:  PUSH    9A6
10B2:  POP     9B4
10B4:  CALL    B9E
10B8:  MOV     W0,[W5]
.................... 			status=1; 
10BA:  MOV     #1,W4
10BC:  MOV     W4,9A4
.................... 		} 
....................  
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
10BE:  CLR.B   9C7
10C0:  MOV     #800,W4
10C2:  MOV     W4,9C8
10C4:  MOV     #15E,W4
10C6:  MOV     W4,9CA
10C8:  CALL    770
.................... 	index=0; 
10CC:  CLR     9A6
.................... 	printf("GET /DEVICEGPRS/GETSTATUS/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
10CE:  MOV     #0,W1
10D0:  MOV     W1,W0
10D2:  CALL    2BE
10D6:  INC     W1,W1
10D8:  MOV     W1,[W15++]
10DA:  BTSC.B  20F.1
10DC:  BRA     10DA
10DE:  MOV     W0,210
10E0:  MOV     [--W15],W1
10E2:  MOV     #19,W0
10E4:  CPSGT   W1,W0
10E6:  BRA     10D0
10E8:  MOV     99E,W0
10EA:  MOV     #0,W4
10EC:  CALL    AA4
10F0:  MOV     #1C,W1
10F2:  MOV     W1,W0
10F4:  CALL    2BE
10F8:  INC     W1,W1
10FA:  MOV     W1,[W15++]
10FC:  BTSC.B  20F.1
10FE:  BRA     10FC
1100:  MOV     W0,210
1102:  MOV     [--W15],W1
1104:  MOV     #48,W0
1106:  CPSGT   W1,W0
1108:  BRA     10F2
.................... 	while(getc()!='\n'); 
110A:  BTSS.B  20E.0
110C:  BRA     110A
110E:  MOV     212,W0
1110:  CP.B    W0L,#A
1112:  BRA     NZ,110A
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1114:  MOV     #800,W4
1116:  MOV     9A6,W3
1118:  ADD     W3,W4,W5
111A:  BTSS.B  20E.0
111C:  BRA     111A
111E:  MOV     212,W0
1120:  MOV.B   W0L,[W5]
.................... 		index++; 
1122:  INC     09A6
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1124:  MOV     9A6,W4
1126:  MOV     #15E,W3
1128:  CP      W3,W4
112A:  BRA     LE,113A
112C:  MOV     9A6,W4
112E:  SUB     W4,#1,W5
1130:  MOV     #800,W4
1132:  ADD     W5,W4,W0
1134:  MOV.B   [W0],W4L
1136:  XOR.B   #24,W4L
1138:  BRA     NZ,1114
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
113A:  MOV     #800,W4
113C:  MOV     W4,9B0
113E:  PUSH    9A6
1140:  POP     9B2
1142:  CALL    818
1146:  MOV     W0,W5
1148:  CP      W5,#1
114A:  BRA     NZ,1168
.................... 		{ 
.................... 			*state=(int)GetDecVal(InputBuffer,index,'s','t'); 
114C:  MOV     9A2,W5
114E:  MOV.B   #73,W0L
1150:  MOV.B   W0L,9B1
1152:  MOV.B   #74,W0L
1154:  MOV.B   W0L,9B6
1156:  MOV     #800,W4
1158:  MOV     W4,9B2
115A:  PUSH    9A6
115C:  POP     9B4
115E:  CALL    B9E
1162:  MOV.B   W0L,[W5]
.................... 			status=1; 
1164:  MOV     #1,W4
1166:  MOV     W4,9A4
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1168:  MOV     #32,W0
116A:  CALL    484
.................... 	printf("+"); 
116E:  BTSC.B  20F.1
1170:  BRA     116E
1172:  MOV     #2B,W4
1174:  MOV     W4,210
.................... 	printf("+"); 
1176:  BTSC.B  20F.1
1178:  BRA     1176
117A:  MOV     #2B,W4
117C:  MOV     W4,210
.................... 	printf("+"); 
117E:  BTSC.B  20F.1
1180:  BRA     117E
1182:  MOV     #2B,W4
1184:  MOV     W4,210
.................... 	OERR=16; 
1186:  MOV.B   #10,W0L
1188:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
118A:  MOV     #800,W4
118C:  MOV     W4,9C8
118E:  CALL    790
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
1192:  MOV     #32,W0
1194:  CALL    484
.................... 	ClosePort(1); 
1198:  MOV     #1,W4
119A:  MOV     W4,9C2
119C:  CALL    F56
.................... } 
11A0:  MOV     [--W15],W5
11A2:  RETURN  
....................  
.................... /***********ReportData************************************ 
.................... **   Description: Connects to server to report the      ** 
.................... **     current consuptions of current and voltage       ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ReportData(int Id, int state,float curr,float volt) 
.................... { 
*
1A6C:  MOV     W5,[W15++]
1A6E:  CLR     9B4
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1A70:  CLR.B   9C7
1A72:  MOV     #800,W4
1A74:  MOV     W4,9C8
1A76:  MOV     #15E,W4
1A78:  MOV     W4,9CA
1A7A:  CALL    770
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
1A7E:  MOV     #0,W1
1A80:  MOV     W1,W0
1A82:  CALL    1A4
1A86:  INC     W1,W1
1A88:  MOV     W1,[W15++]
1A8A:  BTSC.B  20F.1
1A8C:  BRA     1A8A
1A8E:  MOV     W0,210
1A90:  MOV     [--W15],W1
1A92:  MOV     #A,W0
1A94:  CPSGT   W1,W0
1A96:  BRA     1A80
.................... 	ReadBuffer(InputBuffer); 
1A98:  MOV     #800,W4
1A9A:  MOV     W4,9C8
1A9C:  CALL    790
.................... 	delay_ms(ptime); 
1AA0:  MOV     95E,W0
1AA2:  CALL    484
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1AA6:  CLR.B   9C7
1AA8:  MOV     #800,W4
1AAA:  MOV     W4,9C8
1AAC:  MOV     #15E,W4
1AAE:  MOV     W4,9CA
1AB0:  CALL    770
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
1AB4:  MOV     #0,W1
1AB6:  MOV     W1,W0
1AB8:  CALL    1BC
1ABC:  INC     W1,W1
1ABE:  MOV     W1,[W15++]
1AC0:  BTSC.B  20F.1
1AC2:  BRA     1AC0
1AC4:  MOV     W0,210
1AC6:  MOV     [--W15],W1
1AC8:  MOV     #30,W0
1ACA:  CPSGT   W1,W0
1ACC:  BRA     1AB6
.................... 	ReadBuffer(InputBuffer); 
1ACE:  MOV     #800,W4
1AD0:  MOV     W4,9C8
1AD2:  CALL    790
.................... 	delay_ms(ptime); 
1AD6:  MOV     95E,W0
1AD8:  CALL    484
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer /monitoringgprs/create?id=14&status=0&current=1&voltage=2 
1ADC:  CLR.B   9C7
1ADE:  MOV     #800,W4
1AE0:  MOV     W4,9C8
1AE2:  MOV     #15E,W4
1AE4:  MOV     W4,9CA
1AE6:  CALL    770
.................... 	printf("GET /MONITORINGGPRS/CREATE?ID=%d&STATUS=%d&CURRENT=%6.3f&VOLTAGE=%6.3f HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id,state,curr,volt); 
1AEA:  MOV     #0,W1
1AEC:  MOV     W1,W0
1AEE:  CALL    30C
1AF2:  INC     W1,W1
1AF4:  MOV     W1,[W15++]
1AF6:  BTSC.B  20F.1
1AF8:  BRA     1AF6
1AFA:  MOV     W0,210
1AFC:  MOV     [--W15],W1
1AFE:  MOV     #1D,W0
1B00:  CPSGT   W1,W0
1B02:  BRA     1AEC
1B04:  MOV     9A8,W0
1B06:  MOV     #0,W4
1B08:  CALL    AA4
1B0C:  MOV     #20,W1
1B0E:  MOV     W1,W0
1B10:  CALL    30C
1B14:  INC     W1,W1
1B16:  MOV     W1,[W15++]
1B18:  BTSC.B  20F.1
1B1A:  BRA     1B18
1B1C:  MOV     W0,210
1B1E:  MOV     [--W15],W1
1B20:  MOV     #27,W0
1B22:  CPSGT   W1,W0
1B24:  BRA     1B0E
1B26:  MOV     9AA,W0
1B28:  MOV     #0,W4
1B2A:  CALL    AA4
1B2E:  MOV     #2A,W1
1B30:  MOV     W1,W0
1B32:  CALL    30C
1B36:  INC     W1,W1
1B38:  MOV     W1,[W15++]
1B3A:  BTSC.B  20F.1
1B3C:  BRA     1B3A
1B3E:  MOV     W0,210
1B40:  MOV     [--W15],W1
1B42:  MOV     #32,W0
1B44:  CPSGT   W1,W0
1B46:  BRA     1B30
1B48:  MOV     9AE,W2
1B4A:  MOV     9AC,W1
1B4C:  MOV     #0,W0
1B4E:  CALL    152A
1B52:  MOV     #3,W9
1B54:  MOV     #5,W10
1B56:  CALL    18EA
1B5A:  MOV     #38,W1
1B5C:  MOV     W1,W0
1B5E:  CALL    30C
1B62:  INC     W1,W1
1B64:  MOV     W1,[W15++]
1B66:  BTSC.B  20F.1
1B68:  BRA     1B66
1B6A:  MOV     W0,210
1B6C:  MOV     [--W15],W1
1B6E:  MOV     #40,W0
1B70:  CPSGT   W1,W0
1B72:  BRA     1B5C
1B74:  MOV     9B2,W2
1B76:  MOV     9B0,W1
1B78:  MOV     #0,W0
1B7A:  CALL    152A
1B7E:  MOV     #3,W9
1B80:  MOV     #5,W10
1B82:  CALL    18EA
1B86:  MOV     #46,W1
1B88:  MOV     W1,W0
1B8A:  CALL    30C
1B8E:  INC     W1,W1
1B90:  MOV     W1,[W15++]
1B92:  BTSC.B  20F.1
1B94:  BRA     1B92
1B96:  MOV     W0,210
1B98:  MOV     [--W15],W1
1B9A:  MOV     #72,W0
1B9C:  CPSGT   W1,W0
1B9E:  BRA     1B88
.................... 		//printf("GET /MONITORINGGPRS/CREATE?ID=9&STATUS=1&CURRENT=6&VOLTAGE=6 HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n"); 
.................... 	while(getc()!='\n'); 
1BA0:  BTSS.B  20E.0
1BA2:  BRA     1BA0
1BA4:  MOV     212,W0
1BA6:  CP.B    W0L,#A
1BA8:  BRA     NZ,1BA0
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1BAA:  MOV     #800,W4
1BAC:  MOV     9B4,W3
1BAE:  ADD     W3,W4,W5
1BB0:  BTSS.B  20E.0
1BB2:  BRA     1BB0
1BB4:  MOV     212,W0
1BB6:  MOV.B   W0L,[W5]
.................... 		index++; 
1BB8:  INC     09B4
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1BBA:  MOV     9B4,W4
1BBC:  MOV     #15E,W3
1BBE:  CP      W3,W4
1BC0:  BRA     LE,1BD0
1BC2:  MOV     9B4,W4
1BC4:  SUB     W4,#1,W5
1BC6:  MOV     #800,W4
1BC8:  ADD     W5,W4,W0
1BCA:  MOV.B   [W0],W4L
1BCC:  XOR.B   #24,W4L
1BCE:  BRA     NZ,1BAA
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1BD0:  MOV     #32,W0
1BD2:  CALL    484
.................... 	printf("+"); 
1BD6:  BTSC.B  20F.1
1BD8:  BRA     1BD6
1BDA:  MOV     #2B,W4
1BDC:  MOV     W4,210
.................... 	printf("+"); 
1BDE:  BTSC.B  20F.1
1BE0:  BRA     1BDE
1BE2:  MOV     #2B,W4
1BE4:  MOV     W4,210
.................... 	printf("+"); 
1BE6:  BTSC.B  20F.1
1BE8:  BRA     1BE6
1BEA:  MOV     #2B,W4
1BEC:  MOV     W4,210
.................... 	OERR=16; 
1BEE:  MOV.B   #10,W0L
1BF0:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
1BF2:  MOV     #800,W4
1BF4:  MOV     W4,9C8
1BF6:  CALL    790
.................... 	delay_ms(50); 
1BFA:  MOV     #32,W0
1BFC:  CALL    484
.................... 	ClosePort(1); 
1C00:  MOV     #1,W4
1C02:  MOV     W4,9C2
1C04:  CALL    F56
.................... 	delay_ms(5000); 
1C08:  MOV     #1388,W0
1C0A:  CALL    484
.................... } 
1C0E:  MOV     [--W15],W5
1C10:  RETURN  
....................  
.................... /***********CreateAlert*********************************** 
.................... **   Description: Connects to server to report the      ** 
.................... **     current alert detected by the device             ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void CreateAlert(int Id, int type) 
.................... { 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
.................... 	ReadBuffer(InputBuffer); 
.................... 	PrintBuffer(InputBuffer,ptime); 
.................... 	if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
.................... 	ReadBuffer(InputBuffer); 
.................... 	PrintBuffer(InputBuffer,ptime); 
.................... 	if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer /monitoringgprs/create?id=14&status=0&current=1&voltage=2 
.................... 	printf("GET /ALERTGGPRS/CREATE?ID=%d&TYPE=%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id,type); 
.................... 	while(getc()!='\n'); 
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
.................... 		index++; 
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
.................... 	printf("+++\r\n"); 
.................... 	OERR=16; 
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	PrintBuffer(InputBuffer,1000); 
....................  
.................... 	ClosePort(1); 
.................... } 
....................  
....................  
....................  
.................... /******************Global variables***********************/ 
.................... int operation_mode=0,lamp_status=1,lamp_statusw=1,alert_status=0;//,alert_type; 
.................... //int port_status=0,port_statusw=0; //New variables used in new operation mode 
.................... int lamp1=0,lamp2=0; 
.................... int16 Device_Id=9,loops=0,i_=0; 
....................  
.................... float current=0,battery=0,temp=0,s1=0,s2=0,reference=0; 
....................  
.................... byte DateTime[6]={0,2,13,8,30,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
*
1DBE:  MOV     #200,W4
1DC0:  MOV     W4,98A
1DC2:  MOV     #80D,W4
1DC4:  MOV     W4,98C
1DC6:  MOV     #1E,W4
1DC8:  MOV     W4,98E
.................... byte RiseTime[6]={25,2,13,19,27,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
1DCA:  MOV     #219,W4
1DCC:  MOV     W4,990
1DCE:  MOV     #130D,W4
1DD0:  MOV     W4,992
1DD2:  MOV     #1B,W4
1DD4:  MOV     W4,994
.................... byte SetTime[6]={25,2,13,19,29,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
1DD6:  MOV     #219,W4
1DD8:  MOV     W4,996
1DDA:  MOV     #130D,W4
1DDC:  MOV     W4,998
1DDE:  MOV     #1D,W4
1DE0:  MOV     W4,99A
.................... byte dow1=0; 
....................  
.................... //new datetime variables for new operation mode 
.................... //byte OnTime[6]={25,2,13,19,27,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
.................... //byte OffTime[6]={25,2,13,19,29,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
....................  
.................... /******************Main function, program****************/ 
.................... void main(void) 
.................... {	 
*
1C12:  BSET.B  81.7
1C14:  MOV     #8000,W4
1C16:  MOV     W4,20C
1C18:  MOV     #400,W4
1C1A:  MOV     W4,20E
1C1C:  MOV     #3,W4
1C1E:  MOV     W4,214
1C20:  MOV     #64,W4
1C22:  MOV     W4,95E
1C24:  CLR     960
1C26:  MOV     #1,W4
1C28:  MOV     W4,962
1C2A:  MOV     #1,W4
1C2C:  MOV     W4,964
1C2E:  CLR     966
1C30:  CLR     968
1C32:  CLR     96A
1C34:  MOV     #9,W4
1C36:  MOV     W4,96C
1C38:  CLR     96E
1C3A:  CLR     970
1C3C:  CLR     972
1C3E:  CLR     974
1C40:  CLR     976
1C42:  CLR     978
1C44:  CLR     97A
1C46:  CLR     97C
1C48:  CLR     97E
1C4A:  CLR     980
1C4C:  CLR     982
1C4E:  CLR     984
1C50:  CLR     986
1C52:  CLR     988
1C54:  CLR.B   99C
1C56:  SETM    2A8
1C58:  MOV     #F80,W15
1C5A:  MOV     #FFF,W0
1C5C:  MOV     W0,20
1C5E:  NOP     
.................... 	//***Component initializers**** 
.................... 	lcd_init();        //LCD INITIALIZE 
*
1DE2:  CALL    5AE
.................... 	//init_dac();      //MPC4921 DAC INITIALIZE 
.................... 	rtc_init();		   //DS1302 RTC INITIALIZE 
1DE6:  CALL    6B2
.................... 	//***Device initialize********* 
.................... 	lcd_putc("\fTelegestion UTCH"); 
1DEA:  MOV     #0,W5
1DEC:  MOV     W5,W0
1DEE:  CALL    376
1DF2:  IOR.B   #0,W0L
1DF4:  BTSC.B  42.1
1DF6:  BRA     1E02
1DF8:  INC     W5,W5
1DFA:  MOV.B   W0L,9AF
1DFC:  CALL    724
1E00:  BRA     1DEC
.................... 	delay_ms(100); 
1E02:  MOV     #64,W0
1E04:  CALL    484
.................... 	setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN5|sAN6);//*******Setup ch0, ch1 and ch2 as ADC inputs in Px, Py and Pz****** 
1E08:  MOV     #FF80,W4
1E0A:  MOV     W4,2A8
1E0C:  CLR     2A2
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
1E0E:  MOV     #80,W4
1E10:  MOV     W4,2A4
1E12:  MOV     #80E0,W4
1E14:  MOV     W4,2A0
.................... 	//******Configure PORTB*********** 
.................... 	SET_TRIS_B(0x007F);   //PB0, PB1, PB2 as input, PB3-PB15 as output (0b0000000000000111) 
1E16:  MOV     #7F,W4
1E18:  MOV     W4,2C6
.................... 	//******Clear RS232 error********** 
.................... 	OERR=16; 
1E1A:  MOV.B   #10,W0L
1E1C:  MOV.B   W0L,20E
.................... 	//******Configure GPRS device****** 
.................... 	ConfigureGPRS(); 
1E1E:  CALL    852
.................... 	//******Set datetime***************** 
.................... 	switch(ConfigureDatetime(Device_Id, DateTime)) 
.................... 	{ 
1E22:  PUSH    96C
1E24:  POP     99E
1E26:  MOV     #98A,W4
1E28:  MOV     W4,9A0
1E2A:  CALL    C14
1E2E:  XOR     #0,W0
1E30:  BRA     Z,1E38
1E32:  XOR     #1,W0
1E34:  BRA     Z,1E52
1E36:  BRA     1F08
.................... 		case 0: 
.................... 			lcd_putc("\fCMD BAD"); 
1E38:  MOV     #0,W5
1E3A:  MOV     W5,W0
1E3C:  CALL    14A
1E40:  IOR.B   #0,W0L
1E42:  BTSC.B  42.1
1E44:  BRA     1E50
1E46:  INC     W5,W5
1E48:  MOV.B   W0L,9AF
1E4A:  CALL    724
1E4E:  BRA     1E3A
.................... 		break; 
1E50:  BRA     1F22
.................... 		case 1: 
.................... 			rtc_set_datetime(DateTime[day_],DateTime[month_],DateTime[year_],dow1,DateTime[hour_],DateTime[min_]); 
1E52:  MOV.B   98A,W0L
1E54:  MOV.B   W0L,99D
1E56:  MOV.B   98B,W0L
1E58:  MOV.B   W0L,99E
1E5A:  MOV.B   98C,W0L
1E5C:  MOV.B   W0L,99F
1E5E:  MOV.B   99C,W0L
1E60:  MOV.B   W0L,9A0
1E62:  MOV.B   98D,W0L
1E64:  MOV.B   W0L,9A1
1E66:  MOV.B   98E,W0L
1E68:  MOV.B   W0L,9A2
1E6A:  CALL    DB0
.................... 			lcd_putc("\f"); 
1E6E:  MOV     #0,W5
1E70:  MOV     W5,W0
1E72:  CALL    110
1E76:  IOR.B   #0,W0L
1E78:  BTSC.B  42.1
1E7A:  BRA     1E86
1E7C:  INC     W5,W5
1E7E:  MOV.B   W0L,9AF
1E80:  CALL    724
1E84:  BRA     1E70
.................... 			lcd_putc("Datetime:\n"); 
1E86:  MOV     #0,W5
1E88:  MOV     W5,W0
1E8A:  CALL    394
1E8E:  IOR.B   #0,W0L
1E90:  BTSC.B  42.1
1E92:  BRA     1E9E
1E94:  INC     W5,W5
1E96:  MOV.B   W0L,9AF
1E98:  CALL    724
1E9C:  BRA     1E88
.................... 			printf(lcd_putc,"%d/%d/20%d %02d:%02d",DateTime[day_],DateTime[month_],DateTime[year_],DateTime[hour_],DateTime[min_]); 
1E9E:  MOV.B   98A,W0L
1EA0:  SE      W0,W0
1EA2:  MOV     #0,W4
1EA4:  CALL    E5C
1EA8:  MOV.B   #2F,W0L
1EAA:  MOV.B   W0L,9AF
1EAC:  CALL    724
1EB0:  MOV.B   98B,W0L
1EB2:  SE      W0,W0
1EB4:  MOV     #0,W4
1EB6:  CALL    E5C
1EBA:  MOV.B   #2F,W0L
1EBC:  MOV.B   W0L,9AF
1EBE:  CALL    724
1EC2:  MOV.B   #32,W0L
1EC4:  MOV.B   W0L,9AF
1EC6:  CALL    724
1ECA:  MOV.B   #30,W0L
1ECC:  MOV.B   W0L,9AF
1ECE:  CALL    724
1ED2:  MOV.B   98C,W0L
1ED4:  SE      W0,W0
1ED6:  MOV     #0,W4
1ED8:  CALL    E5C
1EDC:  MOV.B   #20,W0L
1EDE:  MOV.B   W0L,9AF
1EE0:  CALL    724
1EE4:  MOV.B   98D,W0L
1EE6:  SE      W0,W0
1EE8:  MOV     #8002,W4
1EEA:  CALL    E5C
1EEE:  MOV.B   #3A,W0L
1EF0:  MOV.B   W0L,9AF
1EF2:  CALL    724
1EF6:  MOV.B   98E,W0L
1EF8:  SE      W0,W0
1EFA:  MOV     #8002,W4
1EFC:  CALL    E5C
.................... 			delay_ms(1000); 
1F00:  MOV     #3E8,W0
1F02:  CALL    484
.................... 		break; 
1F06:  BRA     1F22
.................... 		default: 
.................... 			lcd_putc("\fCMD BAD"); 
1F08:  MOV     #0,W5
1F0A:  MOV     W5,W0
1F0C:  CALL    14A
1F10:  IOR.B   #0,W0L
1F12:  BTSC.B  42.1
1F14:  BRA     1F20
1F16:  INC     W5,W5
1F18:  MOV.B   W0L,9AF
1F1A:  CALL    724
1F1E:  BRA     1F0A
.................... 		break; 
1F20:  BRA     1F22
....................  
.................... 	} 
.................... 	ClosePort(1); 
1F22:  MOV     #1,W4
1F24:  MOV     W4,9C2
1F26:  CALL    F56
.................... 	//***While loop, main program starts here*** 
.................... 	while(TRUE) 
.................... 	{//*****Start of while loop**************        
.................... 		for(loops=0;loops<4;loops++) 
1F2A:  CLR     96E
1F2C:  MOV     96E,W4
1F2E:  CP      W4,#4
1F30:  BRA     GE,2432
.................... 			{//*****Start of for loop************** 
.................... 				 //**********BUZZER******************** 
.................... 					output_bit(PIN_D9,alert_status);  //BUZZER depend of alert state 
1F32:  CP0     966
1F34:  BRA     NZ,1F3A
1F36:  BCLR.B  2D7.1
1F38:  BRA     1F3C
1F3A:  BSET.B  2D7.1
1F3C:  BCLR.B  2D3.1
....................  
.................... 				    //**********GPO*********************** 
....................  
.................... 					//******Get status/mode*********************** 
.................... 					lcd_putc("\fGetting data\nfrom server.+."); 
1F3E:  MOV     #0,W5
1F40:  MOV     W5,W0
1F42:  CALL    3AC
1F46:  IOR.B   #0,W0L
1F48:  BTSC.B  42.1
1F4A:  BRA     1F56
1F4C:  INC     W5,W5
1F4E:  MOV.B   W0L,9AF
1F50:  CALL    724
1F54:  BRA     1F40
.................... 					GetMode(Device_Id,&operation_mode,&lamp_statusw);	 
1F56:  PUSH    96C
1F58:  POP     99E
1F5A:  MOV     #960,W4
1F5C:  MOV     W4,9A0
1F5E:  MOV     #964,W4
1F60:  MOV     W4,9A2
1F62:  CALL    FA0
.................... 					delay_ms(1500);		 
1F66:  MOV     #5DC,W0
1F68:  CALL    484
....................  
.................... 					switch(operation_mode) 
.................... 						{ 
1F6C:  MOV     960,W0
1F6E:  XOR     #2,W0
1F70:  BRA     Z,1F78
1F72:  XOR     #3,W0
1F74:  BRA     Z,1F86
1F76:  BRA     1FBE
.................... 							case Manual_Mode: 
.................... 								lamp_status=lamp_statusw; 
1F78:  PUSH    964
1F7A:  POP     962
.................... 								lamp1= lamp_status; lamp2=lamp_status; 
1F7C:  PUSH    962
1F7E:  POP     968
1F80:  PUSH    962
1F82:  POP     96A
.................... 							break; 
1F84:  BRA     1FC0
....................  
.................... 							case Automated_Mode: 
.................... 								if(DateTime[day_]==RiseTime[day_]&&DateTime[hour_]==RiseTime[hour_]&&DateTime[min_]>=RiseTime[min_]) lamp_status=0; 
1F86:  MOV.B   98A,W0L
1F88:  CP.B    990
1F8A:  BRA     NZ,1F9C
1F8C:  MOV.B   98D,W0L
1F8E:  CP.B    993
1F90:  BRA     NZ,1F9C
1F92:  MOV.B   994,W0L
1F94:  MOV     98E,W4
1F96:  CP.B    W4L,W0L
1F98:  BRA     NC,1F9C
1F9A:  CLR     962
.................... 								if(DateTime[day_]==SetTime[day_]&&DateTime[hour_]==SetTime[hour_]&&DateTime[min_]>=SetTime[min_]) lamp_status=1; 
1F9C:  MOV.B   98A,W0L
1F9E:  CP.B    996
1FA0:  BRA     NZ,1FB4
1FA2:  MOV.B   98D,W0L
1FA4:  CP.B    999
1FA6:  BRA     NZ,1FB4
1FA8:  MOV.B   99A,W0L
1FAA:  MOV     98E,W4
1FAC:  CP.B    W4L,W0L
1FAE:  BRA     NC,1FB4
1FB0:  MOV     #1,W4
1FB2:  MOV     W4,962
.................... 								lamp1= lamp_status; lamp2=lamp_status; 
1FB4:  PUSH    962
1FB6:  POP     968
1FB8:  PUSH    962
1FBA:  POP     96A
.................... 							break;		 
1FBC:  BRA     1FC0
.................... 							default: 
.................... 							break; 
1FBE:  BRA     1FC0
.................... 						}						 
.................... 					output_bit(PIN_B7,lamp1); 
1FC0:  CP0     968
1FC2:  BRA     NZ,1FC8
1FC4:  BCLR.B  2CA.7
1FC6:  BRA     1FCA
1FC8:  BSET.B  2CA.7
1FCA:  MOV     #7E,W4
1FCC:  MOV     W4,2C6
.................... 					output_bit(PIN_B8,lamp2);					 
1FCE:  CP0     96A
1FD0:  BRA     NZ,1FD6
1FD2:  BCLR.B  2CB.0
1FD4:  BRA     1FD8
1FD6:  BSET.B  2CB.0
1FD8:  MOV     #7E,W4
1FDA:  MOV     W4,2C6
.................... 					//******RTC Get and show datetime***** 
.................... 					lcd_putc("\f"); 
1FDC:  MOV     #0,W5
1FDE:  MOV     W5,W0
1FE0:  CALL    110
1FE4:  IOR.B   #0,W0L
1FE6:  BTSC.B  42.1
1FE8:  BRA     1FF4
1FEA:  INC     W5,W5
1FEC:  MOV.B   W0L,9AF
1FEE:  CALL    724
1FF2:  BRA     1FDE
.................... 					lcd_putc("Datetime:\n"); 
1FF4:  MOV     #0,W5
1FF6:  MOV     W5,W0
1FF8:  CALL    394
1FFC:  IOR.B   #0,W0L
1FFE:  BTSC.B  42.1
2000:  BRA     200C
2002:  INC     W5,W5
2004:  MOV.B   W0L,9AF
2006:  CALL    724
200A:  BRA     1FF6
.................... 					rtc_get_date(DateTime[day_],DateTime[month_],DateTime[year_],dow1); 
.................... 					rtc_get_time(DateTime[hour_],DateTime[min_],DateTime[sec_]); 
.................... 					printf(lcd_putc,"%d/%d/20%d %02d:%02d",DateTime[day_],DateTime[month_],DateTime[year_],DateTime[hour_],DateTime[min_]); 
*
2098:  MOV.B   98A,W0L
209A:  SE      W0,W0
209C:  MOV     #0,W4
209E:  CALL    E5C
20A2:  MOV.B   #2F,W0L
20A4:  MOV.B   W0L,9AF
20A6:  CALL    724
20AA:  MOV.B   98B,W0L
20AC:  SE      W0,W0
20AE:  MOV     #0,W4
20B0:  CALL    E5C
20B4:  MOV.B   #2F,W0L
20B6:  MOV.B   W0L,9AF
20B8:  CALL    724
20BC:  MOV.B   #32,W0L
20BE:  MOV.B   W0L,9AF
20C0:  CALL    724
20C4:  MOV.B   #30,W0L
20C6:  MOV.B   W0L,9AF
20C8:  CALL    724
20CC:  MOV.B   98C,W0L
20CE:  SE      W0,W0
20D0:  MOV     #0,W4
20D2:  CALL    E5C
20D6:  MOV.B   #20,W0L
20D8:  MOV.B   W0L,9AF
20DA:  CALL    724
20DE:  MOV.B   98D,W0L
20E0:  SE      W0,W0
20E2:  MOV     #8002,W4
20E4:  CALL    E5C
20E8:  MOV.B   #3A,W0L
20EA:  MOV.B   W0L,9AF
20EC:  CALL    724
20F0:  MOV.B   98E,W0L
20F2:  SE      W0,W0
20F4:  MOV     #8002,W4
20F6:  CALL    E5C
.................... 					delay_ms(2000); 
20FA:  MOV     #7D0,W0
20FC:  CALL    484
....................  
.................... 					//******Get and show status/mode******* 
.................... 					lcd_putc("\f"); 
2100:  MOV     #0,W5
2102:  MOV     W5,W0
2104:  CALL    110
2108:  IOR.B   #0,W0L
210A:  BTSC.B  42.1
210C:  BRA     2118
210E:  INC     W5,W5
2110:  MOV.B   W0L,9AF
2112:  CALL    724
2116:  BRA     2102
.................... 					printf(lcd_putc,"Mode: %d\nStatus: %d",operation_mode,lamp_status); 
2118:  MOV     #0,W1
211A:  MOV     W1,W0
211C:  CALL    3D6
2120:  INC     W1,W1
2122:  MOV     W1,[W15++]
2124:  MOV.B   W0L,9AF
2126:  CALL    724
212A:  MOV     [--W15],W1
212C:  MOV     #5,W0
212E:  CPSGT   W1,W0
2130:  BRA     211A
2132:  MOV     960,W0
2134:  MOV     #0,W4
2136:  CALL    E5C
213A:  MOV     #8,W1
213C:  MOV     W1,W0
213E:  CALL    3D6
2142:  INC     W1,W1
2144:  MOV     W1,[W15++]
2146:  MOV.B   W0L,9AF
2148:  CALL    724
214C:  MOV     [--W15],W1
214E:  MOV     #10,W0
2150:  CPSGT   W1,W0
2152:  BRA     213C
2154:  MOV     962,W0
2156:  MOV     #0,W4
2158:  CALL    E5C
.................... 					delay_ms(2000); 
215C:  MOV     #7D0,W0
215E:  CALL    484
....................  
.................... 					//******Get and show current/voltage*** 
.................... 					set_adc_channel(0);  //temp sensor 
2162:  CLR     2A6
.................... 					temp=read_ADC(); 
2164:  BCLR.B  2A0.0
2166:  BSET.B  2A0.1
2168:  BTSS.B  2A0.0
216A:  BRA     2168
216C:  MOV     280,W0
216E:  CALL    11C8
2172:  MOV     W0,97A
2174:  MOV     W1,97C
.................... 					delay_us(100); 
2176:  REPEAT  #2DF
2178:  NOP     
.................... 					set_adc_channel(1); 
217A:  MOV     #1,W4
217C:  MOV     W4,2A6
.................... 					current=read_ADC(); 
217E:  BCLR.B  2A0.0
2180:  BSET.B  2A0.1
2182:  BTSS.B  2A0.0
2184:  BRA     2182
2186:  MOV     280,W0
2188:  CALL    11C8
218C:  MOV     W0,972
218E:  MOV     W1,974
.................... 					delay_us(100); 
2190:  REPEAT  #2DF
2192:  NOP     
.................... 					set_adc_channel(5); 
2194:  MOV     #5,W4
2196:  MOV     W4,2A6
.................... 					battery=read_ADC(); 
2198:  BCLR.B  2A0.0
219A:  BSET.B  2A0.1
219C:  BTSS.B  2A0.0
219E:  BRA     219C
21A0:  MOV     280,W0
21A2:  CALL    11C8
21A6:  MOV     W0,976
21A8:  MOV     W1,978
.................... 					delay_us(100); 
21AA:  REPEAT  #2DF
21AC:  NOP     
.................... 					set_adc_channel(3); 
21AE:  MOV     #3,W4
21B0:  MOV     W4,2A6
.................... 					s1=read_ADC(); 
21B2:  BCLR.B  2A0.0
21B4:  BSET.B  2A0.1
21B6:  BTSS.B  2A0.0
21B8:  BRA     21B6
21BA:  MOV     280,W0
21BC:  CALL    11C8
21C0:  MOV     W0,97E
21C2:  MOV     W1,980
.................... 					delay_us(100); 
21C4:  REPEAT  #2DF
21C6:  NOP     
.................... 					set_adc_channel(4); 
21C8:  MOV     #4,W4
21CA:  MOV     W4,2A6
.................... 					s2=read_ADC(); 
21CC:  BCLR.B  2A0.0
21CE:  BSET.B  2A0.1
21D0:  BTSS.B  2A0.0
21D2:  BRA     21D0
21D4:  MOV     280,W0
21D6:  CALL    11C8
21DA:  MOV     W0,982
21DC:  MOV     W1,984
.................... 					delay_us(100); 
21DE:  REPEAT  #2DF
21E0:  NOP     
.................... 					 
.................... 					for(i_=0;i_<10;i_++) 
21E2:  CLR     970
21E4:  MOV     970,W4
21E6:  CP      W4,#A
21E8:  BRA     GE,2216
.................... 					{ 
.................... 						set_adc_channel(6); 
21EA:  MOV     #6,W4
21EC:  MOV     W4,2A6
.................... 						reference=reference+read_ADC(); 
21EE:  BCLR.B  2A0.0
21F0:  BSET.B  2A0.1
21F2:  BTSS.B  2A0.0
21F4:  BRA     21F2
21F6:  MOV     280,W0
21F8:  CALL    11C8
21FC:  BCLR.B  43.0
21FE:  MOV     W0,W2
2200:  MOV     W1,W3
2202:  MOV     986,W0
2204:  MOV     988,W1
2206:  CALL    1202
220A:  MOV     W0,986
220C:  MOV     W1,988
.................... 						delay_us(50); 
220E:  REPEAT  #16E
2210:  NOP     
.................... 					} 
2212:  INC     0970
2214:  BRA     21E4
.................... 					reference=4.12/reference; 
2216:  MOV     #D70A,W0
2218:  MOV     #4083,W1
221A:  MOV     986,W2
221C:  MOV     988,W3
221E:  CALL    13A2
2222:  MOV     W0,986
2224:  MOV     W1,988
.................... 					temp=(temp*reference); 
2226:  MOV     97A,W0
2228:  MOV     97C,W1
222A:  MOV     986,W2
222C:  MOV     988,W3
222E:  CALL    146C
2232:  MOV     W0,97A
2234:  MOV     W1,97C
.................... 					battery=(battery*reference)*3.11; 
2236:  MOV     976,W0
2238:  MOV     978,W1
223A:  MOV     986,W2
223C:  MOV     988,W3
223E:  CALL    146C
2242:  MOV     W0,W5
2244:  MOV     W1,W6
2246:  MOV     W5,W0
2248:  MOV     W6,W1
224A:  MOV     #A3D,W2
224C:  MOV     #4047,W3
224E:  CALL    146C
2252:  MOV     W0,976
2254:  MOV     W1,978
.................... 					s1=s1*reference/.165; 
2256:  MOV     97E,W0
2258:  MOV     980,W1
225A:  MOV     986,W2
225C:  MOV     988,W3
225E:  CALL    146C
2262:  MOV     W0,W5
2264:  MOV     W1,W6
2266:  MOV     W5,W0
2268:  MOV     W6,W1
226A:  MOV     #F5C3,W2
226C:  MOV     #3E28,W3
226E:  CALL    13A2
2272:  MOV     W0,97E
2274:  MOV     W1,980
.................... 					s2=s2*reference/.165; 
2276:  MOV     982,W0
2278:  MOV     984,W1
227A:  MOV     986,W2
227C:  MOV     988,W3
227E:  CALL    146C
2282:  MOV     W0,W5
2284:  MOV     W1,W6
2286:  MOV     W5,W0
2288:  MOV     W6,W1
228A:  MOV     #F5C3,W2
228C:  MOV     #3E28,W3
228E:  CALL    13A2
2292:  MOV     W0,982
2294:  MOV     W1,984
....................  
.................... 					lcd_putc("\f"); 
2296:  MOV     #0,W5
2298:  MOV     W5,W0
229A:  CALL    110
229E:  IOR.B   #0,W0L
22A0:  BTSC.B  42.1
22A2:  BRA     22AE
22A4:  INC     W5,W5
22A6:  MOV.B   W0L,9AF
22A8:  CALL    724
22AC:  BRA     2298
.................... 					printf(lcd_putc,"Battery= %6.3fv",battery); 
22AE:  MOV     #0,W1
22B0:  MOV     W1,W0
22B2:  CALL    3F6
22B6:  INC     W1,W1
22B8:  MOV     W1,[W15++]
22BA:  MOV.B   W0L,9AF
22BC:  CALL    724
22C0:  MOV     [--W15],W1
22C2:  MOV     #8,W0
22C4:  CPSGT   W1,W0
22C6:  BRA     22B0
22C8:  MOV     978,W2
22CA:  MOV     976,W1
22CC:  MOV     #0,W0
22CE:  CALL    152A
22D2:  MOV     #3,W9
22D4:  MOV     #5,W10
22D6:  CALL    1768
22DA:  MOV.B   #76,W0L
22DC:  MOV.B   W0L,9AF
22DE:  CALL    724
.................... 					delay_ms(2000); 
22E2:  MOV     #7D0,W0
22E4:  CALL    484
.................... 					lcd_putc("\f"); 
22E8:  MOV     #0,W5
22EA:  MOV     W5,W0
22EC:  CALL    110
22F0:  IOR.B   #0,W0L
22F2:  BTSC.B  42.1
22F4:  BRA     2300
22F6:  INC     W5,W5
22F8:  MOV.B   W0L,9AF
22FA:  CALL    724
22FE:  BRA     22EA
.................... 					printf(lcd_putc,"Current: %6.3fA\nTemperature: %6.3f",current,temp);//1.1,1.1);//current,temp); 
2300:  MOV     #0,W1
2302:  MOV     W1,W0
2304:  CALL    412
2308:  INC     W1,W1
230A:  MOV     W1,[W15++]
230C:  MOV.B   W0L,9AF
230E:  CALL    724
2312:  MOV     [--W15],W1
2314:  MOV     #8,W0
2316:  CPSGT   W1,W0
2318:  BRA     2302
231A:  MOV     974,W2
231C:  MOV     972,W1
231E:  MOV     #0,W0
2320:  CALL    152A
2324:  MOV     #3,W9
2326:  MOV     #5,W10
2328:  CALL    1768
232C:  MOV     #E,W1
232E:  MOV     W1,W0
2330:  CALL    412
2334:  INC     W1,W1
2336:  MOV     W1,[W15++]
2338:  MOV.B   W0L,9AF
233A:  CALL    724
233E:  MOV     [--W15],W1
2340:  MOV     #1C,W0
2342:  CPSGT   W1,W0
2344:  BRA     232E
2346:  MOV     97C,W2
2348:  MOV     97A,W1
234A:  MOV     #0,W0
234C:  CALL    152A
2350:  MOV     #3,W9
2352:  MOV     #5,W10
2354:  CALL    1768
.................... 					//ReportData(Device_Id,lamp_status,current,voltage); 
.................... 					delay_ms(2000); 
2358:  MOV     #7D0,W0
235A:  CALL    484
.................... 					lcd_putc("\f"); 
235E:  MOV     #0,W5
2360:  MOV     W5,W0
2362:  CALL    110
2366:  IOR.B   #0,W0L
2368:  BTSC.B  42.1
236A:  BRA     2376
236C:  INC     W5,W5
236E:  MOV.B   W0L,9AF
2370:  CALL    724
2374:  BRA     2360
.................... 					printf(lcd_putc,"Reference= %6.3f",reference); 
2376:  MOV     #0,W1
2378:  MOV     W1,W0
237A:  CALL    442
237E:  INC     W1,W1
2380:  MOV     W1,[W15++]
2382:  MOV.B   W0L,9AF
2384:  CALL    724
2388:  MOV     [--W15],W1
238A:  MOV     #A,W0
238C:  CPSGT   W1,W0
238E:  BRA     2378
2390:  MOV     988,W2
2392:  MOV     986,W1
2394:  MOV     #0,W0
2396:  CALL    152A
239A:  MOV     #3,W9
239C:  MOV     #5,W10
239E:  CALL    1768
.................... 					delay_ms(2000); 
23A2:  MOV     #7D0,W0
23A4:  CALL    484
.................... 					lcd_putc("\f"); 
23A8:  MOV     #0,W5
23AA:  MOV     W5,W0
23AC:  CALL    110
23B0:  IOR.B   #0,W0L
23B2:  BTSC.B  42.1
23B4:  BRA     23C0
23B6:  INC     W5,W5
23B8:  MOV.B   W0L,9AF
23BA:  CALL    724
23BE:  BRA     23AA
.................... 					printf(lcd_putc,"S1: %6.3fmA\nS2: %6.3fmA",s1,s2); 
23C0:  MOV     #0,W1
23C2:  MOV     W1,W0
23C4:  CALL    460
23C8:  INC     W1,W1
23CA:  MOV     W1,[W15++]
23CC:  MOV.B   W0L,9AF
23CE:  CALL    724
23D2:  MOV     [--W15],W1
23D4:  MOV     #3,W0
23D6:  CPSGT   W1,W0
23D8:  BRA     23C2
23DA:  MOV     980,W2
23DC:  MOV     97E,W1
23DE:  MOV     #0,W0
23E0:  CALL    152A
23E4:  MOV     #3,W9
23E6:  MOV     #5,W10
23E8:  CALL    1768
23EC:  MOV     #9,W1
23EE:  MOV     W1,W0
23F0:  CALL    460
23F4:  INC     W1,W1
23F6:  MOV     W1,[W15++]
23F8:  MOV.B   W0L,9AF
23FA:  CALL    724
23FE:  MOV     [--W15],W1
2400:  MOV     #F,W0
2402:  CPSGT   W1,W0
2404:  BRA     23EE
2406:  MOV     984,W2
2408:  MOV     982,W1
240A:  MOV     #0,W0
240C:  CALL    152A
2410:  MOV     #3,W9
2412:  MOV     #5,W10
2414:  CALL    1768
2418:  MOV.B   #6D,W0L
241A:  MOV.B   W0L,9AF
241C:  CALL    724
2420:  MOV.B   #41,W0L
2422:  MOV.B   W0L,9AF
2424:  CALL    724
.................... 					delay_ms(10000); 
2428:  MOV     #2710,W0
242A:  CALL    484
.................... 			}//*****End of for loop************** 
242E:  INC     096E
2430:  BRA     1F2C
.................... 			ReportData(Device_Id,lamp_status,(current+100),(temp+100));//1,1.1,1.1); 
2432:  BCLR.B  43.0
2434:  MOV     972,W0
2436:  MOV     974,W1
2438:  MOV     #0,W2
243A:  MOV     #42C8,W3
243C:  CALL    1202
2440:  MOV     W0,W5
2442:  MOV     W1,W6
2444:  BCLR.B  43.0
2446:  MOV     97A,W0
2448:  MOV     97C,W1
244A:  MOV     #0,W2
244C:  MOV     #42C8,W3
244E:  CALL    1202
2452:  MOV     W0,W7
2454:  MOV     W1,W8
2456:  PUSH    96C
2458:  POP     9A8
245A:  PUSH    962
245C:  POP     9AA
245E:  MOV     W5,9AC
2460:  MOV     W6,9AE
2462:  MOV     W7,9B0
2464:  MOV     W8,9B2
2466:  CALL    1A6C
.................... 	}//*****End of while loop************** 
246A:  BRA     1F2A
.................... } 
246C:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C701   NOCKSFSM FRC_PLL4 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 0733   PUT64 NOBROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN NOMCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  
