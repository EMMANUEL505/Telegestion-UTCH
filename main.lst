CCS PCD C Compiler, Version 4.104, 5967               06-Aug-15 20:07

               Filename: C:\Users\e882742\Documents\TELEGESTION\dsPIC software\main.lst

               ROM used: 13346 bytes (30%)
                         Largest free fragment is 31710
               RAM used: 554 (27%) at main() level
                         586 (29%) worst case
               Stack:    7 locations

*
0000:  GOTO    2A6C
.................... /******************Configuration file********************/ 
.................... #include "Config.h" 
.................... #include <30f5015.h> 
.................... //////// Standard Header file for the DSPIC30F5015 device //////////////// 
.................... #device DSPIC30F5015 
.................... #list 
....................  
....................  
.................... #device ADC=10 
.................... #fuses FRC_PLL4, NOWRT, NOPROTECT, NOWDT, NOBROWNOUT, NOMCLR 
.................... #use delay(clock=29480000)  
*
0738:  CP0     W0
073A:  BTSC.B  42.1
073C:  BRA     746
073E:  REPEAT  #1CC3
0740:  NOP     
0742:  DEC     W0,W0
0744:  BRA     738
0746:  RETURN  
*
1F72:  LSR     W0,#0,W0
1F74:  CP0     W0
1F76:  BTSC.B  42.1
1F78:  BRA     1F82
1F7A:  REPEAT  #34
1F7C:  NOP     
1F7E:  DEC     W0,W0
1F80:  BRA     1F74
1F82:  RETURN  
.................... #use rs232(baud=115200,bits=8, xmit=PIN_F3,rcv=PIN_F2, parity=N)//, timeout=2000) 
.................... #byte OERR=0x020E 
.................... #USE FIXED_IO(B_OUTPUTS=PIN_B7,PIN_B8) 
....................  
.................... #define Timmer_Mode     1	//new mode  operation 
.................... #define Automated_Mode  3 
.................... #define Manual_Mode     2 
....................  
.................... #define Lamp_On         1 
.................... #define Lamp_Off        0 
....................  
.................... #define day_             0 
.................... #define month_           1 
.................... #define year_            2 
.................... #define hour_            3 
.................... #define min_             4 
.................... #define sec_             5 
....................  
.................... #define RoboCable			1 
.................... #define RoboEnergia			2 
.................... #define LamparaFundida		3 
....................  
.................... #define LCD_Delay			1000 
....................  
.................... #define TEMP_ch				0 
.................... #define CURRENT_ch			1 
.................... #define AN2_ch				2 
.................... #define SENSOR1_ch			3 
.................... #define SENSOR2_ch			4 
.................... #define POWER_ch			5 
.................... #define REFERENCE_ch		6 
....................  
.................... /******************Include files*************************/ 
.................... #include "DS1302_2.c"		//Driver for Real Time Clock  
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_D5 
.................... #define RTC_IO   PIN_D6 
.................... #define RTC_RST  PIN_D4 
....................  
.................... #endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
08E6:  CLR.B   9B9
08E8:  MOV     9B8,W4
08EA:  LSR     W4,#8,W4
08EC:  CP.B    W4L,#7
08EE:  BRA     GTU,90A
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
08F0:  BCLR.B  42.0
08F2:  RRC.B   9B8
08F4:  BRA     C,8FA
08F6:  BCLR.B  2D6.6
08F8:  BRA     8FC
08FA:  BSET.B  2D6.6
08FC:  BCLR.B  2D2.6
....................       output_high(RTC_SCLK); 
08FE:  BCLR.B  2D2.5
0900:  BSET.B  2D6.5
....................       output_low(RTC_SCLK); 
0902:  BCLR.B  2D2.5
0904:  BCLR.B  2D6.5
....................    } 
0906:  INC.B   09B9
0908:  BRA     8E8
.................... } 
090A:  RETURN  
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
090C:  BCLR.B  2D2.4
090E:  BSET.B  2D6.4
....................    write_ds1302_byte(cmd); 
0910:  MOV.B   9B4,W0L
0912:  MOV.B   W0L,9B8
0914:  CALL    8E6
....................    write_ds1302_byte(data); 
0918:  MOV.B   9B5,W0L
091A:  MOV.B   W0L,9B8
091C:  CALL    8E6
....................    output_low(RTC_RST); 
0920:  BCLR.B  2D2.4
0922:  BCLR.B  2D6.4
.................... } 
0924:  RETURN  
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
0926:  BCLR.B  2D2.4
0928:  BSET.B  2D6.4
....................    write_ds1302_byte(cmd); 
092A:  MOV.B   9AA,W0L
092C:  MOV.B   W0L,9B8
092E:  CALL    8E6
....................     
....................    input(RTC_IO); 
0932:  BSET.B  2D2.6
....................    delay_us(1); 
0934:  REPEAT  #5
0936:  NOP     
....................           
....................    for(i=0;i<=7;++i) { 
0938:  CLR.B   9AB
093A:  MOV     9AA,W4
093C:  LSR     W4,#8,W4
093E:  CP.B    W4L,#7
0940:  BRA     GTU,964
....................       shift_right(&data,1,input(RTC_IO)); 
0942:  BSET.B  2D2.6
0944:  BTSC.B  2D4.6
0946:  BRA     94C
0948:  BCLR.B  42.0
094A:  BRA     94E
094C:  BSET.B  42.0
094E:  RRC.B   9AC
....................       output_high(RTC_SCLK); 
0950:  BCLR.B  2D2.5
0952:  BSET.B  2D6.5
....................       delay_us(2); 
0954:  REPEAT  #C
0956:  NOP     
....................       output_low(RTC_SCLK); 
0958:  BCLR.B  2D2.5
095A:  BCLR.B  2D6.5
....................       delay_us(2); 
095C:  REPEAT  #C
095E:  NOP     
....................    } 
0960:  INC.B   09AB
0962:  BRA     93A
....................    output_low(RTC_RST); 
0964:  BCLR.B  2D2.4
0966:  BCLR.B  2D6.4
....................  
....................    return(data); 
0968:  MOV.B   9AC,W0L
096A:  MOV.B   W0L,0
.................... } 
096C:  RETURN  
....................  
.................... void rtc_init() { 
096E:  MOV     W5,[W15++]
....................    BYTE x; 
....................    output_low(RTC_RST); 
0970:  BCLR.B  2D2.4
0972:  BCLR.B  2D6.4
....................    delay_us(2); 
0974:  REPEAT  #C
0976:  NOP     
....................    output_low(RTC_SCLK); 
0978:  BCLR.B  2D2.5
097A:  BCLR.B  2D6.5
....................    write_ds1302(0x8e,0); 
097C:  MOV.B   #8E,W0L
097E:  MOV.B   W0L,9B4
0980:  CLR.B   9B5
0982:  CALL    90C
....................    write_ds1302(0x90,0xa4); 
0986:  MOV.B   #90,W0L
0988:  MOV.B   W0L,9B4
098A:  MOV.B   #A4,W0L
098C:  MOV.B   W0L,9B5
098E:  CALL    90C
....................    x=read_ds1302(0x81); 
0992:  MOV.B   #81,W0L
0994:  MOV.B   W0L,9AA
0996:  CALL    926
099A:  MOV.B   W0L,9A6
....................    if((x & 0x80)!=0) 
099C:  MOV.B   9A6,W0L
099E:  AND.B   #80,W0L
09A0:  CP0.B   W0L
09A2:  BRA     Z,9AE
....................      write_ds1302(0x80,0); 
09A4:  MOV.B   #80,W0L
09A6:  MOV.B   W0L,9B4
09A8:  CLR.B   9B5
09AA:  CALL    90C
.................... } 
09AE:  MOV     [--W15],W5
09B0:  RETURN  
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
*
1096:  MOV     W5,[W15++]
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
1098:  MOV     9B2,W4
109A:  CLR.B   9
109C:  MOV     #A,W3
109E:  REPEAT  #11
10A0:  DIV.U   W4,W3
10A2:  MOV.B   W0L,9B3
....................    nibl=data-(nibh*10); 
10A4:  MOV     9B2,W4
10A6:  LSR     W4,#8,W4
10A8:  MUL.UU  W4,#A,W0
10AA:  MOV     9B2,W4
10AC:  SUB.B   W4L,W0L,W0L
10AE:  MOV.B   W0L,9B4
....................  
....................    return((nibh<<4)|nibl); 
10B0:  MOV.B   9B3,W0L
10B2:  SL      W0,#4,W0
10B4:  IOR.B   9B4,W0L
.................... } 
10B6:  MOV     [--W15],W5
10B8:  RETURN  
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
*
1F4C:  MOV     W5,[W15++]
....................    byte i; 
....................  
....................    i=data; 
1F4E:  MOV.B   9AC,W0L
1F50:  MOV.B   W0L,9AD
....................    data=(i>>4)*10; 
1F52:  MOV.B   9AD,W0L
1F54:  CLR.B   1
1F56:  LSR     W0,#4,W0
1F58:  MOV.B   W0L,W4L
1F5A:  CLR.B   9
1F5C:  MUL.UU  W4,#A,W0
1F5E:  MOV.B   W0L,9AC
....................    data=data+(i<<4>>4); 
1F60:  MOV.B   9AD,W0L
1F62:  SL      W0,#4,W0
1F64:  CLR.B   1
1F66:  LSR     W0,#4,W0
1F68:  ADD.B   9AC
....................  
....................    return data; 
1F6A:  MOV.B   9AC,W0L
1F6C:  MOV.B   W0L,0
.................... } 
1F6E:  MOV     [--W15],W5
1F70:  RETURN  
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
*
10BA:  MOV     W5,[W15++]
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
10BC:  MOV.B   9A6,W0L
10BE:  MOV.B   W0L,9B2
10C0:  CALL    1096
10C4:  MOV.B   W0L,W5L
10C6:  MOV.B   #86,W0L
10C8:  MOV.B   W0L,9B4
10CA:  MOV.B   W5L,W0L
10CC:  MOV.B   W0L,9B5
10CE:  CALL    90C
....................    write_ds1302(0x88,get_bcd(mth)); 
10D2:  MOV.B   9A7,W0L
10D4:  MOV.B   W0L,9B2
10D6:  CALL    1096
10DA:  MOV.B   W0L,W5L
10DC:  MOV.B   #88,W0L
10DE:  MOV.B   W0L,9B4
10E0:  MOV.B   W5L,W0L
10E2:  MOV.B   W0L,9B5
10E4:  CALL    90C
....................    write_ds1302(0x8c,get_bcd(year)); 
10E8:  MOV.B   9A8,W0L
10EA:  MOV.B   W0L,9B2
10EC:  CALL    1096
10F0:  MOV.B   W0L,W5L
10F2:  MOV.B   #8C,W0L
10F4:  MOV.B   W0L,9B4
10F6:  MOV.B   W5L,W0L
10F8:  MOV.B   W0L,9B5
10FA:  CALL    90C
....................    write_ds1302(0x8a,get_bcd(dow)); 
10FE:  MOV.B   9A9,W0L
1100:  MOV.B   W0L,9B2
1102:  CALL    1096
1106:  MOV.B   W0L,W5L
1108:  MOV.B   #8A,W0L
110A:  MOV.B   W0L,9B4
110C:  MOV.B   W5L,W0L
110E:  MOV.B   W0L,9B5
1110:  CALL    90C
....................    write_ds1302(0x84,get_bcd(hr)); 
1114:  MOV.B   9AA,W0L
1116:  MOV.B   W0L,9B2
1118:  CALL    1096
111C:  MOV.B   W0L,W5L
111E:  MOV.B   #84,W0L
1120:  MOV.B   W0L,9B4
1122:  MOV.B   W5L,W0L
1124:  MOV.B   W0L,9B5
1126:  CALL    90C
....................    write_ds1302(0x82,get_bcd(min)); 
112A:  MOV.B   9AB,W0L
112C:  MOV.B   W0L,9B2
112E:  CALL    1096
1132:  MOV.B   W0L,W5L
1134:  MOV.B   #82,W0L
1136:  MOV.B   W0L,9B4
1138:  MOV.B   W5L,W0L
113A:  MOV.B   W0L,9B5
113C:  CALL    90C
....................    write_ds1302(0x80,get_bcd(0)); 
1140:  CLR.B   9B2
1142:  CALL    1096
1146:  MOV.B   W0L,W5L
1148:  MOV.B   #80,W0L
114A:  MOV.B   W0L,9B4
114C:  MOV.B   W5L,W0L
114E:  MOV.B   W0L,9B5
1150:  CALL    90C
.................... } 
1154:  MOV     [--W15],W5
1156:  RETURN  
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
2FB6:  MOV.B   #87,W0L
2FB8:  MOV.B   W0L,9AA
2FBA:  CALL    926
2FBE:  MOV.B   W0L,W5L
2FC0:  PUSH    9AC
2FC2:  MOV.B   W5L,[W15-#2]
2FC4:  POP     9AC
2FC6:  CALL    1F4C
2FCA:  MOV.B   W0L,992
....................    mth = rm_bcd(read_ds1302(0x89)); 
2FCC:  MOV.B   #89,W0L
2FCE:  MOV.B   W0L,9AA
2FD0:  CALL    926
2FD4:  MOV.B   W0L,W5L
2FD6:  PUSH    9AC
2FD8:  MOV.B   W5L,[W15-#2]
2FDA:  POP     9AC
2FDC:  CALL    1F4C
2FE0:  MOV.B   W0L,993
....................    year = rm_bcd(read_ds1302(0x8d)); 
2FE2:  MOV.B   #8D,W0L
2FE4:  MOV.B   W0L,9AA
2FE6:  CALL    926
2FEA:  MOV.B   W0L,W5L
2FEC:  PUSH    9AC
2FEE:  MOV.B   W5L,[W15-#2]
2FF0:  POP     9AC
2FF2:  CALL    1F4C
2FF6:  MOV.B   W0L,994
....................    dow = rm_bcd(read_ds1302(0x8b)); 
2FF8:  MOV.B   #8B,W0L
2FFA:  MOV.B   W0L,9AA
2FFC:  CALL    926
3000:  MOV.B   W0L,W5L
3002:  PUSH    9AC
3004:  MOV.B   W5L,[W15-#2]
3006:  POP     9AC
3008:  CALL    1F4C
300C:  MOV.B   W0L,998
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
300E:  MOV.B   #85,W0L
3010:  MOV.B   W0L,9AA
3012:  CALL    926
3016:  MOV.B   W0L,W5L
3018:  PUSH    9AC
301A:  MOV.B   W5L,[W15-#2]
301C:  POP     9AC
301E:  CALL    1F4C
3022:  MOV.B   W0L,995
....................    min = rm_bcd(read_ds1302(0x83)); 
3024:  MOV.B   #83,W0L
3026:  MOV.B   W0L,9AA
3028:  CALL    926
302C:  MOV.B   W0L,W5L
302E:  PUSH    9AC
3030:  MOV.B   W5L,[W15-#2]
3032:  POP     9AC
3034:  CALL    1F4C
3038:  MOV.B   W0L,996
....................    sec = rm_bcd(read_ds1302(0x81)); 
303A:  MOV.B   #81,W0L
303C:  MOV.B   W0L,9AA
303E:  CALL    926
3042:  MOV.B   W0L,W5L
3044:  PUSH    9AC
3046:  MOV.B   W5L,[W15-#2]
3048:  POP     9AC
304A:  CALL    1F4C
304E:  MOV.B   W0L,997
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... //#include "mcp4921_DSPIC.c" 
.................... #include "lcd_2.c"			//Driver for common LCD modules    
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
....................      #define LCD_ENABLE_PIN  PIN_B12                                   //// 
....................      #define LCD_RS_PIN      PIN_B10                                    ////     
....................      #define LCD_RW_PIN      PIN_B11                                    //// 
....................      #define LCD_DATA4       PIN_D0                                    //// 
....................      #define LCD_DATA5       PIN_D1                                    //// 
....................      #define LCD_DATA6       PIN_D2                                    //// 
....................      #define LCD_DATA7       PIN_D3  
....................  
....................  
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
*
07C6:  MOV     W5,[W15++]
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
07C8:  BSET.B  2D2.0
....................    output_float(LCD_DATA5); 
07CA:  BSET.B  2D2.1
....................    output_float(LCD_DATA6); 
07CC:  BSET.B  2D2.2
....................    output_float(LCD_DATA7); 
07CE:  BSET.B  2D2.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
07D0:  BSET.B  2CB.3
07D2:  MOV     #7E,W4
07D4:  MOV     W4,2C6
....................    delay_cycles(1); 
07D6:  NOP     
....................    lcd_output_enable(1); 
07D8:  BSET.B  2CB.4
07DA:  MOV     #7E,W4
07DC:  MOV     W4,2C6
....................    delay_cycles(1); 
07DE:  NOP     
....................    high = lcd_read_nibble(); 
07E0:  CALL    78C
07E4:  MOV.B   W0L,9C9
....................        
....................    lcd_output_enable(0); 
07E6:  BCLR.B  2CB.4
07E8:  MOV     #7E,W4
07EA:  MOV     W4,2C6
....................    delay_cycles(1); 
07EC:  NOP     
....................    lcd_output_enable(1); 
07EE:  BSET.B  2CB.4
07F0:  MOV     #7E,W4
07F2:  MOV     W4,2C6
....................    delay_us(1); 
07F4:  REPEAT  #5
07F6:  NOP     
....................    low = lcd_read_nibble(); 
07F8:  CALL    78C
07FC:  MOV.B   W0L,9C8
....................        
....................    lcd_output_enable(0); 
07FE:  BCLR.B  2CB.4
0800:  MOV     #7E,W4
0802:  MOV     W4,2C6
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
0804:  BCLR.B  2D2.0
....................    output_drive(LCD_DATA5); 
0806:  BCLR.B  2D2.1
....................    output_drive(LCD_DATA6); 
0808:  BCLR.B  2D2.2
....................    output_drive(LCD_DATA7); 
080A:  BCLR.B  2D2.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
080C:  MOV.B   9C9,W0L
080E:  SL      W0,#4,W0
0810:  IOR.B   9C8,W0L
.................... } 
0812:  MOV     [--W15],W5
0814:  RETURN  
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
078C:  MOV     W5,[W15++]
078E:  CLR.B   9CA
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0790:  BSET.B  2D2.0
0792:  CLR.B   W0
0794:  BTSC.B  2D4.0
0796:  INC     W0,W0
0798:  IOR.B   9CA
....................    n |= input(LCD_DATA5) << 1; 
079A:  BSET.B  2D2.1
079C:  CLR.B   W0
079E:  BTSC.B  2D4.1
07A0:  INC     W0,W0
07A2:  SL      W0,#1,W0
07A4:  IOR.B   9CA
....................    n |= input(LCD_DATA6) << 2; 
07A6:  BSET.B  2D2.2
07A8:  CLR.B   W0
07AA:  BTSC.B  2D4.2
07AC:  INC     W0,W0
07AE:  SL      W0,#2,W0
07B0:  IOR.B   9CA
....................    n |= input(LCD_DATA7) << 3; 
07B2:  BSET.B  2D2.3
07B4:  CLR.B   W0
07B6:  BTSC.B  2D4.3
07B8:  INC     W0,W0
07BA:  SL      W0,#3,W0
07BC:  IOR.B   9CA
....................     
....................    return(n); 
07BE:  MOV.B   9CA,W0L
07C0:  MOV.B   W0L,0
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
07C2:  MOV     [--W15],W5
07C4:  RETURN  
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
0748:  BTSC.B  9CA.0
074A:  BRA     750
074C:  BCLR.B  2D6.0
074E:  BRA     752
0750:  BSET.B  2D6.0
0752:  BCLR.B  2D2.0
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0754:  BTSC.B  9CA.1
0756:  BRA     75C
0758:  BCLR.B  2D6.1
075A:  BRA     75E
075C:  BSET.B  2D6.1
075E:  BCLR.B  2D2.1
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0760:  BTSC.B  9CA.2
0762:  BRA     768
0764:  BCLR.B  2D6.2
0766:  BRA     76A
0768:  BSET.B  2D6.2
076A:  BCLR.B  2D2.2
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
076C:  BTSC.B  9CA.3
076E:  BRA     774
0770:  BCLR.B  2D6.3
0772:  BRA     776
0774:  BSET.B  2D6.3
0776:  BCLR.B  2D2.3
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
0778:  NOP     
....................    lcd_output_enable(1); 
077A:  BSET.B  2CB.4
077C:  MOV     #7E,W4
077E:  MOV     W4,2C6
....................    delay_us(2); 
0780:  REPEAT  #C
0782:  NOP     
....................    lcd_output_enable(0); 
0784:  BCLR.B  2CB.4
0786:  MOV     #7E,W4
0788:  MOV     W4,2C6
.................... } 
078A:  RETURN  
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
*
0816:  MOV     W5,[W15++]
....................    lcd_output_rs(0); 
0818:  BCLR.B  2CB.2
081A:  MOV     #7E,W4
081C:  MOV     W4,2C6
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
081E:  CALL    7C6
0822:  MOV.B   W0L,W5L
0824:  BTSC    W5.7
0826:  BRA     81E
....................    lcd_output_rs(address); 
0828:  CP0.B   9C4
082A:  BRA     NZ,830
082C:  BCLR.B  2CB.2
082E:  BRA     832
0830:  BSET.B  2CB.2
0832:  MOV     #7E,W4
0834:  MOV     W4,2C6
....................    delay_cycles(1); 
0836:  NOP     
....................    lcd_output_rw(0); 
0838:  BCLR.B  2CB.3
083A:  MOV     #7E,W4
083C:  MOV     W4,2C6
....................    delay_cycles(1); 
083E:  NOP     
....................    lcd_output_enable(0); 
0840:  BCLR.B  2CB.4
0842:  MOV     #7E,W4
0844:  MOV     W4,2C6
....................    lcd_send_nibble(n >> 4); 
0846:  MOV     9C4,W5
0848:  LSR     W5,#8,W5
084A:  CLR.B   B
084C:  LSR     W5,#4,W5
084E:  PUSH    9CA
0850:  MOV.B   W5L,[W15-#2]
0852:  POP     9CA
0854:  CALL    748
....................    lcd_send_nibble(n & 0xf); 
0858:  MOV.B   9C5,W0L
085A:  AND.B   W0L,#F,W5L
085C:  PUSH    9CA
085E:  MOV.B   W5L,[W15-#2]
0860:  POP     9CA
0862:  CALL    748
.................... } 
0866:  MOV     [--W15],W5
0868:  RETURN  
....................  
.................... void lcd_init(void)  
.................... { 
086A:  MOV     W5,[W15++]
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
086C:  BCLR.B  2D2.0
....................    output_drive(LCD_DATA5); 
086E:  BCLR.B  2D2.1
....................    output_drive(LCD_DATA6); 
0870:  BCLR.B  2D2.2
....................    output_drive(LCD_DATA7); 
0872:  BCLR.B  2D2.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0874:  MOV     #7E,W4
0876:  MOV     W4,2C6
....................    lcd_rs_tris(); 
0878:  MOV     #7E,W4
087A:  MOV     W4,2C6
....................    lcd_rw_tris(); 
087C:  MOV     #7E,W4
087E:  MOV     W4,2C6
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0880:  BCLR.B  2CB.2
0882:  MOV     #7E,W4
0884:  MOV     W4,2C6
....................    lcd_output_rw(0); 
0886:  BCLR.B  2CB.3
0888:  MOV     #7E,W4
088A:  MOV     W4,2C6
....................    lcd_output_enable(0); 
088C:  BCLR.B  2CB.4
088E:  MOV     #7E,W4
0890:  MOV     W4,2C6
....................      
....................    delay_ms(15); 
0892:  MOV     #F,W0
0894:  CALL    738
....................    for(i=1;i<=3;++i) 
0898:  MOV.B   #1,W0L
089A:  MOV.B   W0L,9A6
089C:  MOV     9A6,W4
089E:  CP.B    W4L,#3
08A0:  BRA     GTU,8BA
....................    { 
....................        lcd_send_nibble(3); 
08A2:  MOV.B   #3,W0L
08A4:  MOV.B   W0L,9CA
08A6:  CALL    748
....................        delay_ms(5); 
08AA:  REPEAT  #FF0
08AC:  NOP     
08AE:  REPEAT  #3FFF
08B0:  NOP     
08B2:  REPEAT  #3FFF
08B4:  NOP     
....................    } 
08B6:  INC.B   09A6
08B8:  BRA     89C
....................      
....................    lcd_send_nibble(2); 
08BA:  MOV.B   #2,W0L
08BC:  MOV.B   W0L,9CA
08BE:  CALL    748
....................    for(i=0;i<=3;++i) 
08C2:  CLR.B   9A6
08C4:  MOV     9A6,W4
08C6:  CP.B    W4L,#3
08C8:  BRA     GTU,8E2
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
08CA:  MOV.B   9A6,W0L
08CC:  CLR.B   1
08CE:  CALL    100
08D2:  MOV.B   W0L,W5L
08D4:  CLR.B   9C4
08D6:  MOV.B   W5L,W0L
08D8:  MOV.B   W0L,9C5
08DA:  CALL    816
08DE:  INC.B   09A6
08E0:  BRA     8C4
.................... } 
08E2:  MOV     [--W15],W5
08E4:  RETURN  
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
*
09B2:  MOV     W5,[W15++]
....................    BYTE address; 
....................  
....................    if(y!=1) 
09B4:  MOV     9BE,W4
09B6:  LSR     W4,#8,W4
09B8:  CP.B    W4L,#1
09BA:  BRA     Z,9C2
....................       address=LCD_LINE_TWO; 
09BC:  MOV.B   #40,W0L
09BE:  MOV.B   W0L,9C0
....................    else 
09C0:  BRA     9C4
....................       address=0; 
09C2:  CLR.B   9C0
....................       
....................    address+=x-1; 
09C4:  MOV     9BE,W4
09C6:  SUB.B   W4L,#1,W0L
09C8:  ADD.B   9C0
....................    lcd_send_byte(0,0x80|address); 
09CA:  MOV     9C0,W5
09CC:  IOR.B   #80,W5L
09CE:  CLR.B   9C4
09D0:  MOV.B   W5L,W0L
09D2:  MOV.B   W0L,9C5
09D4:  CALL    816
.................... } 
09D8:  MOV     [--W15],W5
09DA:  RETURN  
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
09DC:  MOV.B   9BC,W0L
09DE:  CLR.B   1
09E0:  XOR     #C,W0
09E2:  BRA     Z,9EE
09E4:  XOR     #6,W0
09E6:  BRA     Z,9FE
09E8:  XOR     #2,W0
09EA:  BRA     Z,A0C
09EC:  BRA     A18
....................       case '\f'   :  lcd_send_byte(0,1); 
09EE:  CLR.B   9C4
09F0:  MOV.B   #1,W0L
09F2:  MOV.B   W0L,9C5
09F4:  CALL    816
....................                      delay_ms(2); 
09F8:  REPEAT  #3992
09FA:  NOP     
....................                      break; 
09FC:  BRA     A26
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
09FE:  MOV.B   #1,W0L
0A00:  MOV.B   W0L,9BE
0A02:  MOV.B   #2,W0L
0A04:  MOV.B   W0L,9BF
0A06:  CALL    9B2
0A0A:  BRA     A26
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
0A0C:  CLR.B   9C4
0A0E:  MOV.B   #10,W0L
0A10:  MOV.B   W0L,9C5
0A12:  CALL    816
0A16:  BRA     A26
....................       
....................       default     : lcd_send_byte(1,c);     break; 
0A18:  MOV.B   #1,W0L
0A1A:  MOV.B   W0L,9C4
0A1C:  MOV.B   9BC,W0L
0A1E:  MOV.B   W0L,9C5
0A20:  CALL    816
0A24:  BRA     A26
....................    } 
.................... } 
0A26:  RETURN  
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... #include "ADH8066.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             ADH8066.C                                 //// 
.................... ////                 Driver for ADH8066 GPRS modules                       //// 
.................... ////                                                                       //// 
.................... ////  StringToHex(Str,size,result)                                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2014  Adolfo Emmanuel Sigala Villa           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************Global definitions********************/ 
.................... //#define AT "AT+" 
.................... //#define CPIN "CPIN?\r\n" 
.................... //#define AIPDCONT "AIPDCONT=\"INTERNET.MOVISTAR.MX\",\"MOVISTAR\",\"MOVISTAR\"\r\n" 
.................... //#define AIPO "AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n" 
.................... //#define HOST "HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n" 
....................  
.................... #define Buzzer_delay	200 
.................... #define Buzzer_On		1 
.................... #define Buzzer_Off      0 
.................... extern float current,battery,temp,s1,s2,reference; 
.................... /******************Variable and constant definitions*****/ 
.................... const char hexcode[17]="0123456789abcdef"; 
....................  
.................... char InputBuffer[350]={0}; 
*
2ABE:  CLR     818
2AC0:  CLR     81A
2AC2:  CLR     81C
2AC4:  CLR     81E
2AC6:  CLR     820
2AC8:  CLR     822
2ACA:  CLR     824
2ACC:  CLR     826
2ACE:  CLR     828
2AD0:  CLR     82A
2AD2:  CLR     82C
2AD4:  CLR     82E
2AD6:  CLR     830
2AD8:  CLR     832
2ADA:  CLR     834
2ADC:  CLR     836
2ADE:  CLR     838
2AE0:  CLR     83A
2AE2:  CLR     83C
2AE4:  CLR     83E
2AE6:  CLR     840
2AE8:  CLR     842
2AEA:  CLR     844
2AEC:  CLR     846
2AEE:  CLR     848
2AF0:  CLR     84A
2AF2:  CLR     84C
2AF4:  CLR     84E
2AF6:  CLR     850
2AF8:  CLR     852
2AFA:  CLR     854
2AFC:  CLR     856
2AFE:  CLR     858
2B00:  CLR     85A
2B02:  CLR     85C
2B04:  CLR     85E
2B06:  CLR     860
2B08:  CLR     862
2B0A:  CLR     864
2B0C:  CLR     866
2B0E:  CLR     868
2B10:  CLR     86A
2B12:  CLR     86C
2B14:  CLR     86E
2B16:  CLR     870
2B18:  CLR     872
2B1A:  CLR     874
2B1C:  CLR     876
2B1E:  CLR     878
2B20:  CLR     87A
2B22:  CLR     87C
2B24:  CLR     87E
2B26:  CLR     880
2B28:  CLR     882
2B2A:  CLR     884
2B2C:  CLR     886
2B2E:  CLR     888
2B30:  CLR     88A
2B32:  CLR     88C
2B34:  CLR     88E
2B36:  CLR     890
2B38:  CLR     892
2B3A:  CLR     894
2B3C:  CLR     896
2B3E:  CLR     898
2B40:  CLR     89A
2B42:  CLR     89C
2B44:  CLR     89E
2B46:  CLR     8A0
2B48:  CLR     8A2
2B4A:  CLR     8A4
2B4C:  CLR     8A6
2B4E:  CLR     8A8
2B50:  CLR     8AA
2B52:  CLR     8AC
2B54:  CLR     8AE
2B56:  CLR     8B0
2B58:  CLR     8B2
2B5A:  CLR     8B4
2B5C:  CLR     8B6
2B5E:  CLR     8B8
2B60:  CLR     8BA
2B62:  CLR     8BC
2B64:  CLR     8BE
2B66:  CLR     8C0
2B68:  CLR     8C2
2B6A:  CLR     8C4
2B6C:  CLR     8C6
2B6E:  CLR     8C8
2B70:  CLR     8CA
2B72:  CLR     8CC
2B74:  CLR     8CE
2B76:  CLR     8D0
2B78:  CLR     8D2
2B7A:  CLR     8D4
2B7C:  CLR     8D6
2B7E:  CLR     8D8
2B80:  CLR     8DA
2B82:  CLR     8DC
2B84:  CLR     8DE
2B86:  CLR     8E0
2B88:  CLR     8E2
2B8A:  CLR     8E4
2B8C:  CLR     8E6
2B8E:  CLR     8E8
2B90:  CLR     8EA
2B92:  CLR     8EC
2B94:  CLR     8EE
2B96:  CLR     8F0
2B98:  CLR     8F2
2B9A:  CLR     8F4
2B9C:  CLR     8F6
2B9E:  CLR     8F8
2BA0:  CLR     8FA
2BA2:  CLR     8FC
2BA4:  CLR     8FE
2BA6:  CLR     900
2BA8:  CLR     902
2BAA:  CLR     904
2BAC:  CLR     906
2BAE:  CLR     908
2BB0:  CLR     90A
2BB2:  CLR     90C
2BB4:  CLR     90E
2BB6:  CLR     910
2BB8:  CLR     912
2BBA:  CLR     914
2BBC:  CLR     916
2BBE:  CLR     918
2BC0:  CLR     91A
2BC2:  CLR     91C
2BC4:  CLR     91E
2BC6:  CLR     920
2BC8:  CLR     922
2BCA:  CLR     924
2BCC:  CLR     926
2BCE:  CLR     928
2BD0:  CLR     92A
2BD2:  CLR     92C
2BD4:  CLR     92E
2BD6:  CLR     930
2BD8:  CLR     932
2BDA:  CLR     934
2BDC:  CLR     936
2BDE:  CLR     938
2BE0:  CLR     93A
2BE2:  CLR     93C
2BE4:  CLR     93E
2BE6:  CLR     940
2BE8:  CLR     942
2BEA:  CLR     944
2BEC:  CLR     946
2BEE:  CLR     948
2BF0:  CLR     94A
2BF2:  CLR     94C
2BF4:  CLR     94E
2BF6:  CLR     950
2BF8:  CLR     952
2BFA:  CLR     954
2BFC:  CLR     956
2BFE:  CLR     958
2C00:  CLR     95A
2C02:  CLR     95C
2C04:  CLR     95E
2C06:  CLR     960
2C08:  CLR     962
2C0A:  CLR     964
2C0C:  CLR     966
2C0E:  CLR     968
2C10:  CLR     96A
2C12:  CLR     96C
2C14:  CLR     96E
2C16:  CLR     970
2C18:  CLR     972
2C1A:  CLR     974
.................... int16 ptime=100; 
....................  
.................... /***********StringToHex*********************************** 
.................... **   Description: This function converts a string in    ** 
.................... **     their hex codification                           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void StringToHex(char* str,unsigned int size,char* result) 
.................... { 
.................... 	int index=0,aux=0,aux2=0; 
.................... 	for(index=0;index<size;index++) 
.................... 		{ 
.................... 			aux=*(str+index); 
.................... 			aux2=aux/16; 
.................... 			*(result+(index*2))=hexcode[aux2]; 
.................... 			if(aux>15) 
.................... 				{ 
.................... 					aux=aux-(aux2*16); 
.................... 				} 
.................... 			*(result+((index*2)+1))=hexcode[aux];	 
.................... 		} 
.................... } 
....................  
.................... /***********FillArray************************************* 
.................... **   Description: Function used to fill an array with   ** 
.................... **     value of (val) variable                          ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void FillArray(char* arrayval,int size,char val) 
.................... { 
*
0A28:  MOV     W5,[W15++]
0A2A:  CLR     9C4
.................... 	int index=0; 
.................... 	for(index=0;index<size;index++) 
0A2C:  CLR     9C4
0A2E:  MOV     9C4,W0
0A30:  MOV     9C0,W4
0A32:  CP      W4,W0
0A34:  BRA     LE,A44
.................... 	{ 
.................... 		*(arrayval+index)=val; 
0A36:  MOV     9BE,W0
0A38:  ADD     9C4,W0
0A3A:  MOV     W0,W5
0A3C:  MOV.B   9C2,W0L
0A3E:  MOV.B   W0L,[W5+#0]
.................... 	} 
0A40:  INC     09C4
0A42:  BRA     A2E
.................... } 
0A44:  MOV     [--W15],W5
0A46:  RETURN  
....................  
.................... /***********ReadBuffer************************************ 
.................... **   Description: Reads incoming characters until arrive** 
.................... **     a carriage return '\r' and save the buffer in    ** 
.................... **       *buffer array                                  ** 
.................... *********************************************************/ 
.................... void ReadBuffer(char* buffer) 
.................... { 
0A48:  MOV     W5,[W15++]
0A4A:  CLR     9C0
.................... 	int16 index=0; 
.................... 	OERR=16; 
0A4C:  MOV.B   #10,W0L
0A4E:  MOV.B   W0L,20E
.................... 	//******Get incoming buffer data****** 
.................... 	while(getc()!='\n'); 
0A50:  BTSS.B  20E.0
0A52:  BRA     A50
0A54:  MOV     212,W0
0A56:  CP.B    W0L,#A
0A58:  BRA     NZ,A50
....................     do 
....................     { 
....................        *(buffer+index)=getc();	 
0A5A:  MOV     9BE,W0
0A5C:  ADD     9C0,W0
0A5E:  MOV     W0,W5
0A60:  BTSS.B  20E.0
0A62:  BRA     A60
0A64:  MOV     212,W0
0A66:  MOV.B   W0L,[W5]
.................... 		index++; 
0A68:  INC     09C0
....................     }while(index<350 && *(buffer+index-1)!='\r'); 
0A6A:  MOV     9C0,W4
0A6C:  MOV     #15E,W3
0A6E:  CP      W3,W4
0A70:  BRA     LE,A80
0A72:  MOV     9BE,W0
0A74:  ADD     9C0,W0
0A76:  MOV     W0,W5
0A78:  SUB     W5,#1,W0
0A7A:  MOV.B   [W0],W4L
0A7C:  CP.B    W4L,#D
0A7E:  BRA     NZ,A5A
....................  
.................... 	//***Buzzer sound when receive******** 
....................     //output_bit(PIN_D9,Buzzer_On); 
.................... 	delay_ms(Buzzer_delay); 
0A80:  MOV     #C8,W0
0A82:  CALL    738
.................... 	//output_bit(PIN_D9,Buzzer_Off); 
.................... 	OERR=16; 
0A86:  MOV.B   #10,W0L
0A88:  MOV.B   W0L,20E
....................  
.................... } 
0A8A:  MOV     [--W15],W5
0A8C:  RETURN  
....................  
.................... /***********PrintBuffer*********************************** 
.................... **   Description: Prints in LCD the specified buffer    ** 
.................... **     of characters with a permanency of ms            ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void PrintBuffer(char* buffer,int16 permanency) 
.................... { 
0A8E:  MOV     W5,[W15++]
.................... 	lcd_putc("\f"); 
0A90:  MOV     #0,W5
0A92:  MOV     W5,W0
0A94:  CALL    110
0A98:  IOR.B   #0,W0L
0A9A:  BTSC.B  42.1
0A9C:  BRA     AA8
0A9E:  INC     W5,W5
0AA0:  MOV.B   W0L,9BC
0AA2:  CALL    9DC
0AA6:  BRA     A92
....................     printf(lcd_putc,"%s",buffer); 
0AA8:  MOV     9B0,W1
0AAA:  CP0.B   [W1]
0AAC:  BRA     Z,ABE
0AAE:  MOV     W1,[W15++]
0AB0:  MOV.B   [W1+#0],W0L
0AB2:  MOV.B   W0L,9BC
0AB4:  CALL    9DC
0AB8:  MOV     [--W15],W1
0ABA:  INC     W1,W1
0ABC:  BRA     AAA
.................... 	delay_ms(permanency); 
0ABE:  MOV     9B2,W0
0AC0:  CALL    738
.................... } 
0AC4:  MOV     [--W15],W5
0AC6:  RETURN  
....................  
.................... /***********ValidateCommand******************************* 
.................... **   Description: Validate that input string does not   ** 
.................... **     contains an ERROR                                ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int ValidateCommand(char* cmdstr,int size) 
.................... { 
0AC8:  MOV     W5,[W15++]
0ACA:  CLR     9BE
0ACC:  MOV     #1,W4
0ACE:  MOV     W4,9C0
.................... 	int index=0,result=1; 
.................... 	for(index=0;index<size;index++) 
0AD0:  CLR     9BE
0AD2:  MOV     9BE,W0
0AD4:  MOV     9BC,W4
0AD6:  CP      W4,W0
0AD8:  BRA     LE,AFA
.................... 	{ 
.................... 		if(*(cmdstr+index)=='E' && *(cmdstr+(index+1))=='R')  
0ADA:  MOV     9BA,W0
0ADC:  ADD     9BE,W0
0ADE:  MOV.B   [W0],W4L
0AE0:  XOR.B   #45,W4L
0AE2:  BRA     NZ,AF6
0AE4:  MOV     9BE,W4
0AE6:  ADD     W4,#1,W4
0AE8:  MOV     W4,W0
0AEA:  MOV     9BA,W4
0AEC:  ADD     W0,W4,W0
0AEE:  MOV.B   [W0],W4L
0AF0:  XOR.B   #52,W4L
0AF2:  BRA     NZ,AF6
.................... 		{ 
.................... 			result=0; 
0AF4:  CLR     9C0
.................... 		} 
.................... 	} 
0AF6:  INC     09BE
0AF8:  BRA     AD2
....................     return result; 
0AFA:  PUSH    9C0
0AFC:  POP     0
.................... } 
0AFE:  MOV     [--W15],W5
0B00:  RETURN  
....................  
.................... /***********GetDecVal************************************* 
.................... **   Description: Function used to find a decimal value ** 
.................... **     into string                                      ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int GetDecVal(char* arrayval,int16 size,char stch1,char stch2) 
.................... { 
*
0E4E:  MOV     W5,[W15++]
0E50:  CLR     9C4
0E52:  SETM    9C6
.................... 	int16 ind=0; 
....................     int16  value=-1; 
.................... 	while(ind<size && *(arrayval+ind)!='$')// && value==-1) 
.................... 	{ 
0E54:  MOV     9C4,W0
0E56:  MOV     9C0,W4
0E58:  CP      W4,W0
0E5A:  BRA     LE,EBC
0E5C:  MOV     9BE,W0
0E5E:  ADD     9C4,W0
0E60:  MOV.B   [W0],W4L
0E62:  XOR.B   #24,W4L
0E64:  BRA     Z,EBC
.................... 		if(*(arrayval+ind)==stch1 && *(arrayval+(ind+1))==stch2) 
0E66:  MOV     9BE,W0
0E68:  ADD     9C4,W0
0E6A:  MOV.B   [W0],W0L
0E6C:  CP.B    9C2
0E6E:  BRA     NZ,EB8
0E70:  MOV     9C4,W4
0E72:  ADD     W4,#1,W4
0E74:  MOV     W4,W0
0E76:  MOV     9BE,W4
0E78:  ADD     W0,W4,W0
0E7A:  MOV.B   [W0],W0L
0E7C:  CP.B    9C3
0E7E:  BRA     NZ,EB8
.................... 			{ 
.................... 				ind+=2; 
0E80:  MOV     9C4,W4
0E82:  ADD     W4,#2,W4
0E84:  MOV     W4,9C4
.................... 				value=0; 
0E86:  CLR     9C6
.................... 				while(*(arrayval+ind)>47 && *(arrayval+ind)<58) 
.................... 					{ 
0E88:  MOV     9BE,W0
0E8A:  ADD     9C4,W0
0E8C:  MOV     #2F,W4
0E8E:  CP.B    W4L,[W0]
0E90:  BRA     C,EB8
0E92:  MOV     9BE,W0
0E94:  ADD     9C4,W0
0E96:  MOV.B   [W0],W4L
0E98:  MOV     #3A,W3
0E9A:  CP.B    W3L,W4L
0E9C:  BRA     LEU,EB8
.................... 						value*=10; 
0E9E:  MOV     9C6,W4
0EA0:  MUL.UU  W4,#A,W0
0EA2:  MOV     W0,9C6
.................... 						value+=(*(arrayval+ind)-48); 
0EA4:  MOV     9BE,W0
0EA6:  ADD     9C4,W0
0EA8:  MOV.B   [W0],W4L
0EAA:  SUB.B   #30,W4L
0EAC:  MOV.B   W4L,W0L
0EAE:  MOV.B   W0L,0
0EB0:  ZE      W0,W0
0EB2:  ADD     9C6
.................... 						ind++; 
0EB4:  INC     09C4
.................... 					} 
0EB6:  BRA     E88
.................... 			} 
.................... 		ind++; 
0EB8:  INC     09C4
.................... 	} 
0EBA:  BRA     E54
.................... 	return value; 
0EBC:  PUSH    9C6
0EBE:  POP     0
.................... } 
0EC0:  MOV     [--W15],W5
0EC2:  RETURN  
....................  
.................... /***********ConfigureGPRS********************************* 
.................... **   Description: Function used to configure the GPRS   ** 
.................... **     module to conect it to internet                  ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ConfigureGPRS() 
.................... { 
*
0B02:  MOV     W5,[W15++]
0B04:  CLR     9A6
0B06:  CLR     9A8
.................... 	int status=0,count=0; 
.................... 	while(status==0 && count<5) 
.................... 		{ 
0B08:  CP0     9A6
0B0A:  BRA     NZ,D50
0B0C:  MOV     9A8,W4
0B0E:  CP      W4,#5
0B10:  BRA     GE,D50
.................... 			FillArray(InputBuffer,350,0);  //Clear input_buffer 
0B12:  CLR.B   9C2
0B14:  MOV     #818,W4
0B16:  MOV     W4,9BE
0B18:  MOV     #15E,W4
0B1A:  MOV     W4,9C0
0B1C:  CALL    A28
.................... 			printf("AT+CPIN?\r\n");         //Verify chip 
0B20:  MOV     #0,W1
0B22:  MOV     W1,W0
0B24:  CALL    11E
0B28:  INC     W1,W1
0B2A:  MOV     W1,[W15++]
0B2C:  BTSC.B  20F.1
0B2E:  BRA     B2C
0B30:  MOV     W0,210
0B32:  MOV     [--W15],W1
0B34:  MOV     #9,W0
0B36:  CPSGT   W1,W0
0B38:  BRA     B22
.................... 			ReadBuffer(InputBuffer); 
0B3A:  MOV     #818,W4
0B3C:  MOV     W4,9BE
0B3E:  CALL    A48
.................... 			PrintBuffer(InputBuffer,100); 
0B42:  MOV     #64,W4
0B44:  MOV     W4,9B2
0B46:  MOV     #818,W4
0B48:  MOV     W4,9B0
0B4A:  CALL    A8E
.................... 			status=ValidateCommand(InputBuffer,30); 
0B4E:  MOV     #1E,W4
0B50:  MOV     W4,9BC
0B52:  MOV     #818,W4
0B54:  MOV     W4,9BA
0B56:  CALL    AC8
0B5A:  MOV     W0,9A6
.................... 			if(status==1) lcd_putc("\fCMD OK"); 
0B5C:  MOV     9A6,W4
0B5E:  CP      W4,#1
0B60:  BRA     NZ,B7C
0B62:  MOV     #0,W5
0B64:  MOV     W5,W0
0B66:  CALL    136
0B6A:  IOR.B   #0,W0L
0B6C:  BTSC.B  42.1
0B6E:  BRA     B7A
0B70:  INC     W5,W5
0B72:  MOV.B   W0L,9BC
0B74:  CALL    9DC
0B78:  BRA     B64
.................... 			else  
0B7A:  BRA     B96
.................... 				{	 
.................... 					lcd_putc("\fCMD BAD"); 
0B7C:  MOV     #0,W5
0B7E:  MOV     W5,W0
0B80:  CALL    14A
0B84:  IOR.B   #0,W0L
0B86:  BTSC.B  42.1
0B88:  BRA     B94
0B8A:  INC     W5,W5
0B8C:  MOV.B   W0L,9BC
0B8E:  CALL    9DC
0B92:  BRA     B7E
.................... 					status=0; 
0B94:  CLR     9A6
.................... 				} 
.................... 			delay_ms(100); 
0B96:  MOV     #64,W0
0B98:  CALL    738
.................... 			if(status==1) 
0B9C:  MOV     9A6,W4
0B9E:  CP      W4,#1
0BA0:  BRA     NZ,C2C
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0BA2:  CLR.B   9C2
0BA4:  MOV     #818,W4
0BA6:  MOV     W4,9BE
0BA8:  MOV     #15E,W4
0BAA:  MOV     W4,9C0
0BAC:  CALL    A28
.................... 					printf("AT+AIPDCONT=\"internet.movistar.mx\",\"movistar\",\"movistar\"\r\n");  //Configure internet 
0BB0:  MOV     #0,W1
0BB2:  MOV     W1,W0
0BB4:  CALL    160
0BB8:  INC     W1,W1
0BBA:  MOV     W1,[W15++]
0BBC:  BTSC.B  20F.1
0BBE:  BRA     BBC
0BC0:  MOV     W0,210
0BC2:  MOV     [--W15],W1
0BC4:  MOV     #39,W0
0BC6:  CPSGT   W1,W0
0BC8:  BRA     BB2
.................... 					ReadBuffer(InputBuffer); 
0BCA:  MOV     #818,W4
0BCC:  MOV     W4,9BE
0BCE:  CALL    A48
.................... 					PrintBuffer(InputBuffer,1000); 
0BD2:  MOV     #818,W4
0BD4:  MOV     W4,9B0
0BD6:  MOV     #3E8,W4
0BD8:  MOV     W4,9B2
0BDA:  CALL    A8E
.................... 					status=ValidateCommand(InputBuffer,30); 
0BDE:  MOV     #1E,W4
0BE0:  MOV     W4,9BC
0BE2:  MOV     #818,W4
0BE4:  MOV     W4,9BA
0BE6:  CALL    AC8
0BEA:  MOV     W0,9A6
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0BEC:  MOV     9A6,W4
0BEE:  CP      W4,#1
0BF0:  BRA     NZ,C0C
0BF2:  MOV     #0,W5
0BF4:  MOV     W5,W0
0BF6:  CALL    136
0BFA:  IOR.B   #0,W0L
0BFC:  BTSC.B  42.1
0BFE:  BRA     C0A
0C00:  INC     W5,W5
0C02:  MOV.B   W0L,9BC
0C04:  CALL    9DC
0C08:  BRA     BF4
.................... 					else  
0C0A:  BRA     C26
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0C0C:  MOV     #0,W5
0C0E:  MOV     W5,W0
0C10:  CALL    14A
0C14:  IOR.B   #0,W0L
0C16:  BTSC.B  42.1
0C18:  BRA     C24
0C1A:  INC     W5,W5
0C1C:  MOV.B   W0L,9BC
0C1E:  CALL    9DC
0C22:  BRA     C0E
.................... 							status=0; 
0C24:  CLR     9A6
.................... 						} 
.................... 					delay_ms(600); 
0C26:  MOV     #258,W0
0C28:  CALL    738
.................... 				}		 
.................... 			if(status==1) 
0C2C:  MOV     9A6,W4
0C2E:  CP      W4,#1
0C30:  BRA     NZ,CBC
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0C32:  CLR.B   9C2
0C34:  MOV     #818,W4
0C36:  MOV     W4,9BE
0C38:  MOV     #15E,W4
0C3A:  MOV     W4,9C0
0C3C:  CALL    A28
.................... 					printf("AT+AIPA=1\r\n");        //Conect to internet 
0C40:  MOV     #0,W1
0C42:  MOV     W1,W0
0C44:  CALL    1A4
0C48:  INC     W1,W1
0C4A:  MOV     W1,[W15++]
0C4C:  BTSC.B  20F.1
0C4E:  BRA     C4C
0C50:  MOV     W0,210
0C52:  MOV     [--W15],W1
0C54:  MOV     #A,W0
0C56:  CPSGT   W1,W0
0C58:  BRA     C42
.................... 					ReadBuffer(InputBuffer); 
0C5A:  MOV     #818,W4
0C5C:  MOV     W4,9BE
0C5E:  CALL    A48
.................... 					PrintBuffer(InputBuffer,1000); 
0C62:  MOV     #818,W4
0C64:  MOV     W4,9B0
0C66:  MOV     #3E8,W4
0C68:  MOV     W4,9B2
0C6A:  CALL    A8E
.................... 					status=ValidateCommand(InputBuffer,30); 
0C6E:  MOV     #1E,W4
0C70:  MOV     W4,9BC
0C72:  MOV     #818,W4
0C74:  MOV     W4,9BA
0C76:  CALL    AC8
0C7A:  MOV     W0,9A6
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0C7C:  MOV     9A6,W4
0C7E:  CP      W4,#1
0C80:  BRA     NZ,C9C
0C82:  MOV     #0,W5
0C84:  MOV     W5,W0
0C86:  CALL    136
0C8A:  IOR.B   #0,W0L
0C8C:  BTSC.B  42.1
0C8E:  BRA     C9A
0C90:  INC     W5,W5
0C92:  MOV.B   W0L,9BC
0C94:  CALL    9DC
0C98:  BRA     C84
.................... 					else  
0C9A:  BRA     CB6
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0C9C:  MOV     #0,W5
0C9E:  MOV     W5,W0
0CA0:  CALL    14A
0CA4:  IOR.B   #0,W0L
0CA6:  BTSC.B  42.1
0CA8:  BRA     CB4
0CAA:  INC     W5,W5
0CAC:  MOV.B   W0L,9BC
0CAE:  CALL    9DC
0CB2:  BRA     C9E
.................... 							status=0; 
0CB4:  CLR     9A6
.................... 						} 
.................... 					delay_ms(500); 
0CB6:  MOV     #1F4,W0
0CB8:  CALL    738
.................... 				} 
.................... 			if(status==1) 
0CBC:  MOV     9A6,W4
0CBE:  CP      W4,#1
0CC0:  BRA     NZ,D4C
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0CC2:  CLR.B   9C2
0CC4:  MOV     #818,W4
0CC6:  MOV     W4,9BE
0CC8:  MOV     #15E,W4
0CCA:  MOV     W4,9C0
0CCC:  CALL    A28
.................... 					printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server"AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n" 
0CD0:  MOV     #0,W1
0CD2:  MOV     W1,W0
0CD4:  CALL    1BC
0CD8:  INC     W1,W1
0CDA:  MOV     W1,[W15++]
0CDC:  BTSC.B  20F.1
0CDE:  BRA     CDC
0CE0:  MOV     W0,210
0CE2:  MOV     [--W15],W1
0CE4:  MOV     #30,W0
0CE6:  CPSGT   W1,W0
0CE8:  BRA     CD2
.................... 					ReadBuffer(InputBuffer);																	  
0CEA:  MOV     #818,W4
0CEC:  MOV     W4,9BE
0CEE:  CALL    A48
.................... 					PrintBuffer(InputBuffer,1000); 
0CF2:  MOV     #818,W4
0CF4:  MOV     W4,9B0
0CF6:  MOV     #3E8,W4
0CF8:  MOV     W4,9B2
0CFA:  CALL    A8E
.................... 					status=ValidateCommand(InputBuffer,30); 
0CFE:  MOV     #1E,W4
0D00:  MOV     W4,9BC
0D02:  MOV     #818,W4
0D04:  MOV     W4,9BA
0D06:  CALL    AC8
0D0A:  MOV     W0,9A6
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0D0C:  MOV     9A6,W4
0D0E:  CP      W4,#1
0D10:  BRA     NZ,D2C
0D12:  MOV     #0,W5
0D14:  MOV     W5,W0
0D16:  CALL    136
0D1A:  IOR.B   #0,W0L
0D1C:  BTSC.B  42.1
0D1E:  BRA     D2A
0D20:  INC     W5,W5
0D22:  MOV.B   W0L,9BC
0D24:  CALL    9DC
0D28:  BRA     D14
.................... 					else  
0D2A:  BRA     D46
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0D2C:  MOV     #0,W5
0D2E:  MOV     W5,W0
0D30:  CALL    14A
0D34:  IOR.B   #0,W0L
0D36:  BTSC.B  42.1
0D38:  BRA     D44
0D3A:  INC     W5,W5
0D3C:  MOV.B   W0L,9BC
0D3E:  CALL    9DC
0D42:  BRA     D2E
.................... 							status=0; 
0D44:  CLR     9A6
.................... 						} 
.................... 					delay_ms(500); 
0D46:  MOV     #1F4,W0
0D48:  CALL    738
.................... 				} 
.................... 			count++; 
0D4C:  INC     09A8
.................... 		} 
0D4E:  BRA     B08
.................... 	//return status; 
.................... } 
0D50:  MOV     [--W15],W5
0D52:  RETURN  
.................... /***********OpenPort************************************** 
.................... **   Description: Open a TCP port in domain name and    ** 
.................... **     specified in dname and rport variables           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int OpenPort(int socket, int lport,char dname[100], int rport) 
.................... { 
.................... 	int state=0; 
.................... 	printf("AT+AIPO=%d,%d,\"%s\",%d,0,,1,2\r\n",socket,lport,dname,rport);  //Conect to server 
.................... 	//******Get incoming buffer data****** 
.................... 	ReadBuffer(InputBuffer); 
.................... 	//***Validate ok command************** 
.................... 	state=ValidateCommand(InputBuffer,30); 
.................... 	if(state==1) lcd_putc("\fCMD OK"); 
.................... 	else 
.................... 		{ 
.................... 			 lcd_putc("\fCMD BAD"); 
.................... 			 state=0; 
.................... 		} 
.................... 	delay_ms(ptime); 
.................... 	return state; 
.................... } 
....................  
.................... /***********ClosePort************************************* 
.................... **   Description: Close a TCP port in domain name and   ** 
.................... **     specified in dname and rport variables           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ClosePort(int socket) 
.................... { 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
*
0EC4:  CLR.B   9C2
0EC6:  MOV     #818,W4
0EC8:  MOV     W4,9BE
0ECA:  MOV     #15E,W4
0ECC:  MOV     W4,9C0
0ECE:  CALL    A28
.................... 	printf("AT+AIPC=%d\r\n",socket);  //Disconnect 
0ED2:  MOV     #0,W1
0ED4:  MOV     W1,W0
0ED6:  CALL    1FA
0EDA:  INC     W1,W1
0EDC:  MOV     W1,[W15++]
0EDE:  BTSC.B  20F.1
0EE0:  BRA     EDE
0EE2:  MOV     W0,210
0EE4:  MOV     [--W15],W1
0EE6:  MOV     #7,W0
0EE8:  CPSGT   W1,W0
0EEA:  BRA     ED4
0EEC:  MOV     9BA,W0
0EEE:  MOV     #0,W4
0EF0:  CALL    D54
0EF4:  BTSC.B  20F.1
0EF6:  BRA     EF4
0EF8:  MOV     #D,W4
0EFA:  MOV     W4,210
0EFC:  BTSC.B  20F.1
0EFE:  BRA     EFC
0F00:  MOV     #A,W4
0F02:  MOV     W4,210
.................... 	ReadBuffer(InputBuffer); 
0F04:  MOV     #818,W4
0F06:  MOV     W4,9BE
0F08:  CALL    A48
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	//delay_ms(ptime); 
.................... } 
0F0C:  RETURN  
....................  
.................... /***********ConfigureDatetime***************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  dy24mt3yr2014hr11mn52$ (24/marzo/2014 11:52 a.m)    ** 
.................... *********************************************************/ 
.................... int ConfigureDatetime(int Id, byte* DateTime) 
.................... { 
0F0E:  MOV     W5,[W15++]
0F10:  MOV     W6,[W15++]
0F12:  CLR     9AA
0F14:  CLR     9AC
.................... 	int status=0; 
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
0F16:  CLR.B   9C2
0F18:  MOV     #818,W4
0F1A:  MOV     W4,9BE
0F1C:  MOV     #15E,W4
0F1E:  MOV     W4,9C0
0F20:  CALL    A28
.................... 	printf("GET /TIMEGPRS/NOWTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
0F24:  MOV     #0,W1
0F26:  MOV     W1,W0
0F28:  CALL    214
0F2C:  INC     W1,W1
0F2E:  MOV     W1,[W15++]
0F30:  BTSC.B  20F.1
0F32:  BRA     F30
0F34:  MOV     W0,210
0F36:  MOV     [--W15],W1
0F38:  MOV     #15,W0
0F3A:  CPSGT   W1,W0
0F3C:  BRA     F26
0F3E:  MOV     9A6,W0
0F40:  MOV     #0,W4
0F42:  CALL    D54
0F46:  MOV     #18,W1
0F48:  MOV     W1,W0
0F4A:  CALL    214
0F4E:  INC     W1,W1
0F50:  MOV     W1,[W15++]
0F52:  BTSC.B  20F.1
0F54:  BRA     F52
0F56:  MOV     W0,210
0F58:  MOV     [--W15],W1
0F5A:  MOV     #44,W0
0F5C:  CPSGT   W1,W0
0F5E:  BRA     F48
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
0F60:  MOV     #818,W4
0F62:  MOV     9AC,W3
0F64:  ADD     W3,W4,W5
0F66:  BTSS.B  20E.0
0F68:  BRA     F66
0F6A:  MOV     212,W0
0F6C:  MOV.B   W0L,[W5]
.................... 		index++; 
0F6E:  INC     09AC
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
0F70:  MOV     9AC,W4
0F72:  MOV     #15E,W3
0F74:  CP      W3,W4
0F76:  BRA     LE,F86
0F78:  MOV     9AC,W4
0F7A:  SUB     W4,#1,W5
0F7C:  MOV     #818,W4
0F7E:  ADD     W5,W4,W0
0F80:  MOV.B   [W0],W4L
0F82:  XOR.B   #24,W4L
0F84:  BRA     NZ,F60
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
0F86:  MOV     #818,W4
0F88:  MOV     W4,9BA
0F8A:  PUSH    9AC
0F8C:  POP     9BC
0F8E:  CALL    AC8
0F92:  MOV     W0,W5
0F94:  CP      W5,#1
0F96:  BRA     NZ,1052
.................... 		{ 
.................... 			lcd_putc("\fCMD OK"); 
0F98:  MOV     #0,W5
0F9A:  MOV     W5,W0
0F9C:  CALL    136
0FA0:  IOR.B   #0,W0L
0FA2:  BTSC.B  42.1
0FA4:  BRA     FB0
0FA6:  INC     W5,W5
0FA8:  MOV.B   W0L,9BC
0FAA:  CALL    9DC
0FAE:  BRA     F9A
.................... 			delay_ms(ptime); 
0FB0:  MOV     976,W0
0FB2:  CALL    738
....................  
.................... 			*(DateTime)=(int)GetDecVal(InputBuffer,index,'d','y'); 
0FB6:  MOV     9A8,W5
0FB8:  MOV.B   #64,W0L
0FBA:  MOV.B   W0L,9C2
0FBC:  MOV.B   #79,W0L
0FBE:  MOV.B   W0L,9C3
0FC0:  MOV     #818,W4
0FC2:  MOV     W4,9BE
0FC4:  PUSH    9AC
0FC6:  POP     9C0
0FC8:  CALL    E4E
0FCC:  MOV.B   W0L,[W5]
.................... 			*(DateTime+1)=(int)GetDecVal(InputBuffer,index,'m','t'); 
0FCE:  MOV     9A8,W4
0FD0:  ADD     W4,#1,W4
0FD2:  MOV     W4,W0
0FD4:  MOV     W0,W5
0FD6:  MOV.B   #6D,W0L
0FD8:  MOV.B   W0L,9C2
0FDA:  MOV.B   #74,W0L
0FDC:  MOV.B   W0L,9C3
0FDE:  MOV     #818,W4
0FE0:  MOV     W4,9BE
0FE2:  PUSH    9AC
0FE4:  POP     9C0
0FE6:  CALL    E4E
0FEA:  MOV.B   W0L,[W5]
.................... 			*(DateTime+2)=(int)(GetDecVal(InputBuffer,index,'y','r')-2000); 
0FEC:  MOV     9A8,W4
0FEE:  ADD     W4,#2,W4
0FF0:  MOV     W4,W0
0FF2:  MOV     W0,W5
0FF4:  MOV.B   #79,W0L
0FF6:  MOV.B   W0L,9C2
0FF8:  MOV.B   #72,W0L
0FFA:  MOV.B   W0L,9C3
0FFC:  MOV     #818,W4
0FFE:  MOV     W4,9BE
1000:  PUSH    9AC
1002:  POP     9C0
1004:  CALL    E4E
1008:  MOV     W0,W6
100A:  MOV     #7D0,W4
100C:  SUB     W6,W4,W0
100E:  MOV.B   W0L,[W5]
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
1010:  MOV     9A8,W4
1012:  ADD     W4,#3,W4
1014:  MOV     W4,W0
1016:  MOV     W0,W5
1018:  MOV.B   #68,W0L
101A:  MOV.B   W0L,9C2
101C:  MOV.B   #72,W0L
101E:  MOV.B   W0L,9C3
1020:  MOV     #818,W4
1022:  MOV     W4,9BE
1024:  PUSH    9AC
1026:  POP     9C0
1028:  CALL    E4E
102C:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
102E:  MOV     9A8,W4
1030:  ADD     W4,#4,W4
1032:  MOV     W4,W0
1034:  MOV     W0,W5
1036:  MOV.B   #6D,W0L
1038:  MOV.B   W0L,9C2
103A:  MOV.B   #6E,W0L
103C:  MOV.B   W0L,9C3
103E:  MOV     #818,W4
1040:  MOV     W4,9BE
1042:  PUSH    9AC
1044:  POP     9C0
1046:  CALL    E4E
104A:  MOV.B   W0L,[W5]
....................  
.................... 			status=1; 
104C:  MOV     #1,W4
104E:  MOV     W4,9AA
.................... 		} 
....................  
.................... 	else  
1050:  BRA     1054
.................... 		{ 
.................... 			status=0; 
1052:  CLR     9AA
.................... 		} 
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1054:  MOV     #32,W0
1056:  CALL    738
.................... 	printf("+"); 
105A:  BTSC.B  20F.1
105C:  BRA     105A
105E:  MOV     #2B,W4
1060:  MOV     W4,210
.................... 	printf("+"); 
1062:  BTSC.B  20F.1
1064:  BRA     1062
1066:  MOV     #2B,W4
1068:  MOV     W4,210
.................... 	printf("+"); 
106A:  BTSC.B  20F.1
106C:  BRA     106A
106E:  MOV     #2B,W4
1070:  MOV     W4,210
.................... 	OERR=16; 
1072:  MOV.B   #10,W0L
1074:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
1076:  MOV     #818,W4
1078:  MOV     W4,9BE
107A:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
107E:  MOV     #32,W0
1080:  CALL    738
.................... 	ClosePort(1); 
1084:  MOV     #1,W4
1086:  MOV     W4,9BA
1088:  CALL    EC4
.................... 	return status; 
108C:  PUSH    9AA
108E:  POP     0
.................... } 
1090:  MOV     [--W15],W6
1092:  MOV     [--W15],W5
1094:  RETURN  
....................  
.................... /***********GetSunriseTime******************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current sunrise time of the specified device     ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  hr11mn52$ (11:52 a.m)                               ** 
.................... *********************************************************/ 
.................... void GetOnTime(int Id, byte* DateTime) 
.................... { 
*
1456:  MOV     W5,[W15++]
1458:  CLR     9AA
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
145A:  CLR.B   9C2
145C:  MOV     #818,W4
145E:  MOV     W4,9BE
1460:  MOV     #15E,W4
1462:  MOV     W4,9C0
1464:  CALL    A28
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
1468:  MOV     #0,W1
146A:  MOV     W1,W0
146C:  CALL    1A4
1470:  INC     W1,W1
1472:  MOV     W1,[W15++]
1474:  BTSC.B  20F.1
1476:  BRA     1474
1478:  MOV     W0,210
147A:  MOV     [--W15],W1
147C:  MOV     #A,W0
147E:  CPSGT   W1,W0
1480:  BRA     146A
.................... 	ReadBuffer(InputBuffer); 
1482:  MOV     #818,W4
1484:  MOV     W4,9BE
1486:  CALL    A48
.................... 	delay_ms(ptime); 
148A:  MOV     976,W0
148C:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1490:  CLR.B   9C2
1492:  MOV     #818,W4
1494:  MOV     W4,9BE
1496:  MOV     #15E,W4
1498:  MOV     W4,9C0
149A:  CALL    A28
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
149E:  MOV     #0,W1
14A0:  MOV     W1,W0
14A2:  CALL    1BC
14A6:  INC     W1,W1
14A8:  MOV     W1,[W15++]
14AA:  BTSC.B  20F.1
14AC:  BRA     14AA
14AE:  MOV     W0,210
14B0:  MOV     [--W15],W1
14B2:  MOV     #30,W0
14B4:  CPSGT   W1,W0
14B6:  BRA     14A0
.................... 	ReadBuffer(InputBuffer); 
14B8:  MOV     #818,W4
14BA:  MOV     W4,9BE
14BC:  CALL    A48
.................... 	delay_ms(ptime); 
14C0:  MOV     976,W0
14C2:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
14C6:  CLR.B   9C2
14C8:  MOV     #818,W4
14CA:  MOV     W4,9BE
14CC:  MOV     #15E,W4
14CE:  MOV     W4,9C0
14D0:  CALL    A28
.................... 	printf("GET /TIMEGPRS/ONTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
14D4:  MOV     #0,W1
14D6:  MOV     W1,W0
14D8:  CALL    260
14DC:  INC     W1,W1
14DE:  MOV     W1,[W15++]
14E0:  BTSC.B  20F.1
14E2:  BRA     14E0
14E4:  MOV     W0,210
14E6:  MOV     [--W15],W1
14E8:  MOV     #14,W0
14EA:  CPSGT   W1,W0
14EC:  BRA     14D6
14EE:  MOV     9A6,W0
14F0:  MOV     #0,W4
14F2:  CALL    D54
14F6:  MOV     #17,W1
14F8:  MOV     W1,W0
14FA:  CALL    260
14FE:  INC     W1,W1
1500:  MOV     W1,[W15++]
1502:  BTSC.B  20F.1
1504:  BRA     1502
1506:  MOV     W0,210
1508:  MOV     [--W15],W1
150A:  MOV     #43,W0
150C:  CPSGT   W1,W0
150E:  BRA     14F8
....................  
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
1510:  MOV     #818,W4
1512:  MOV     9AA,W3
1514:  ADD     W3,W4,W5
1516:  BTSS.B  20E.0
1518:  BRA     1516
151A:  MOV     212,W0
151C:  MOV.B   W0L,[W5]
.................... 		index++; 
151E:  INC     09AA
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
1520:  MOV     9AA,W4
1522:  MOV     #15E,W3
1524:  CP      W3,W4
1526:  BRA     LE,1536
1528:  MOV     9AA,W4
152A:  SUB     W4,#1,W5
152C:  MOV     #818,W4
152E:  ADD     W5,W4,W0
1530:  MOV.B   [W0],W4L
1532:  XOR.B   #24,W4L
1534:  BRA     NZ,1510
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1536:  MOV     #818,W4
1538:  MOV     W4,9BA
153A:  PUSH    9AA
153C:  POP     9BC
153E:  CALL    AC8
1542:  MOV     W0,W5
1544:  CP      W5,#1
1546:  BRA     NZ,1584
.................... 		{ 
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
1548:  MOV     9A8,W4
154A:  ADD     W4,#3,W4
154C:  MOV     W4,W0
154E:  MOV     W0,W5
1550:  MOV.B   #68,W0L
1552:  MOV.B   W0L,9C2
1554:  MOV.B   #72,W0L
1556:  MOV.B   W0L,9C3
1558:  MOV     #818,W4
155A:  MOV     W4,9BE
155C:  PUSH    9AA
155E:  POP     9C0
1560:  CALL    E4E
1564:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
1566:  MOV     9A8,W4
1568:  ADD     W4,#4,W4
156A:  MOV     W4,W0
156C:  MOV     W0,W5
156E:  MOV.B   #6D,W0L
1570:  MOV.B   W0L,9C2
1572:  MOV.B   #6E,W0L
1574:  MOV.B   W0L,9C3
1576:  MOV     #818,W4
1578:  MOV     W4,9BE
157A:  PUSH    9AA
157C:  POP     9C0
157E:  CALL    E4E
1582:  MOV.B   W0L,[W5]
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1584:  MOV     #32,W0
1586:  CALL    738
.................... 	printf("+"); 
158A:  BTSC.B  20F.1
158C:  BRA     158A
158E:  MOV     #2B,W4
1590:  MOV     W4,210
.................... 	printf("+"); 
1592:  BTSC.B  20F.1
1594:  BRA     1592
1596:  MOV     #2B,W4
1598:  MOV     W4,210
.................... 	printf("+"); 
159A:  BTSC.B  20F.1
159C:  BRA     159A
159E:  MOV     #2B,W4
15A0:  MOV     W4,210
.................... 	OERR=16; 
15A2:  MOV.B   #10,W0L
15A4:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
15A6:  MOV     #818,W4
15A8:  MOV     W4,9BE
15AA:  CALL    A48
.................... 	ClosePort(1); 
15AE:  MOV     #1,W4
15B0:  MOV     W4,9BA
15B2:  CALL    EC4
.................... } 
15B6:  MOV     [--W15],W5
15B8:  RETURN  
....................  
.................... /***********GetSunsetTime******************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current sunset time of the specified device      ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  hr11mn52$ (11:52 a.m)                               ** 
.................... *********************************************************/ 
.................... void GetOffTime(int Id, byte* DateTime) 
.................... { 
15BA:  MOV     W5,[W15++]
15BC:  CLR     9AA
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
15BE:  CLR.B   9C2
15C0:  MOV     #818,W4
15C2:  MOV     W4,9BE
15C4:  MOV     #15E,W4
15C6:  MOV     W4,9C0
15C8:  CALL    A28
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
15CC:  MOV     #0,W1
15CE:  MOV     W1,W0
15D0:  CALL    1A4
15D4:  INC     W1,W1
15D6:  MOV     W1,[W15++]
15D8:  BTSC.B  20F.1
15DA:  BRA     15D8
15DC:  MOV     W0,210
15DE:  MOV     [--W15],W1
15E0:  MOV     #A,W0
15E2:  CPSGT   W1,W0
15E4:  BRA     15CE
.................... 	ReadBuffer(InputBuffer); 
15E6:  MOV     #818,W4
15E8:  MOV     W4,9BE
15EA:  CALL    A48
.................... 	delay_ms(ptime); 
15EE:  MOV     976,W0
15F0:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
15F4:  CLR.B   9C2
15F6:  MOV     #818,W4
15F8:  MOV     W4,9BE
15FA:  MOV     #15E,W4
15FC:  MOV     W4,9C0
15FE:  CALL    A28
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
1602:  MOV     #0,W1
1604:  MOV     W1,W0
1606:  CALL    1BC
160A:  INC     W1,W1
160C:  MOV     W1,[W15++]
160E:  BTSC.B  20F.1
1610:  BRA     160E
1612:  MOV     W0,210
1614:  MOV     [--W15],W1
1616:  MOV     #30,W0
1618:  CPSGT   W1,W0
161A:  BRA     1604
.................... 	ReadBuffer(InputBuffer); 
161C:  MOV     #818,W4
161E:  MOV     W4,9BE
1620:  CALL    A48
.................... 	delay_ms(ptime); 
1624:  MOV     976,W0
1626:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
162A:  CLR.B   9C2
162C:  MOV     #818,W4
162E:  MOV     W4,9BE
1630:  MOV     #15E,W4
1632:  MOV     W4,9C0
1634:  CALL    A28
.................... 	printf("GET /TIMEGPRS/OFFTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1638:  MOV     #0,W1
163A:  MOV     W1,W0
163C:  CALL    2AA
1640:  INC     W1,W1
1642:  MOV     W1,[W15++]
1644:  BTSC.B  20F.1
1646:  BRA     1644
1648:  MOV     W0,210
164A:  MOV     [--W15],W1
164C:  MOV     #15,W0
164E:  CPSGT   W1,W0
1650:  BRA     163A
1652:  MOV     9A6,W0
1654:  MOV     #0,W4
1656:  CALL    D54
165A:  MOV     #18,W1
165C:  MOV     W1,W0
165E:  CALL    2AA
1662:  INC     W1,W1
1664:  MOV     W1,[W15++]
1666:  BTSC.B  20F.1
1668:  BRA     1666
166A:  MOV     W0,210
166C:  MOV     [--W15],W1
166E:  MOV     #44,W0
1670:  CPSGT   W1,W0
1672:  BRA     165C
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
1674:  MOV     #818,W4
1676:  MOV     9AA,W3
1678:  ADD     W3,W4,W5
167A:  BTSS.B  20E.0
167C:  BRA     167A
167E:  MOV     212,W0
1680:  MOV.B   W0L,[W5]
.................... 		index++; 
1682:  INC     09AA
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
1684:  MOV     9AA,W4
1686:  MOV     #15E,W3
1688:  CP      W3,W4
168A:  BRA     LE,169A
168C:  MOV     9AA,W4
168E:  SUB     W4,#1,W5
1690:  MOV     #818,W4
1692:  ADD     W5,W4,W0
1694:  MOV.B   [W0],W4L
1696:  XOR.B   #24,W4L
1698:  BRA     NZ,1674
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
169A:  MOV     #818,W4
169C:  MOV     W4,9BA
169E:  PUSH    9AA
16A0:  POP     9BC
16A2:  CALL    AC8
16A6:  MOV     W0,W5
16A8:  CP      W5,#1
16AA:  BRA     NZ,16E8
.................... 		{ 
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
16AC:  MOV     9A8,W4
16AE:  ADD     W4,#3,W4
16B0:  MOV     W4,W0
16B2:  MOV     W0,W5
16B4:  MOV.B   #68,W0L
16B6:  MOV.B   W0L,9C2
16B8:  MOV.B   #72,W0L
16BA:  MOV.B   W0L,9C3
16BC:  MOV     #818,W4
16BE:  MOV     W4,9BE
16C0:  PUSH    9AA
16C2:  POP     9C0
16C4:  CALL    E4E
16C8:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
16CA:  MOV     9A8,W4
16CC:  ADD     W4,#4,W4
16CE:  MOV     W4,W0
16D0:  MOV     W0,W5
16D2:  MOV.B   #6D,W0L
16D4:  MOV.B   W0L,9C2
16D6:  MOV.B   #6E,W0L
16D8:  MOV.B   W0L,9C3
16DA:  MOV     #818,W4
16DC:  MOV     W4,9BE
16DE:  PUSH    9AA
16E0:  POP     9C0
16E2:  CALL    E4E
16E6:  MOV.B   W0L,[W5]
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
16E8:  MOV     #32,W0
16EA:  CALL    738
.................... 	printf("+"); 
16EE:  BTSC.B  20F.1
16F0:  BRA     16EE
16F2:  MOV     #2B,W4
16F4:  MOV     W4,210
.................... 	printf("+"); 
16F6:  BTSC.B  20F.1
16F8:  BRA     16F6
16FA:  MOV     #2B,W4
16FC:  MOV     W4,210
.................... 	printf("+"); 
16FE:  BTSC.B  20F.1
1700:  BRA     16FE
1702:  MOV     #2B,W4
1704:  MOV     W4,210
.................... 	OERR=16; 
1706:  MOV.B   #10,W0L
1708:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
170A:  MOV     #818,W4
170C:  MOV     W4,9BE
170E:  CALL    A48
.................... 	delay_ms(50); 
1712:  MOV     #32,W0
1714:  CALL    738
.................... 	ClosePort(1); 
1718:  MOV     #1,W4
171A:  MOV     W4,9BA
171C:  CALL    EC4
.................... } 
1720:  MOV     [--W15],W5
1722:  RETURN  
....................  
.................... /***********GetMode*************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void GetMode(int Id, int* mod,int state) 
.................... { 
*
1252:  MOV     W5,[W15++]
1254:  CLR     9AC
1256:  CLR     9AE
.................... 	int status=0; 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1258:  CLR.B   9C2
125A:  MOV     #818,W4
125C:  MOV     W4,9BE
125E:  MOV     #15E,W4
1260:  MOV     W4,9C0
1262:  CALL    A28
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
1266:  MOV     #0,W1
1268:  MOV     W1,W0
126A:  CALL    1A4
126E:  INC     W1,W1
1270:  MOV     W1,[W15++]
1272:  BTSC.B  20F.1
1274:  BRA     1272
1276:  MOV     W0,210
1278:  MOV     [--W15],W1
127A:  MOV     #A,W0
127C:  CPSGT   W1,W0
127E:  BRA     1268
.................... 	ReadBuffer(InputBuffer); 
1280:  MOV     #818,W4
1282:  MOV     W4,9BE
1284:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
1288:  MOV     976,W0
128A:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
128E:  CLR.B   9C2
1290:  MOV     #818,W4
1292:  MOV     W4,9BE
1294:  MOV     #15E,W4
1296:  MOV     W4,9C0
1298:  CALL    A28
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
129C:  MOV     #0,W1
129E:  MOV     W1,W0
12A0:  CALL    1BC
12A4:  INC     W1,W1
12A6:  MOV     W1,[W15++]
12A8:  BTSC.B  20F.1
12AA:  BRA     12A8
12AC:  MOV     W0,210
12AE:  MOV     [--W15],W1
12B0:  MOV     #30,W0
12B2:  CPSGT   W1,W0
12B4:  BRA     129E
.................... 	ReadBuffer(InputBuffer); 
12B6:  MOV     #818,W4
12B8:  MOV     W4,9BE
12BA:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
12BE:  MOV     976,W0
12C0:  CALL    738
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
12C4:  CLR.B   9C2
12C6:  MOV     #818,W4
12C8:  MOV     W4,9BE
12CA:  MOV     #15E,W4
12CC:  MOV     W4,9C0
12CE:  CALL    A28
.................... 	printf("GET /DEVICEGPRS/GETMODE/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
12D2:  MOV     #0,W1
12D4:  MOV     W1,W0
12D6:  CALL    2F6
12DA:  INC     W1,W1
12DC:  MOV     W1,[W15++]
12DE:  BTSC.B  20F.1
12E0:  BRA     12DE
12E2:  MOV     W0,210
12E4:  MOV     [--W15],W1
12E6:  MOV     #17,W0
12E8:  CPSGT   W1,W0
12EA:  BRA     12D4
12EC:  MOV     9A6,W0
12EE:  MOV     #0,W4
12F0:  CALL    D54
12F4:  MOV     #1A,W1
12F6:  MOV     W1,W0
12F8:  CALL    2F6
12FC:  INC     W1,W1
12FE:  MOV     W1,[W15++]
1300:  BTSC.B  20F.1
1302:  BRA     1300
1304:  MOV     W0,210
1306:  MOV     [--W15],W1
1308:  MOV     #46,W0
130A:  CPSGT   W1,W0
130C:  BRA     12F6
.................... 	while(getc()!='\n'); 
130E:  BTSS.B  20E.0
1310:  BRA     130E
1312:  MOV     212,W0
1314:  CP.B    W0L,#A
1316:  BRA     NZ,130E
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1318:  MOV     #818,W4
131A:  MOV     9AE,W3
131C:  ADD     W3,W4,W5
131E:  BTSS.B  20E.0
1320:  BRA     131E
1322:  MOV     212,W0
1324:  MOV.B   W0L,[W5]
.................... 		index++; 
1326:  INC     09AE
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1328:  MOV     9AE,W4
132A:  MOV     #15E,W3
132C:  CP      W3,W4
132E:  BRA     LE,133E
1330:  MOV     9AE,W4
1332:  SUB     W4,#1,W5
1334:  MOV     #818,W4
1336:  ADD     W5,W4,W0
1338:  MOV.B   [W0],W4L
133A:  XOR.B   #24,W4L
133C:  BRA     NZ,1318
....................  
.................... 	OERR=16; 
133E:  MOV.B   #10,W0L
1340:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1342:  MOV     #818,W4
1344:  MOV     W4,9BA
1346:  PUSH    9AE
1348:  POP     9BC
134A:  CALL    AC8
134E:  MOV     W0,W5
1350:  CP      W5,#1
1352:  BRA     NZ,1370
.................... 		{ 
.................... 			*mod=(int)GetDecVal(InputBuffer,index,'m','d'); 
1354:  MOV     9A8,W5
1356:  MOV.B   #6D,W0L
1358:  MOV.B   W0L,9C2
135A:  MOV.B   #64,W0L
135C:  MOV.B   W0L,9C3
135E:  MOV     #818,W4
1360:  MOV     W4,9BE
1362:  PUSH    9AE
1364:  POP     9C0
1366:  CALL    E4E
136A:  MOV     W0,[W5]
.................... 			status=1; 
136C:  MOV     #1,W4
136E:  MOV     W4,9AC
.................... 		} 
....................  
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1370:  CLR.B   9C2
1372:  MOV     #818,W4
1374:  MOV     W4,9BE
1376:  MOV     #15E,W4
1378:  MOV     W4,9C0
137A:  CALL    A28
.................... 	index=0; 
137E:  CLR     9AE
.................... 	printf("GET /DEVICEGPRS/GETSTATUS/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1380:  MOV     #0,W1
1382:  MOV     W1,W0
1384:  CALL    342
1388:  INC     W1,W1
138A:  MOV     W1,[W15++]
138C:  BTSC.B  20F.1
138E:  BRA     138C
1390:  MOV     W0,210
1392:  MOV     [--W15],W1
1394:  MOV     #19,W0
1396:  CPSGT   W1,W0
1398:  BRA     1382
139A:  MOV     9A6,W0
139C:  MOV     #0,W4
139E:  CALL    D54
13A2:  MOV     #1C,W1
13A4:  MOV     W1,W0
13A6:  CALL    342
13AA:  INC     W1,W1
13AC:  MOV     W1,[W15++]
13AE:  BTSC.B  20F.1
13B0:  BRA     13AE
13B2:  MOV     W0,210
13B4:  MOV     [--W15],W1
13B6:  MOV     #48,W0
13B8:  CPSGT   W1,W0
13BA:  BRA     13A4
.................... 	while(getc()!='\n'); 
13BC:  BTSS.B  20E.0
13BE:  BRA     13BC
13C0:  MOV     212,W0
13C2:  CP.B    W0L,#A
13C4:  BRA     NZ,13BC
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
13C6:  MOV     #818,W4
13C8:  MOV     9AE,W3
13CA:  ADD     W3,W4,W5
13CC:  BTSS.B  20E.0
13CE:  BRA     13CC
13D0:  MOV     212,W0
13D2:  MOV.B   W0L,[W5]
.................... 		index++; 
13D4:  INC     09AE
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
13D6:  MOV     9AE,W4
13D8:  MOV     #15E,W3
13DA:  CP      W3,W4
13DC:  BRA     LE,13EC
13DE:  MOV     9AE,W4
13E0:  SUB     W4,#1,W5
13E2:  MOV     #818,W4
13E4:  ADD     W5,W4,W0
13E6:  MOV.B   [W0],W4L
13E8:  XOR.B   #24,W4L
13EA:  BRA     NZ,13C6
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
13EC:  MOV     #818,W4
13EE:  MOV     W4,9BA
13F0:  PUSH    9AE
13F2:  POP     9BC
13F4:  CALL    AC8
13F8:  MOV     W0,W5
13FA:  CP      W5,#1
13FC:  BRA     NZ,141A
.................... 		{ 
.................... 			*state=(int)GetDecVal(InputBuffer,index,'s','t'); 
13FE:  MOV     9AA,W5
1400:  MOV.B   #73,W0L
1402:  MOV.B   W0L,9C2
1404:  MOV.B   #74,W0L
1406:  MOV.B   W0L,9C3
1408:  MOV     #818,W4
140A:  MOV     W4,9BE
140C:  PUSH    9AE
140E:  POP     9C0
1410:  CALL    E4E
1414:  MOV.B   W0L,[W5]
.................... 			status=1; 
1416:  MOV     #1,W4
1418:  MOV     W4,9AC
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
141A:  MOV     #32,W0
141C:  CALL    738
.................... 	printf("+"); 
1420:  BTSC.B  20F.1
1422:  BRA     1420
1424:  MOV     #2B,W4
1426:  MOV     W4,210
.................... 	printf("+"); 
1428:  BTSC.B  20F.1
142A:  BRA     1428
142C:  MOV     #2B,W4
142E:  MOV     W4,210
.................... 	printf("+"); 
1430:  BTSC.B  20F.1
1432:  BRA     1430
1434:  MOV     #2B,W4
1436:  MOV     W4,210
.................... 	OERR=16; 
1438:  MOV.B   #10,W0L
143A:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
143C:  MOV     #818,W4
143E:  MOV     W4,9BE
1440:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
1444:  MOV     #32,W0
1446:  CALL    738
.................... 	ClosePort(1); 
144A:  MOV     #1,W4
144C:  MOV     W4,9BA
144E:  CALL    EC4
.................... } 
1452:  MOV     [--W15],W5
1454:  RETURN  
....................  
.................... /***********GetAutomated*************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void GetAutomated(int Id, int* setpoint,int* histeresys) 
.................... { 
*
19D2:  MOV     W5,[W15++]
19D4:  CLR     9AC
19D6:  CLR     9AE
.................... 	int status=0; 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
19D8:  CLR.B   9C2
19DA:  MOV     #818,W4
19DC:  MOV     W4,9BE
19DE:  MOV     #15E,W4
19E0:  MOV     W4,9C0
19E2:  CALL    A28
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
19E6:  MOV     #0,W1
19E8:  MOV     W1,W0
19EA:  CALL    1A4
19EE:  INC     W1,W1
19F0:  MOV     W1,[W15++]
19F2:  BTSC.B  20F.1
19F4:  BRA     19F2
19F6:  MOV     W0,210
19F8:  MOV     [--W15],W1
19FA:  MOV     #A,W0
19FC:  CPSGT   W1,W0
19FE:  BRA     19E8
.................... 	ReadBuffer(InputBuffer); 
1A00:  MOV     #818,W4
1A02:  MOV     W4,9BE
1A04:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
1A08:  MOV     976,W0
1A0A:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1A0E:  CLR.B   9C2
1A10:  MOV     #818,W4
1A12:  MOV     W4,9BE
1A14:  MOV     #15E,W4
1A16:  MOV     W4,9C0
1A18:  CALL    A28
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
1A1C:  MOV     #0,W1
1A1E:  MOV     W1,W0
1A20:  CALL    1BC
1A24:  INC     W1,W1
1A26:  MOV     W1,[W15++]
1A28:  BTSC.B  20F.1
1A2A:  BRA     1A28
1A2C:  MOV     W0,210
1A2E:  MOV     [--W15],W1
1A30:  MOV     #30,W0
1A32:  CPSGT   W1,W0
1A34:  BRA     1A1E
.................... 	ReadBuffer(InputBuffer); 
1A36:  MOV     #818,W4
1A38:  MOV     W4,9BE
1A3A:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
1A3E:  MOV     976,W0
1A40:  CALL    738
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1A44:  CLR.B   9C2
1A46:  MOV     #818,W4
1A48:  MOV     W4,9BE
1A4A:  MOV     #15E,W4
1A4C:  MOV     W4,9C0
1A4E:  CALL    A28
.................... 	printf("GET /DEVICEGPRS/GETSETPOINT/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1A52:  MOV     #0,W1
1A54:  MOV     W1,W0
1A56:  CALL    390
1A5A:  INC     W1,W1
1A5C:  MOV     W1,[W15++]
1A5E:  BTSC.B  20F.1
1A60:  BRA     1A5E
1A62:  MOV     W0,210
1A64:  MOV     [--W15],W1
1A66:  MOV     #1B,W0
1A68:  CPSGT   W1,W0
1A6A:  BRA     1A54
1A6C:  MOV     9A6,W0
1A6E:  MOV     #0,W4
1A70:  CALL    D54
1A74:  MOV     #1E,W1
1A76:  MOV     W1,W0
1A78:  CALL    390
1A7C:  INC     W1,W1
1A7E:  MOV     W1,[W15++]
1A80:  BTSC.B  20F.1
1A82:  BRA     1A80
1A84:  MOV     W0,210
1A86:  MOV     [--W15],W1
1A88:  MOV     #4A,W0
1A8A:  CPSGT   W1,W0
1A8C:  BRA     1A76
.................... 	while(getc()!='\n'); 
1A8E:  BTSS.B  20E.0
1A90:  BRA     1A8E
1A92:  MOV     212,W0
1A94:  CP.B    W0L,#A
1A96:  BRA     NZ,1A8E
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1A98:  MOV     #818,W4
1A9A:  MOV     9AE,W3
1A9C:  ADD     W3,W4,W5
1A9E:  BTSS.B  20E.0
1AA0:  BRA     1A9E
1AA2:  MOV     212,W0
1AA4:  MOV.B   W0L,[W5]
.................... 		index++; 
1AA6:  INC     09AE
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1AA8:  MOV     9AE,W4
1AAA:  MOV     #15E,W3
1AAC:  CP      W3,W4
1AAE:  BRA     LE,1ABE
1AB0:  MOV     9AE,W4
1AB2:  SUB     W4,#1,W5
1AB4:  MOV     #818,W4
1AB6:  ADD     W5,W4,W0
1AB8:  MOV.B   [W0],W4L
1ABA:  XOR.B   #24,W4L
1ABC:  BRA     NZ,1A98
....................  
.................... 	OERR=16; 
1ABE:  MOV.B   #10,W0L
1AC0:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1AC2:  MOV     #818,W4
1AC4:  MOV     W4,9BA
1AC6:  PUSH    9AE
1AC8:  POP     9BC
1ACA:  CALL    AC8
1ACE:  MOV     W0,W5
1AD0:  CP      W5,#1
1AD2:  BRA     NZ,1AF0
.................... 		{ 
.................... 			*setpoint=(int)GetDecVal(InputBuffer,index,'s','t'); 
1AD4:  MOV     9A8,W5
1AD6:  MOV.B   #73,W0L
1AD8:  MOV.B   W0L,9C2
1ADA:  MOV.B   #74,W0L
1ADC:  MOV.B   W0L,9C3
1ADE:  MOV     #818,W4
1AE0:  MOV     W4,9BE
1AE2:  PUSH    9AE
1AE4:  POP     9C0
1AE6:  CALL    E4E
1AEA:  MOV     W0,[W5]
.................... 			status=1; 
1AEC:  MOV     #1,W4
1AEE:  MOV     W4,9AC
.................... 		} 
....................  
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1AF0:  CLR.B   9C2
1AF2:  MOV     #818,W4
1AF4:  MOV     W4,9BE
1AF6:  MOV     #15E,W4
1AF8:  MOV     W4,9C0
1AFA:  CALL    A28
.................... 	index=0; 
1AFE:  CLR     9AE
.................... 	printf("GET /DEVICEGPRS/GETHIST/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1B00:  MOV     #0,W1
1B02:  MOV     W1,W0
1B04:  CALL    3E0
1B08:  INC     W1,W1
1B0A:  MOV     W1,[W15++]
1B0C:  BTSC.B  20F.1
1B0E:  BRA     1B0C
1B10:  MOV     W0,210
1B12:  MOV     [--W15],W1
1B14:  MOV     #17,W0
1B16:  CPSGT   W1,W0
1B18:  BRA     1B02
1B1A:  MOV     9A6,W0
1B1C:  MOV     #0,W4
1B1E:  CALL    D54
1B22:  MOV     #1A,W1
1B24:  MOV     W1,W0
1B26:  CALL    3E0
1B2A:  INC     W1,W1
1B2C:  MOV     W1,[W15++]
1B2E:  BTSC.B  20F.1
1B30:  BRA     1B2E
1B32:  MOV     W0,210
1B34:  MOV     [--W15],W1
1B36:  MOV     #46,W0
1B38:  CPSGT   W1,W0
1B3A:  BRA     1B24
.................... 	while(getc()!='\n'); 
1B3C:  BTSS.B  20E.0
1B3E:  BRA     1B3C
1B40:  MOV     212,W0
1B42:  CP.B    W0L,#A
1B44:  BRA     NZ,1B3C
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1B46:  MOV     #818,W4
1B48:  MOV     9AE,W3
1B4A:  ADD     W3,W4,W5
1B4C:  BTSS.B  20E.0
1B4E:  BRA     1B4C
1B50:  MOV     212,W0
1B52:  MOV.B   W0L,[W5]
.................... 		index++; 
1B54:  INC     09AE
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1B56:  MOV     9AE,W4
1B58:  MOV     #15E,W3
1B5A:  CP      W3,W4
1B5C:  BRA     LE,1B6C
1B5E:  MOV     9AE,W4
1B60:  SUB     W4,#1,W5
1B62:  MOV     #818,W4
1B64:  ADD     W5,W4,W0
1B66:  MOV.B   [W0],W4L
1B68:  XOR.B   #24,W4L
1B6A:  BRA     NZ,1B46
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1B6C:  MOV     #818,W4
1B6E:  MOV     W4,9BA
1B70:  PUSH    9AE
1B72:  POP     9BC
1B74:  CALL    AC8
1B78:  MOV     W0,W5
1B7A:  CP      W5,#1
1B7C:  BRA     NZ,1B9A
.................... 		{ 
.................... 			*histeresys=(int)GetDecVal(InputBuffer,index,'s','t'); 
1B7E:  MOV     9AA,W5
1B80:  MOV.B   #73,W0L
1B82:  MOV.B   W0L,9C2
1B84:  MOV.B   #74,W0L
1B86:  MOV.B   W0L,9C3
1B88:  MOV     #818,W4
1B8A:  MOV     W4,9BE
1B8C:  PUSH    9AE
1B8E:  POP     9C0
1B90:  CALL    E4E
1B94:  MOV     W0,[W5]
.................... 			status=1; 
1B96:  MOV     #1,W4
1B98:  MOV     W4,9AC
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1B9A:  MOV     #32,W0
1B9C:  CALL    738
.................... 	printf("+"); 
1BA0:  BTSC.B  20F.1
1BA2:  BRA     1BA0
1BA4:  MOV     #2B,W4
1BA6:  MOV     W4,210
.................... 	printf("+"); 
1BA8:  BTSC.B  20F.1
1BAA:  BRA     1BA8
1BAC:  MOV     #2B,W4
1BAE:  MOV     W4,210
.................... 	printf("+"); 
1BB0:  BTSC.B  20F.1
1BB2:  BRA     1BB0
1BB4:  MOV     #2B,W4
1BB6:  MOV     W4,210
.................... 	OERR=16; 
1BB8:  MOV.B   #10,W0L
1BBA:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
1BBC:  MOV     #818,W4
1BBE:  MOV     W4,9BE
1BC0:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
1BC4:  MOV     #32,W0
1BC6:  CALL    738
.................... 	ClosePort(1); 
1BCA:  MOV     #1,W4
1BCC:  MOV     W4,9BA
1BCE:  CALL    EC4
.................... } 
1BD2:  MOV     [--W15],W5
1BD4:  RETURN  
.................... /***********GetPort*************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void GetPort(int Id, int* porton,int* portoff,int* portin) 
.................... { 
*
1724:  MOV     W5,[W15++]
1726:  CLR     9AE
1728:  CLR     9B0
.................... 	int status=0; 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
172A:  CLR.B   9C2
172C:  MOV     #818,W4
172E:  MOV     W4,9BE
1730:  MOV     #15E,W4
1732:  MOV     W4,9C0
1734:  CALL    A28
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
1738:  MOV     #0,W1
173A:  MOV     W1,W0
173C:  CALL    1A4
1740:  INC     W1,W1
1742:  MOV     W1,[W15++]
1744:  BTSC.B  20F.1
1746:  BRA     1744
1748:  MOV     W0,210
174A:  MOV     [--W15],W1
174C:  MOV     #A,W0
174E:  CPSGT   W1,W0
1750:  BRA     173A
.................... 	ReadBuffer(InputBuffer); 
1752:  MOV     #818,W4
1754:  MOV     W4,9BE
1756:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
175A:  MOV     976,W0
175C:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1760:  CLR.B   9C2
1762:  MOV     #818,W4
1764:  MOV     W4,9BE
1766:  MOV     #15E,W4
1768:  MOV     W4,9C0
176A:  CALL    A28
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
176E:  MOV     #0,W1
1770:  MOV     W1,W0
1772:  CALL    1BC
1776:  INC     W1,W1
1778:  MOV     W1,[W15++]
177A:  BTSC.B  20F.1
177C:  BRA     177A
177E:  MOV     W0,210
1780:  MOV     [--W15],W1
1782:  MOV     #30,W0
1784:  CPSGT   W1,W0
1786:  BRA     1770
.................... 	ReadBuffer(InputBuffer); 
1788:  MOV     #818,W4
178A:  MOV     W4,9BE
178C:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
1790:  MOV     976,W0
1792:  CALL    738
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1796:  CLR.B   9C2
1798:  MOV     #818,W4
179A:  MOV     W4,9BE
179C:  MOV     #15E,W4
179E:  MOV     W4,9C0
17A0:  CALL    A28
.................... 	printf("GET /DEVICEGPRS/GETPORTON/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
17A4:  MOV     #0,W1
17A6:  MOV     W1,W0
17A8:  CALL    42C
17AC:  INC     W1,W1
17AE:  MOV     W1,[W15++]
17B0:  BTSC.B  20F.1
17B2:  BRA     17B0
17B4:  MOV     W0,210
17B6:  MOV     [--W15],W1
17B8:  MOV     #19,W0
17BA:  CPSGT   W1,W0
17BC:  BRA     17A6
17BE:  MOV     9A6,W0
17C0:  MOV     #0,W4
17C2:  CALL    D54
17C6:  MOV     #1C,W1
17C8:  MOV     W1,W0
17CA:  CALL    42C
17CE:  INC     W1,W1
17D0:  MOV     W1,[W15++]
17D2:  BTSC.B  20F.1
17D4:  BRA     17D2
17D6:  MOV     W0,210
17D8:  MOV     [--W15],W1
17DA:  MOV     #48,W0
17DC:  CPSGT   W1,W0
17DE:  BRA     17C8
.................... 	while(getc()!='\n'); 
17E0:  BTSS.B  20E.0
17E2:  BRA     17E0
17E4:  MOV     212,W0
17E6:  CP.B    W0L,#A
17E8:  BRA     NZ,17E0
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
17EA:  MOV     #818,W4
17EC:  MOV     9B0,W3
17EE:  ADD     W3,W4,W5
17F0:  BTSS.B  20E.0
17F2:  BRA     17F0
17F4:  MOV     212,W0
17F6:  MOV.B   W0L,[W5]
.................... 		index++; 
17F8:  INC     09B0
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
17FA:  MOV     9B0,W4
17FC:  MOV     #15E,W3
17FE:  CP      W3,W4
1800:  BRA     LE,1810
1802:  MOV     9B0,W4
1804:  SUB     W4,#1,W5
1806:  MOV     #818,W4
1808:  ADD     W5,W4,W0
180A:  MOV.B   [W0],W4L
180C:  XOR.B   #24,W4L
180E:  BRA     NZ,17EA
....................  
.................... 	OERR=16; 
1810:  MOV.B   #10,W0L
1812:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1814:  MOV     #818,W4
1816:  MOV     W4,9BA
1818:  PUSH    9B0
181A:  POP     9BC
181C:  CALL    AC8
1820:  MOV     W0,W5
1822:  CP      W5,#1
1824:  BRA     NZ,1842
.................... 		{ 
.................... 			*porton=(int)GetDecVal(InputBuffer,index,'s','t'); 
1826:  MOV     9A8,W5
1828:  MOV.B   #73,W0L
182A:  MOV.B   W0L,9C2
182C:  MOV.B   #74,W0L
182E:  MOV.B   W0L,9C3
1830:  MOV     #818,W4
1832:  MOV     W4,9BE
1834:  PUSH    9B0
1836:  POP     9C0
1838:  CALL    E4E
183C:  MOV     W0,[W5]
.................... 			status=1; 
183E:  MOV     #1,W4
1840:  MOV     W4,9AE
.................... 		} 
....................  
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1842:  CLR.B   9C2
1844:  MOV     #818,W4
1846:  MOV     W4,9BE
1848:  MOV     #15E,W4
184A:  MOV     W4,9C0
184C:  CALL    A28
.................... 	index=0; 
1850:  CLR     9B0
.................... 	printf("GET /DEVICEGPRS/GETPORTOFF/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1852:  MOV     #0,W1
1854:  MOV     W1,W0
1856:  CALL    47A
185A:  INC     W1,W1
185C:  MOV     W1,[W15++]
185E:  BTSC.B  20F.1
1860:  BRA     185E
1862:  MOV     W0,210
1864:  MOV     [--W15],W1
1866:  MOV     #1A,W0
1868:  CPSGT   W1,W0
186A:  BRA     1854
186C:  MOV     9A6,W0
186E:  MOV     #0,W4
1870:  CALL    D54
1874:  MOV     #1D,W1
1876:  MOV     W1,W0
1878:  CALL    47A
187C:  INC     W1,W1
187E:  MOV     W1,[W15++]
1880:  BTSC.B  20F.1
1882:  BRA     1880
1884:  MOV     W0,210
1886:  MOV     [--W15],W1
1888:  MOV     #49,W0
188A:  CPSGT   W1,W0
188C:  BRA     1876
.................... 	while(getc()!='\n'); 
188E:  BTSS.B  20E.0
1890:  BRA     188E
1892:  MOV     212,W0
1894:  CP.B    W0L,#A
1896:  BRA     NZ,188E
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1898:  MOV     #818,W4
189A:  MOV     9B0,W3
189C:  ADD     W3,W4,W5
189E:  BTSS.B  20E.0
18A0:  BRA     189E
18A2:  MOV     212,W0
18A4:  MOV.B   W0L,[W5]
.................... 		index++; 
18A6:  INC     09B0
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
18A8:  MOV     9B0,W4
18AA:  MOV     #15E,W3
18AC:  CP      W3,W4
18AE:  BRA     LE,18BE
18B0:  MOV     9B0,W4
18B2:  SUB     W4,#1,W5
18B4:  MOV     #818,W4
18B6:  ADD     W5,W4,W0
18B8:  MOV.B   [W0],W4L
18BA:  XOR.B   #24,W4L
18BC:  BRA     NZ,1898
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
18BE:  MOV     #818,W4
18C0:  MOV     W4,9BA
18C2:  PUSH    9B0
18C4:  POP     9BC
18C6:  CALL    AC8
18CA:  MOV     W0,W5
18CC:  CP      W5,#1
18CE:  BRA     NZ,18EC
.................... 		{ 
.................... 			*portoff=(int)GetDecVal(InputBuffer,index,'s','t'); 
18D0:  MOV     9AA,W5
18D2:  MOV.B   #73,W0L
18D4:  MOV.B   W0L,9C2
18D6:  MOV.B   #74,W0L
18D8:  MOV.B   W0L,9C3
18DA:  MOV     #818,W4
18DC:  MOV     W4,9BE
18DE:  PUSH    9B0
18E0:  POP     9C0
18E2:  CALL    E4E
18E6:  MOV     W0,[W5]
.................... 			status=1; 
18E8:  MOV     #1,W4
18EA:  MOV     W4,9AE
.................... 		} 
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
18EC:  CLR.B   9C2
18EE:  MOV     #818,W4
18F0:  MOV     W4,9BE
18F2:  MOV     #15E,W4
18F4:  MOV     W4,9C0
18F6:  CALL    A28
.................... 	index=0; 
18FA:  CLR     9B0
.................... 	printf("GET /DEVICEGPRS/GETPORTIN/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
18FC:  MOV     #0,W1
18FE:  MOV     W1,W0
1900:  CALL    4C8
1904:  INC     W1,W1
1906:  MOV     W1,[W15++]
1908:  BTSC.B  20F.1
190A:  BRA     1908
190C:  MOV     W0,210
190E:  MOV     [--W15],W1
1910:  MOV     #19,W0
1912:  CPSGT   W1,W0
1914:  BRA     18FE
1916:  MOV     9A6,W0
1918:  MOV     #0,W4
191A:  CALL    D54
191E:  MOV     #1C,W1
1920:  MOV     W1,W0
1922:  CALL    4C8
1926:  INC     W1,W1
1928:  MOV     W1,[W15++]
192A:  BTSC.B  20F.1
192C:  BRA     192A
192E:  MOV     W0,210
1930:  MOV     [--W15],W1
1932:  MOV     #48,W0
1934:  CPSGT   W1,W0
1936:  BRA     1920
.................... 	while(getc()!='\n'); 
1938:  BTSS.B  20E.0
193A:  BRA     1938
193C:  MOV     212,W0
193E:  CP.B    W0L,#A
1940:  BRA     NZ,1938
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1942:  MOV     #818,W4
1944:  MOV     9B0,W3
1946:  ADD     W3,W4,W5
1948:  BTSS.B  20E.0
194A:  BRA     1948
194C:  MOV     212,W0
194E:  MOV.B   W0L,[W5]
.................... 		index++; 
1950:  INC     09B0
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1952:  MOV     9B0,W4
1954:  MOV     #15E,W3
1956:  CP      W3,W4
1958:  BRA     LE,1968
195A:  MOV     9B0,W4
195C:  SUB     W4,#1,W5
195E:  MOV     #818,W4
1960:  ADD     W5,W4,W0
1962:  MOV.B   [W0],W4L
1964:  XOR.B   #24,W4L
1966:  BRA     NZ,1942
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1968:  MOV     #818,W4
196A:  MOV     W4,9BA
196C:  PUSH    9B0
196E:  POP     9BC
1970:  CALL    AC8
1974:  MOV     W0,W5
1976:  CP      W5,#1
1978:  BRA     NZ,1996
.................... 		{ 
.................... 			*portin=(int)GetDecVal(InputBuffer,index,'s','t'); 
197A:  MOV     9AC,W5
197C:  MOV.B   #73,W0L
197E:  MOV.B   W0L,9C2
1980:  MOV.B   #74,W0L
1982:  MOV.B   W0L,9C3
1984:  MOV     #818,W4
1986:  MOV     W4,9BE
1988:  PUSH    9B0
198A:  POP     9C0
198C:  CALL    E4E
1990:  MOV     W0,[W5]
.................... 			status=1; 
1992:  MOV     #1,W4
1994:  MOV     W4,9AE
.................... 		} 
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1996:  MOV     #32,W0
1998:  CALL    738
.................... 	printf("+"); 
199C:  BTSC.B  20F.1
199E:  BRA     199C
19A0:  MOV     #2B,W4
19A2:  MOV     W4,210
.................... 	printf("+"); 
19A4:  BTSC.B  20F.1
19A6:  BRA     19A4
19A8:  MOV     #2B,W4
19AA:  MOV     W4,210
.................... 	printf("+"); 
19AC:  BTSC.B  20F.1
19AE:  BRA     19AC
19B0:  MOV     #2B,W4
19B2:  MOV     W4,210
.................... 	OERR=16; 
19B4:  MOV.B   #10,W0L
19B6:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
19B8:  MOV     #818,W4
19BA:  MOV     W4,9BE
19BC:  CALL    A48
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
19C0:  MOV     #32,W0
19C2:  CALL    738
.................... 	ClosePort(1); 
19C6:  MOV     #1,W4
19C8:  MOV     W4,9BA
19CA:  CALL    EC4
.................... } 
19CE:  MOV     [--W15],W5
19D0:  RETURN  
.................... /***********ReportData************************************ 
.................... **   Description: Connects to server to report the      ** 
.................... **     current consuptions of current and voltage       ** 
.................... **                                                      ** 
.................... *********************************************************/ 
....................  
.................... void ReportData(int Id, int status) 
.................... { 
*
286E:  MOV     W5,[W15++]
2870:  CLR     9AA
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
2872:  CLR.B   9C2
2874:  MOV     #818,W4
2876:  MOV     W4,9BE
2878:  MOV     #15E,W4
287A:  MOV     W4,9C0
287C:  CALL    A28
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
2880:  MOV     #0,W1
2882:  MOV     W1,W0
2884:  CALL    1A4
2888:  INC     W1,W1
288A:  MOV     W1,[W15++]
288C:  BTSC.B  20F.1
288E:  BRA     288C
2890:  MOV     W0,210
2892:  MOV     [--W15],W1
2894:  MOV     #A,W0
2896:  CPSGT   W1,W0
2898:  BRA     2882
.................... 	ReadBuffer(InputBuffer); 
289A:  MOV     #818,W4
289C:  MOV     W4,9BE
289E:  CALL    A48
.................... 	delay_ms(ptime); 
28A2:  MOV     976,W0
28A4:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
28A8:  CLR.B   9C2
28AA:  MOV     #818,W4
28AC:  MOV     W4,9BE
28AE:  MOV     #15E,W4
28B0:  MOV     W4,9C0
28B2:  CALL    A28
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
28B6:  MOV     #0,W1
28B8:  MOV     W1,W0
28BA:  CALL    1BC
28BE:  INC     W1,W1
28C0:  MOV     W1,[W15++]
28C2:  BTSC.B  20F.1
28C4:  BRA     28C2
28C6:  MOV     W0,210
28C8:  MOV     [--W15],W1
28CA:  MOV     #30,W0
28CC:  CPSGT   W1,W0
28CE:  BRA     28B8
.................... 	ReadBuffer(InputBuffer); 
28D0:  MOV     #818,W4
28D2:  MOV     W4,9BE
28D4:  CALL    A48
.................... 	delay_ms(ptime); 
28D8:  MOV     976,W0
28DA:  CALL    738
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer /monitoringgprs/create?id=14&status=0&current=1&voltage=2 
28DE:  CLR.B   9C2
28E0:  MOV     #818,W4
28E2:  MOV     W4,9BE
28E4:  MOV     #15E,W4
28E6:  MOV     W4,9C0
28E8:  CALL    A28
.................... 	printf("GET /MONITORINGGPRS/CREATE2?ID=%d&STATUS=%d",Id,status); 
28EC:  MOV     #0,W1
28EE:  MOV     W1,W0
28F0:  CALL    516
28F4:  INC     W1,W1
28F6:  MOV     W1,[W15++]
28F8:  BTSC.B  20F.1
28FA:  BRA     28F8
28FC:  MOV     W0,210
28FE:  MOV     [--W15],W1
2900:  MOV     #1E,W0
2902:  CPSGT   W1,W0
2904:  BRA     28EE
2906:  MOV     9A6,W0
2908:  MOV     #0,W4
290A:  CALL    D54
290E:  MOV     #21,W1
2910:  MOV     W1,W0
2912:  CALL    516
2916:  INC     W1,W1
2918:  MOV     W1,[W15++]
291A:  BTSC.B  20F.1
291C:  BRA     291A
291E:  MOV     W0,210
2920:  MOV     [--W15],W1
2922:  MOV     #28,W0
2924:  CPSGT   W1,W0
2926:  BRA     2910
2928:  MOV     9A8,W0
292A:  MOV     #0,W4
292C:  CALL    D54
.................... 	printf("&CURRENT=%f",current); 
2930:  MOV     #0,W1
2932:  MOV     W1,W0
2934:  CALL    550
2938:  INC     W1,W1
293A:  MOV     W1,[W15++]
293C:  BTSC.B  20F.1
293E:  BRA     293C
2940:  MOV     W0,210
2942:  MOV     [--W15],W1
2944:  MOV     #8,W0
2946:  CPSGT   W1,W0
2948:  BRA     2932
294A:  MOV     802,W2
294C:  MOV     800,W1
294E:  MOV     #0,W0
2950:  CALL    2144
2954:  MOV     #2,W9
2956:  MOV     #8008,W10
2958:  CALL    26EC
.................... 	printf("&VOLTAGE=%.2f",battery); 
295C:  MOV     #0,W1
295E:  MOV     W1,W0
2960:  CALL    568
2964:  INC     W1,W1
2966:  MOV     W1,[W15++]
2968:  BTSC.B  20F.1
296A:  BRA     2968
296C:  MOV     W0,210
296E:  MOV     [--W15],W1
2970:  MOV     #8,W0
2972:  CPSGT   W1,W0
2974:  BRA     295E
2976:  MOV     806,W2
2978:  MOV     804,W1
297A:  MOV     #0,W0
297C:  CALL    2144
2980:  MOV     #2,W9
2982:  MOV     #8009,W10
2984:  CALL    26EC
.................... 	printf("&VAR1=%f",s1); 
2988:  MOV     #0,W1
298A:  MOV     W1,W0
298C:  CALL    582
2990:  INC     W1,W1
2992:  MOV     W1,[W15++]
2994:  BTSC.B  20F.1
2996:  BRA     2994
2998:  MOV     W0,210
299A:  MOV     [--W15],W1
299C:  MOV     #5,W0
299E:  CPSGT   W1,W0
29A0:  BRA     298A
29A2:  MOV     80E,W2
29A4:  MOV     80C,W1
29A6:  MOV     #0,W0
29A8:  CALL    2144
29AC:  MOV     #2,W9
29AE:  MOV     #8008,W10
29B0:  CALL    26EC
.................... 	printf("&VAR2=%f HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",s2); 
29B4:  MOV     #0,W1
29B6:  MOV     W1,W0
29B8:  CALL    598
29BC:  INC     W1,W1
29BE:  MOV     W1,[W15++]
29C0:  BTSC.B  20F.1
29C2:  BRA     29C0
29C4:  MOV     W0,210
29C6:  MOV     [--W15],W1
29C8:  MOV     #5,W0
29CA:  CPSGT   W1,W0
29CC:  BRA     29B6
29CE:  MOV     812,W2
29D0:  MOV     810,W1
29D2:  MOV     #0,W0
29D4:  CALL    2144
29D8:  MOV     #2,W9
29DA:  MOV     #8008,W10
29DC:  CALL    26EC
29E0:  MOV     #8,W1
29E2:  MOV     W1,W0
29E4:  CALL    598
29E8:  INC     W1,W1
29EA:  MOV     W1,[W15++]
29EC:  BTSC.B  20F.1
29EE:  BRA     29EC
29F0:  MOV     W0,210
29F2:  MOV     [--W15],W1
29F4:  MOV     #34,W0
29F6:  CPSGT   W1,W0
29F8:  BRA     29E2
.................... 		//printf("GET /MONITORINGGPRS/CREATE?ID=9&STATUS=1&CURRENT=6&VOLTAGE=6 HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n"); 
.................... 	while(getc()!='\n'); 
29FA:  BTSS.B  20E.0
29FC:  BRA     29FA
29FE:  MOV     212,W0
2A00:  CP.B    W0L,#A
2A02:  BRA     NZ,29FA
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
2A04:  MOV     #818,W4
2A06:  MOV     9AA,W3
2A08:  ADD     W3,W4,W5
2A0A:  BTSS.B  20E.0
2A0C:  BRA     2A0A
2A0E:  MOV     212,W0
2A10:  MOV.B   W0L,[W5]
.................... 		index++; 
2A12:  INC     09AA
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
2A14:  MOV     9AA,W4
2A16:  MOV     #15E,W3
2A18:  CP      W3,W4
2A1A:  BRA     LE,2A2A
2A1C:  MOV     9AA,W4
2A1E:  SUB     W4,#1,W5
2A20:  MOV     #818,W4
2A22:  ADD     W5,W4,W0
2A24:  MOV.B   [W0],W4L
2A26:  XOR.B   #24,W4L
2A28:  BRA     NZ,2A04
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
2A2A:  MOV     #32,W0
2A2C:  CALL    738
.................... 	printf("+"); 
2A30:  BTSC.B  20F.1
2A32:  BRA     2A30
2A34:  MOV     #2B,W4
2A36:  MOV     W4,210
.................... 	printf("+"); 
2A38:  BTSC.B  20F.1
2A3A:  BRA     2A38
2A3C:  MOV     #2B,W4
2A3E:  MOV     W4,210
.................... 	printf("+"); 
2A40:  BTSC.B  20F.1
2A42:  BRA     2A40
2A44:  MOV     #2B,W4
2A46:  MOV     W4,210
.................... 	OERR=16; 
2A48:  MOV.B   #10,W0L
2A4A:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
2A4C:  MOV     #818,W4
2A4E:  MOV     W4,9BE
2A50:  CALL    A48
.................... 	delay_ms(50); 
2A54:  MOV     #32,W0
2A56:  CALL    738
.................... 	ClosePort(1); 
2A5A:  MOV     #1,W4
2A5C:  MOV     W4,9BA
2A5E:  CALL    EC4
.................... 	delay_ms(5000); 
2A62:  MOV     #1388,W0
2A64:  CALL    738
.................... } 
2A68:  MOV     [--W15],W5
2A6A:  RETURN  
....................  
.................... /***********CreateAlert*********************************** 
.................... **   Description: Connects to server to report the      ** 
.................... **     current alert detected by the device             ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void CreateAlert(int Id, int type) 
.................... { 
*
2504:  MOV     W5,[W15++]
2506:  CLR     9AA
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
2508:  CLR.B   9C2
250A:  MOV     #818,W4
250C:  MOV     W4,9BE
250E:  MOV     #15E,W4
2510:  MOV     W4,9C0
2512:  CALL    A28
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
2516:  MOV     #0,W1
2518:  MOV     W1,W0
251A:  CALL    1A4
251E:  INC     W1,W1
2520:  MOV     W1,[W15++]
2522:  BTSC.B  20F.1
2524:  BRA     2522
2526:  MOV     W0,210
2528:  MOV     [--W15],W1
252A:  MOV     #A,W0
252C:  CPSGT   W1,W0
252E:  BRA     2518
.................... 	ReadBuffer(InputBuffer); 
2530:  MOV     #818,W4
2532:  MOV     W4,9BE
2534:  CALL    A48
.................... 	PrintBuffer(InputBuffer,ptime); 
2538:  MOV     #818,W4
253A:  MOV     W4,9B0
253C:  PUSH    976
253E:  POP     9B2
2540:  CALL    A8E
.................... 	if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
2544:  MOV     #1E,W4
2546:  MOV     W4,9BC
2548:  MOV     #818,W4
254A:  MOV     W4,9BA
254C:  CALL    AC8
2550:  MOV     W0,W5
2552:  CP      W5,#1
2554:  BRA     NZ,2570
2556:  MOV     #0,W5
2558:  MOV     W5,W0
255A:  CALL    136
255E:  IOR.B   #0,W0L
2560:  BTSC.B  42.1
2562:  BRA     256E
2564:  INC     W5,W5
2566:  MOV.B   W0L,9BC
2568:  CALL    9DC
256C:  BRA     2558
.................... 	else lcd_putc("\fCMD BAD"); 
256E:  BRA     2588
2570:  MOV     #0,W5
2572:  MOV     W5,W0
2574:  CALL    14A
2578:  IOR.B   #0,W0L
257A:  BTSC.B  42.1
257C:  BRA     2588
257E:  INC     W5,W5
2580:  MOV.B   W0L,9BC
2582:  CALL    9DC
2586:  BRA     2572
.................... 	delay_ms(ptime); 
2588:  MOV     976,W0
258A:  CALL    738
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
258E:  CLR.B   9C2
2590:  MOV     #818,W4
2592:  MOV     W4,9BE
2594:  MOV     #15E,W4
2596:  MOV     W4,9C0
2598:  CALL    A28
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
259C:  MOV     #0,W1
259E:  MOV     W1,W0
25A0:  CALL    1BC
25A4:  INC     W1,W1
25A6:  MOV     W1,[W15++]
25A8:  BTSC.B  20F.1
25AA:  BRA     25A8
25AC:  MOV     W0,210
25AE:  MOV     [--W15],W1
25B0:  MOV     #30,W0
25B2:  CPSGT   W1,W0
25B4:  BRA     259E
.................... 	ReadBuffer(InputBuffer); 
25B6:  MOV     #818,W4
25B8:  MOV     W4,9BE
25BA:  CALL    A48
.................... 	PrintBuffer(InputBuffer,ptime); 
25BE:  MOV     #818,W4
25C0:  MOV     W4,9B0
25C2:  PUSH    976
25C4:  POP     9B2
25C6:  CALL    A8E
.................... 	if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
25CA:  MOV     #1E,W4
25CC:  MOV     W4,9BC
25CE:  MOV     #818,W4
25D0:  MOV     W4,9BA
25D2:  CALL    AC8
25D6:  MOV     W0,W5
25D8:  CP      W5,#1
25DA:  BRA     NZ,25F6
25DC:  MOV     #0,W5
25DE:  MOV     W5,W0
25E0:  CALL    136
25E4:  IOR.B   #0,W0L
25E6:  BTSC.B  42.1
25E8:  BRA     25F4
25EA:  INC     W5,W5
25EC:  MOV.B   W0L,9BC
25EE:  CALL    9DC
25F2:  BRA     25DE
.................... 	else lcd_putc("\fCMD BAD"); 
25F4:  BRA     260E
25F6:  MOV     #0,W5
25F8:  MOV     W5,W0
25FA:  CALL    14A
25FE:  IOR.B   #0,W0L
2600:  BTSC.B  42.1
2602:  BRA     260E
2604:  INC     W5,W5
2606:  MOV.B   W0L,9BC
2608:  CALL    9DC
260C:  BRA     25F8
.................... 	delay_ms(ptime); 
260E:  MOV     976,W0
2610:  CALL    738
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer /monitoringgprs/create?id=14&status=0&current=1&voltage=2 
2614:  CLR.B   9C2
2616:  MOV     #818,W4
2618:  MOV     W4,9BE
261A:  MOV     #15E,W4
261C:  MOV     W4,9C0
261E:  CALL    A28
.................... 	printf("GET /ALERTGPRS/CREATE?ID=%d&TYPE=%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id,type); 
2622:  MOV     #0,W1
2624:  MOV     W1,W0
2626:  CALL    5D8
262A:  INC     W1,W1
262C:  MOV     W1,[W15++]
262E:  BTSC.B  20F.1
2630:  BRA     262E
2632:  MOV     W0,210
2634:  MOV     [--W15],W1
2636:  MOV     #18,W0
2638:  CPSGT   W1,W0
263A:  BRA     2624
263C:  MOV     9A6,W0
263E:  MOV     #0,W4
2640:  CALL    D54
2644:  MOV     #1B,W1
2646:  MOV     W1,W0
2648:  CALL    5D8
264C:  INC     W1,W1
264E:  MOV     W1,[W15++]
2650:  BTSC.B  20F.1
2652:  BRA     2650
2654:  MOV     W0,210
2656:  MOV     [--W15],W1
2658:  MOV     #20,W0
265A:  CPSGT   W1,W0
265C:  BRA     2646
265E:  MOV     9A8,W0
2660:  MOV     #0,W4
2662:  CALL    D54
2666:  MOV     #23,W1
2668:  MOV     W1,W0
266A:  CALL    5D8
266E:  INC     W1,W1
2670:  MOV     W1,[W15++]
2672:  BTSC.B  20F.1
2674:  BRA     2672
2676:  MOV     W0,210
2678:  MOV     [--W15],W1
267A:  MOV     #4F,W0
267C:  CPSGT   W1,W0
267E:  BRA     2668
.................... 	while(getc()!='\n'); 
2680:  BTSS.B  20E.0
2682:  BRA     2680
2684:  MOV     212,W0
2686:  CP.B    W0L,#A
2688:  BRA     NZ,2680
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
268A:  MOV     #818,W4
268C:  MOV     9AA,W3
268E:  ADD     W3,W4,W5
2690:  BTSS.B  20E.0
2692:  BRA     2690
2694:  MOV     212,W0
2696:  MOV.B   W0L,[W5]
.................... 		index++; 
2698:  INC     09AA
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
269A:  MOV     9AA,W4
269C:  MOV     #15E,W3
269E:  CP      W3,W4
26A0:  BRA     LE,26B0
26A2:  MOV     9AA,W4
26A4:  SUB     W4,#1,W5
26A6:  MOV     #818,W4
26A8:  ADD     W5,W4,W0
26AA:  MOV.B   [W0],W4L
26AC:  XOR.B   #24,W4L
26AE:  BRA     NZ,268A
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
26B0:  MOV     #32,W0
26B2:  CALL    738
.................... 	printf("+++\r\n"); 
26B6:  MOV     #0,W1
26B8:  MOV     W1,W0
26BA:  CALL    62A
26BE:  INC     W1,W1
26C0:  MOV     W1,[W15++]
26C2:  BTSC.B  20F.1
26C4:  BRA     26C2
26C6:  MOV     W0,210
26C8:  MOV     [--W15],W1
26CA:  MOV     #4,W0
26CC:  CPSGT   W1,W0
26CE:  BRA     26B8
.................... 	OERR=16; 
26D0:  MOV.B   #10,W0L
26D2:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	PrintBuffer(InputBuffer,1000); 
26D4:  MOV     #818,W4
26D6:  MOV     W4,9B0
26D8:  MOV     #3E8,W4
26DA:  MOV     W4,9B2
26DC:  CALL    A8E
....................  
.................... 	ClosePort(1); 
26E0:  MOV     #1,W4
26E2:  MOV     W4,9BA
26E4:  CALL    EC4
.................... } 
26E8:  MOV     [--W15],W5
26EA:  RETURN  
.................... /***********Read ADC************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int16 ReadADC(int channel,int delay, int16 samples) 
.................... { 
*
1F84:  CLR     9AC
1F86:  CLR     9AE
.................... 	int sample=0; 
.................... 	int16 measure=0; 
.................... 	set_adc_channel(channel); 
1F88:  PUSH    9A6
1F8A:  POP     2A6
.................... 	for(sample=0;sample<samples;sample++)	 
1F8C:  CLR     9AC
1F8E:  MOV     9AC,W0
1F90:  MOV     9AA,W4
1F92:  CP      W4,W0
1F94:  BRA     LE,1FAC
.................... 	{ 
.................... 		measure=measure+read_ADC(); 
1F96:  BCLR.B  2A0.0
1F98:  BSET.B  2A0.1
1F9A:  BTSS.B  2A0.0
1F9C:  BRA     1F9A
1F9E:  MOV     280,W0
1FA0:  ADD     9AE
.................... 		delay_us(delay); 
1FA2:  MOV     9A8,W0
1FA4:  CALL    1F72
.................... 	} 
1FA8:  INC     09AC
1FAA:  BRA     1F8E
.................... 	measure=measure/samples; 
1FAC:  MOV     9AE,W4
1FAE:  MOV     9AA,W3
1FB0:  REPEAT  #11
1FB2:  DIV.S   W4,W3
1FB4:  MOV     W0,9AE
.................... return measure;	 
1FB6:  PUSH    9AE
1FB8:  POP     0
.................... } 
1FBA:  RETURN  
....................  
....................  
.................... /******************Global variables***********************/ 
.................... int operation_mode=0,lamp_status=0,lamp_statusw=0,alert_status=0;//,alert_type; 
.................... int port_on=0,port_off=0,port_in=0; //New variables used in new operation mode 
.................... int lamp1=0,lamp2=0; 
.................... int set_point=0,histeresys=0; 
.................... int16 Device_Id=21,loops=0; 
....................  
.................... float current=0,battery=0,temp=0,s1=0,s2=0,reference=0; 
....................  
.................... byte DateTime[6]={0,2,13,8,30,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
*
2C1C:  MOV     #200,W4
2C1E:  MOV     W4,992
2C20:  MOV     #80D,W4
2C22:  MOV     W4,994
2C24:  MOV     #1E,W4
2C26:  MOV     W4,996
.................... //byte RiseTime[6]={25,2,13,19,27,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
.................... //byte SetTime[6]={25,2,13,19,29,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
.................... byte dow1=0; 
....................  
.................... /*struct ADC_Channels 
.................... { 
.................... 	float value; 
.................... 	char  name[10]; 
.................... 	char  unit[4];	 
....................  
.................... }ADC_Channels[7];*/ 
....................  
.................... //new datetime variables for new operation mode 
.................... byte OnTime[6]={25,2,13,19,27,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
2C28:  MOV     #219,W4
2C2A:  MOV     W4,99A
2C2C:  MOV     #130D,W4
2C2E:  MOV     W4,99C
2C30:  MOV     #1B,W4
2C32:  MOV     W4,99E
.................... byte OffTime[6]={25,2,13,19,29,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
2C34:  MOV     #219,W4
2C36:  MOV     W4,9A0
2C38:  MOV     #130D,W4
2C3A:  MOV     W4,9A2
2C3C:  MOV     #1D,W4
2C3E:  MOV     W4,9A4
....................  
.................... /******************Main function, program****************/ 
.................... void main(void) 
.................... {	 
*
2A6C:  BSET.B  81.7
2A6E:  MOV     #8000,W4
2A70:  MOV     W4,20C
2A72:  MOV     #400,W4
2A74:  MOV     W4,20E
2A76:  MOV     #3,W4
2A78:  MOV     W4,214
2A7A:  MOV     #64,W4
2A7C:  MOV     W4,976
2A7E:  CLR     978
2A80:  CLR     97A
2A82:  CLR     97C
2A84:  CLR     97E
2A86:  CLR     980
2A88:  CLR     982
2A8A:  CLR     984
2A8C:  CLR     986
2A8E:  CLR     988
2A90:  CLR     98A
2A92:  CLR     98C
2A94:  MOV     #15,W4
2A96:  MOV     W4,98E
2A98:  CLR     990
2A9A:  CLR     800
2A9C:  CLR     802
2A9E:  CLR     804
2AA0:  CLR     806
2AA2:  CLR     808
2AA4:  CLR     80A
2AA6:  CLR     80C
2AA8:  CLR     80E
2AAA:  CLR     810
2AAC:  CLR     812
2AAE:  CLR     814
2AB0:  CLR     816
2AB2:  CLR.B   998
2AB4:  SETM    2A8
2AB6:  MOV     #F80,W15
2AB8:  MOV     #FFF,W0
2ABA:  MOV     W0,20
2ABC:  NOP     
.................... 	//***Component initializers**** 
.................... 	lcd_init();        //LCD INITIALIZE 
*
2C40:  CALL    86A
.................... 	//init_dac();      //MPC4921 DAC INITIALIZE 
.................... 	rtc_init();		   //DS1302 RTC INITIALIZE 
2C44:  CALL    96E
.................... 	//***Device initialize********* 
.................... 	lcd_putc("\fTelegestion UTCH"); 
2C48:  MOV     #0,W5
2C4A:  MOV     W5,W0
2C4C:  CALL    63C
2C50:  IOR.B   #0,W0L
2C52:  BTSC.B  42.1
2C54:  BRA     2C60
2C56:  INC     W5,W5
2C58:  MOV.B   W0L,9BC
2C5A:  CALL    9DC
2C5E:  BRA     2C4A
.................... 	delay_ms(100); 
2C60:  MOV     #64,W0
2C62:  CALL    738
.................... 	setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN5|sAN6);//*******Setup CH0-CH6 as ADC 
2C66:  MOV     #FF80,W4
2C68:  MOV     W4,2A8
2C6A:  CLR     2A2
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
2C6C:  MOV     #80,W4
2C6E:  MOV     W4,2A4
2C70:  MOV     #80E0,W4
2C72:  MOV     W4,2A0
.................... 	//******Configure PORTB*********** 
.................... 	SET_TRIS_B(0x007F);   //PB0-PB6 as input, PB7-PB15 as output 
2C74:  MOV     #7F,W4
2C76:  MOV     W4,2C6
.................... 	//******Clear RS232 error********** 
.................... 	OERR=16; 
2C78:  MOV.B   #10,W0L
2C7A:  MOV.B   W0L,20E
.................... 	//******Configure GPRS device****** 
.................... 	ConfigureGPRS();	 
2C7C:  CALL    B02
.................... 	//******Set datetime***************** 
.................... 	switch(ConfigureDatetime(Device_Id, DateTime)) 
.................... 	{ 
2C80:  PUSH    98E
2C82:  POP     9A6
2C84:  MOV     #992,W4
2C86:  MOV     W4,9A8
2C88:  CALL    F0E
2C8C:  XOR     #0,W0
2C8E:  BRA     Z,2C96
2C90:  XOR     #1,W0
2C92:  BRA     Z,2CB0
2C94:  BRA     2D66
.................... 		case 0: 
.................... 			lcd_putc("\fCMD BAD"); 
2C96:  MOV     #0,W5
2C98:  MOV     W5,W0
2C9A:  CALL    14A
2C9E:  IOR.B   #0,W0L
2CA0:  BTSC.B  42.1
2CA2:  BRA     2CAE
2CA4:  INC     W5,W5
2CA6:  MOV.B   W0L,9BC
2CA8:  CALL    9DC
2CAC:  BRA     2C98
.................... 		break; 
2CAE:  BRA     2D80
.................... 		case 1: 
.................... 			rtc_set_datetime(DateTime[day_],DateTime[month_],DateTime[year_],dow1,DateTime[hour_],DateTime[min_]); 
2CB0:  MOV.B   992,W0L
2CB2:  MOV.B   W0L,9A6
2CB4:  MOV.B   993,W0L
2CB6:  MOV.B   W0L,9A7
2CB8:  MOV.B   994,W0L
2CBA:  MOV.B   W0L,9A8
2CBC:  MOV.B   998,W0L
2CBE:  MOV.B   W0L,9A9
2CC0:  MOV.B   995,W0L
2CC2:  MOV.B   W0L,9AA
2CC4:  MOV.B   996,W0L
2CC6:  MOV.B   W0L,9AB
2CC8:  CALL    10BA
.................... 			lcd_putc("\f"); 
2CCC:  MOV     #0,W5
2CCE:  MOV     W5,W0
2CD0:  CALL    110
2CD4:  IOR.B   #0,W0L
2CD6:  BTSC.B  42.1
2CD8:  BRA     2CE4
2CDA:  INC     W5,W5
2CDC:  MOV.B   W0L,9BC
2CDE:  CALL    9DC
2CE2:  BRA     2CCE
.................... 			lcd_putc("Datetime:\n"); 
2CE4:  MOV     #0,W5
2CE6:  MOV     W5,W0
2CE8:  CALL    65A
2CEC:  IOR.B   #0,W0L
2CEE:  BTSC.B  42.1
2CF0:  BRA     2CFC
2CF2:  INC     W5,W5
2CF4:  MOV.B   W0L,9BC
2CF6:  CALL    9DC
2CFA:  BRA     2CE6
.................... 			printf(lcd_putc,"%d/%d/20%d %02d:%02d",DateTime[day_],DateTime[month_],DateTime[year_],DateTime[hour_],DateTime[min_]); 
2CFC:  MOV.B   992,W0L
2CFE:  SE      W0,W0
2D00:  MOV     #0,W4
2D02:  CALL    1158
2D06:  MOV.B   #2F,W0L
2D08:  MOV.B   W0L,9BC
2D0A:  CALL    9DC
2D0E:  MOV.B   993,W0L
2D10:  SE      W0,W0
2D12:  MOV     #0,W4
2D14:  CALL    1158
2D18:  MOV.B   #2F,W0L
2D1A:  MOV.B   W0L,9BC
2D1C:  CALL    9DC
2D20:  MOV.B   #32,W0L
2D22:  MOV.B   W0L,9BC
2D24:  CALL    9DC
2D28:  MOV.B   #30,W0L
2D2A:  MOV.B   W0L,9BC
2D2C:  CALL    9DC
2D30:  MOV.B   994,W0L
2D32:  SE      W0,W0
2D34:  MOV     #0,W4
2D36:  CALL    1158
2D3A:  MOV.B   #20,W0L
2D3C:  MOV.B   W0L,9BC
2D3E:  CALL    9DC
2D42:  MOV.B   995,W0L
2D44:  SE      W0,W0
2D46:  MOV     #8002,W4
2D48:  CALL    1158
2D4C:  MOV.B   #3A,W0L
2D4E:  MOV.B   W0L,9BC
2D50:  CALL    9DC
2D54:  MOV.B   996,W0L
2D56:  SE      W0,W0
2D58:  MOV     #8002,W4
2D5A:  CALL    1158
.................... 			delay_ms(LCD_Delay); 
2D5E:  MOV     #3E8,W0
2D60:  CALL    738
.................... 		break; 
2D64:  BRA     2D80
.................... 		default: 
.................... 			lcd_putc("\fCMD BAD"); 
2D66:  MOV     #0,W5
2D68:  MOV     W5,W0
2D6A:  CALL    14A
2D6E:  IOR.B   #0,W0L
2D70:  BTSC.B  42.1
2D72:  BRA     2D7E
2D74:  INC     W5,W5
2D76:  MOV.B   W0L,9BC
2D78:  CALL    9DC
2D7C:  BRA     2D68
.................... 		break; 
2D7E:  BRA     2D80
....................  
.................... 	} 
.................... 	//ClosePort(1); 
.................... 	//***While loop, main program starts here*** 
.................... 	while(TRUE) 
.................... 	{//*****Start of while loop**************        
.................... 		for(loops=0;loops<2;loops++) 
2D80:  CLR     990
2D82:  MOV     990,W4
2D84:  CP      W4,#2
2D86:  BRA     GE,3412
.................... 		{//*****Start of for loop************** 
.................... 			//**********BUZZER******************** 
.................... 			output_bit(PIN_D9,alert_status);  //BUZZER depend of alert state 
2D88:  CP0     97E
2D8A:  BRA     NZ,2D90
2D8C:  BCLR.B  2D7.1
2D8E:  BRA     2D92
2D90:  BSET.B  2D7.1
2D92:  BCLR.B  2D3.1
.................... 			//**********GPO*********************** 
.................... 			//******Get status/mode*********************** 
.................... 			lcd_putc("\fGetting data\nfrom server.+."); 
2D94:  MOV     #0,W5
2D96:  MOV     W5,W0
2D98:  CALL    672
2D9C:  IOR.B   #0,W0L
2D9E:  BTSC.B  42.1
2DA0:  BRA     2DAC
2DA2:  INC     W5,W5
2DA4:  MOV.B   W0L,9BC
2DA6:  CALL    9DC
2DAA:  BRA     2D96
.................... 			GetMode(Device_Id,&operation_mode,&lamp_statusw);	 
2DAC:  PUSH    98E
2DAE:  POP     9A6
2DB0:  MOV     #978,W4
2DB2:  MOV     W4,9A8
2DB4:  MOV     #97C,W4
2DB6:  MOV     W4,9AA
2DB8:  CALL    1252
.................... 			delay_ms(LCD_Delay);		 
2DBC:  MOV     #3E8,W0
2DBE:  CALL    738
.................... 			switch(operation_mode) 
.................... 			{ 
2DC2:  MOV     978,W0
2DC4:  XOR     #1,W0
2DC6:  BRA     Z,2DD2
2DC8:  XOR     #2,W0
2DCA:  BRA     Z,2E54
2DCC:  XOR     #1,W0
2DCE:  BRA     Z,2F54
2DD0:  BRA     2F68
.................... 				case Timmer_Mode: 
.................... 					GetOnTime(Device_Id,OnTime); 
2DD2:  PUSH    98E
2DD4:  POP     9A6
2DD6:  MOV     #99A,W4
2DD8:  MOV     W4,9A8
2DDA:  CALL    1456
.................... 					GetOffTime(Device_Id,OffTime); 
2DDE:  PUSH    98E
2DE0:  POP     9A6
2DE2:  MOV     #9A0,W4
2DE4:  MOV     W4,9A8
2DE6:  CALL    15BA
.................... 					GetPort(Device_Id,&port_on,&port_off,&port_in); 
2DEA:  PUSH    98E
2DEC:  POP     9A6
2DEE:  MOV     #980,W4
2DF0:  MOV     W4,9A8
2DF2:  MOV     #982,W4
2DF4:  MOV     W4,9AA
2DF6:  MOV     #984,W4
2DF8:  MOV     W4,9AC
2DFA:  CALL    1724
.................... 					if(DateTime[hour_]==OnTime[hour_]&&((DateTime[min_]>=(OnTime[min_]-1))&&(DateTime[min_]<=(OnTime[min_]+1)))) lamp_status=port_on; 
2DFE:  MOV.B   995,W0L
2E00:  CP.B    99D
2E02:  BRA     NZ,2E22
2E04:  MOV     99E,W4
2E06:  SUB.B   W4L,#1,W0L
2E08:  MOV     996,W4
2E0A:  CP.B    W4L,W0L
2E0C:  BRA     NC,2E22
2E0E:  MOV     99E,W4
2E10:  ADD.B   W4L,#1,W4L
2E12:  MOV.B   W4L,W0L
2E14:  MOV.B   W0L,0
2E16:  MOV     996,W4
2E18:  CP.B    W4L,W0L
2E1A:  BRA     GTU,2E22
2E1C:  PUSH    980
2E1E:  POP     97A
.................... 					else if(DateTime[hour_]==OffTime[hour_]&&((DateTime[min_]>=(OffTime[min_]-1))&&(DateTime[min_]<=(OffTime[min_]+1)))) lamp_status=port_off; 
2E20:  BRA     2E44
2E22:  MOV.B   995,W0L
2E24:  CP.B    9A3
2E26:  BRA     NZ,2E44
2E28:  MOV     9A4,W4
2E2A:  SUB.B   W4L,#1,W0L
2E2C:  MOV     996,W4
2E2E:  CP.B    W4L,W0L
2E30:  BRA     NC,2E44
2E32:  MOV     9A4,W4
2E34:  ADD.B   W4L,#1,W4L
2E36:  MOV.B   W4L,W0L
2E38:  MOV.B   W0L,0
2E3A:  MOV     996,W4
2E3C:  CP.B    W4L,W0L
2E3E:  BRA     GTU,2E44
2E40:  PUSH    982
2E42:  POP     97A
.................... 					//else lamp_status=0; 
.................... 					lamp1= (lamp_status&0x01); lamp2=(lamp_status&0x02)>>1; 
2E44:  MOV     97A,W0
2E46:  AND     W0,#1,W0
2E48:  MOV     W0,986
2E4A:  MOV     97A,W0
2E4C:  AND     W0,#2,W5
2E4E:  MOV     W5,988
2E50:  LSR     988
.................... 				break;	 
2E52:  BRA     2F6A
.................... 				case Automated_Mode: 
.................... 					GetAutomated(Device_Id,&set_point,&histeresys); 
2E54:  PUSH    98E
2E56:  POP     9A6
2E58:  MOV     #98A,W4
2E5A:  MOV     W4,9A8
2E5C:  MOV     #98C,W4
2E5E:  MOV     W4,9AA
2E60:  CALL    19D2
.................... 					delay_ms(300); 
2E64:  MOV     #12C,W0
2E66:  CALL    738
.................... 					GetPort(Device_Id,&port_on,&port_off,&port_in); 
2E6A:  PUSH    98E
2E6C:  POP     9A6
2E6E:  MOV     #980,W4
2E70:  MOV     W4,9A8
2E72:  MOV     #982,W4
2E74:  MOV     W4,9AA
2E76:  MOV     #984,W4
2E78:  MOV     W4,9AC
2E7A:  CALL    1724
.................... 					if(S1>set_point+histeresys) lamp_status=port_on; 
2E7E:  MOV     98A,W0
2E80:  ADD     98C,W0
2E82:  CALL    1BD6
2E86:  MOV     80C,W2
2E88:  MOV     80E,W3
2E8A:  CALL    1C20
2E8E:  BRA     NC,2E96
2E90:  PUSH    980
2E92:  POP     97A
.................... 					else if(S1<set_point-histeresys) lamp_status=port_off; 
2E94:  BRA     2F44
2E96:  MOV     98A,W4
2E98:  MOV     98C,W3
2E9A:  SUB     W4,W3,W0
2E9C:  CALL    1BD6
2EA0:  MOV     W0,W2
2EA2:  MOV     W1,W3
2EA4:  MOV     80C,W0
2EA6:  MOV     80E,W1
2EA8:  CALL    1C20
2EAC:  BRA     NC,2EB4
2EAE:  PUSH    982
2EB0:  POP     97A
.................... 					else if((S1<set_point+0.9)&&(S1>set_point-0.9)) lamp_status=port_off;	 
2EB2:  BRA     2F44
2EB4:  MOV     98A,W5
2EB6:  MOV     W5,W0
2EB8:  CLR     W3
2EBA:  BTSC    W0.F
2EBC:  SETM    W3
2EBE:  MOV     W3,W1
2EC0:  MOV     W3,W2
2EC2:  CALL    1C88
2EC6:  BCLR.B  43.0
2EC8:  MOV     W5,[W15++]
2ECA:  MOV     #CCCD,W4
2ECC:  MOV     #CCCC,W5
2ECE:  MOV     #CCCC,W6
2ED0:  MOV     #3FEC,W7
2ED2:  CALL    1CEC
2ED6:  MOV     [--W15],W5
2ED8:  MOV     80C,W5
2EDA:  MOV     80E,W6
2EDC:  CLR     W8
2EDE:  BTSC    W6.F
2EE0:  SETM    W8
2EE2:  MOV     W8,W7
2EE4:  MOV     W5,[W15++]
2EE6:  MOV     W0,W4
2EE8:  MOV     W5,W0
2EEA:  MOV     W1,W5
2EEC:  MOV     W6,W1
2EEE:  MOV     W2,W6
2EF0:  MOV     W7,W2
2EF2:  MOV     W3,W7
2EF4:  MOV     W8,W3
2EF6:  CALL    1EC8
2EFA:  MOV     [--W15],W5
2EFC:  BRA     NC,2F44
2EFE:  MOV     98A,W5
2F00:  MOV     W5,W0
2F02:  CLR     W3
2F04:  BTSC    W0.F
2F06:  SETM    W3
2F08:  MOV     W3,W1
2F0A:  MOV     W3,W2
2F0C:  CALL    1C88
2F10:  BSET.B  43.0
2F12:  MOV     W5,[W15++]
2F14:  MOV     #CCCD,W4
2F16:  MOV     #CCCC,W5
2F18:  MOV     #CCCC,W6
2F1A:  MOV     #3FEC,W7
2F1C:  CALL    1CEC
2F20:  MOV     [--W15],W5
2F22:  MOV     80C,W5
2F24:  MOV     80E,W6
2F26:  CLR     W8
2F28:  BTSC    W6.F
2F2A:  SETM    W8
2F2C:  MOV     W8,W7
2F2E:  MOV     W5,[W15++]
2F30:  MOV     W5,W4
2F32:  MOV     W6,W5
2F34:  MOV     W7,W6
2F36:  MOV     W8,W7
2F38:  CALL    1EC8
2F3C:  MOV     [--W15],W5
2F3E:  BRA     NC,2F44
2F40:  PUSH    982
2F42:  POP     97A
.................... 					lamp1= (lamp_status&0x01); lamp2=(lamp_status&0x02)>>1;				 
2F44:  MOV     97A,W0
2F46:  AND     W0,#1,W0
2F48:  MOV     W0,986
2F4A:  MOV     97A,W0
2F4C:  AND     W0,#2,W5
2F4E:  MOV     W5,988
2F50:  LSR     988
.................... 				break;	 
2F52:  BRA     2F6A
.................... 				case Manual_Mode: 
.................... 					lamp_status=lamp_statusw; 
2F54:  PUSH    97C
2F56:  POP     97A
.................... 					lamp1= (lamp_status&0x01); lamp2=(lamp_status&0x02)>>1; 
2F58:  MOV     97A,W0
2F5A:  AND     W0,#1,W0
2F5C:  MOV     W0,986
2F5E:  MOV     97A,W0
2F60:  AND     W0,#2,W5
2F62:  MOV     W5,988
2F64:  LSR     988
.................... 				break;	 
2F66:  BRA     2F6A
.................... 				default: 
.................... 				break; 
2F68:  BRA     2F6A
.................... 			}						 
.................... 			output_bit(PIN_B7,lamp1);	output_bit(PIN_B8,lamp2);					 
2F6A:  CP0     986
2F6C:  BRA     NZ,2F72
2F6E:  BCLR.B  2CA.7
2F70:  BRA     2F74
2F72:  BSET.B  2CA.7
2F74:  MOV     #7E,W4
2F76:  MOV     W4,2C6
2F78:  CP0     988
2F7A:  BRA     NZ,2F80
2F7C:  BCLR.B  2CB.0
2F7E:  BRA     2F82
2F80:  BSET.B  2CB.0
2F82:  MOV     #7E,W4
2F84:  MOV     W4,2C6
.................... 			//******RTC Get and show datetime***** 
.................... 			lcd_putc("\f"); 
2F86:  MOV     #0,W5
2F88:  MOV     W5,W0
2F8A:  CALL    110
2F8E:  IOR.B   #0,W0L
2F90:  BTSC.B  42.1
2F92:  BRA     2F9E
2F94:  INC     W5,W5
2F96:  MOV.B   W0L,9BC
2F98:  CALL    9DC
2F9C:  BRA     2F88
.................... 			lcd_putc("Datetime:\n"); 
2F9E:  MOV     #0,W5
2FA0:  MOV     W5,W0
2FA2:  CALL    65A
2FA6:  IOR.B   #0,W0L
2FA8:  BTSC.B  42.1
2FAA:  BRA     2FB6
2FAC:  INC     W5,W5
2FAE:  MOV.B   W0L,9BC
2FB0:  CALL    9DC
2FB4:  BRA     2FA0
.................... 			rtc_get_date(DateTime[day_],DateTime[month_],DateTime[year_],dow1); 
.................... 			rtc_get_time(DateTime[hour_],DateTime[min_],DateTime[sec_]); 
.................... 			printf(lcd_putc,"%d/%d/20%d %02d:%02d",DateTime[day_],DateTime[month_],DateTime[year_],DateTime[hour_],DateTime[min_]); 
*
3050:  MOV.B   992,W0L
3052:  SE      W0,W0
3054:  MOV     #0,W4
3056:  CALL    1158
305A:  MOV.B   #2F,W0L
305C:  MOV.B   W0L,9BC
305E:  CALL    9DC
3062:  MOV.B   993,W0L
3064:  SE      W0,W0
3066:  MOV     #0,W4
3068:  CALL    1158
306C:  MOV.B   #2F,W0L
306E:  MOV.B   W0L,9BC
3070:  CALL    9DC
3074:  MOV.B   #32,W0L
3076:  MOV.B   W0L,9BC
3078:  CALL    9DC
307C:  MOV.B   #30,W0L
307E:  MOV.B   W0L,9BC
3080:  CALL    9DC
3084:  MOV.B   994,W0L
3086:  SE      W0,W0
3088:  MOV     #0,W4
308A:  CALL    1158
308E:  MOV.B   #20,W0L
3090:  MOV.B   W0L,9BC
3092:  CALL    9DC
3096:  MOV.B   995,W0L
3098:  SE      W0,W0
309A:  MOV     #8002,W4
309C:  CALL    1158
30A0:  MOV.B   #3A,W0L
30A2:  MOV.B   W0L,9BC
30A4:  CALL    9DC
30A8:  MOV.B   996,W0L
30AA:  SE      W0,W0
30AC:  MOV     #8002,W4
30AE:  CALL    1158
.................... 			delay_ms(LCD_Delay); 
30B2:  MOV     #3E8,W0
30B4:  CALL    738
....................  
.................... 			//******Get and show status/mode******* 
.................... 			lcd_putc("\f"); 
30B8:  MOV     #0,W5
30BA:  MOV     W5,W0
30BC:  CALL    110
30C0:  IOR.B   #0,W0L
30C2:  BTSC.B  42.1
30C4:  BRA     30D0
30C6:  INC     W5,W5
30C8:  MOV.B   W0L,9BC
30CA:  CALL    9DC
30CE:  BRA     30BA
.................... 			printf(lcd_putc,"Mode: %d\nStatus: %d",operation_mode,lamp_status); 
30D0:  MOV     #0,W1
30D2:  MOV     W1,W0
30D4:  CALL    69C
30D8:  INC     W1,W1
30DA:  MOV     W1,[W15++]
30DC:  MOV.B   W0L,9BC
30DE:  CALL    9DC
30E2:  MOV     [--W15],W1
30E4:  MOV     #5,W0
30E6:  CPSGT   W1,W0
30E8:  BRA     30D2
30EA:  MOV     978,W0
30EC:  MOV     #0,W4
30EE:  CALL    1158
30F2:  MOV     #8,W1
30F4:  MOV     W1,W0
30F6:  CALL    69C
30FA:  INC     W1,W1
30FC:  MOV     W1,[W15++]
30FE:  MOV.B   W0L,9BC
3100:  CALL    9DC
3104:  MOV     [--W15],W1
3106:  MOV     #10,W0
3108:  CPSGT   W1,W0
310A:  BRA     30F4
310C:  MOV     97A,W0
310E:  MOV     #0,W4
3110:  CALL    1158
.................... 			delay_ms(LCD_Delay); 
3114:  MOV     #3E8,W0
3116:  CALL    738
....................  
.................... 			//******Get and show ADC values*** 
.................... 			temp=ReadADC(TEMP_ch,100,10); 
311A:  CLR     9A6
311C:  MOV     #64,W4
311E:  MOV     W4,9A8
3120:  MOV     #A,W4
3122:  MOV     W4,9AA
3124:  CALL    1F84
3128:  CALL    1BD6
312C:  MOV     W0,808
312E:  MOV     W1,80A
.................... 			current=ReadADC(CURRENT_ch,100,10); 
3130:  MOV     #1,W4
3132:  MOV     W4,9A6
3134:  MOV     #64,W4
3136:  MOV     W4,9A8
3138:  MOV     #A,W4
313A:  MOV     W4,9AA
313C:  CALL    1F84
3140:  CALL    1BD6
3144:  MOV     W0,800
3146:  MOV     W1,802
.................... 			s1=ReadADC(SENSOR1_ch,100,10); 
3148:  MOV     #3,W4
314A:  MOV     W4,9A6
314C:  MOV     #64,W4
314E:  MOV     W4,9A8
3150:  MOV     #A,W4
3152:  MOV     W4,9AA
3154:  CALL    1F84
3158:  CALL    1BD6
315C:  MOV     W0,80C
315E:  MOV     W1,80E
.................... 			s2=ReadADC(SENSOR2_ch,100,10); 
3160:  MOV     #4,W4
3162:  MOV     W4,9A6
3164:  MOV     #64,W4
3166:  MOV     W4,9A8
3168:  MOV     #A,W4
316A:  MOV     W4,9AA
316C:  CALL    1F84
3170:  CALL    1BD6
3174:  MOV     W0,810
3176:  MOV     W1,812
.................... 			reference=ReadADC(REFERENCE_ch,100,10); 
3178:  MOV     #6,W4
317A:  MOV     W4,9A6
317C:  MOV     #64,W4
317E:  MOV     W4,9A8
3180:  MOV     #A,W4
3182:  MOV     W4,9AA
3184:  CALL    1F84
3188:  CALL    1BD6
318C:  MOV     W0,814
318E:  MOV     W1,816
.................... 			battery=ReadADC(POWER_ch,100,10); 
3190:  MOV     #5,W4
3192:  MOV     W4,9A6
3194:  MOV     #64,W4
3196:  MOV     W4,9A8
3198:  MOV     #A,W4
319A:  MOV     W4,9AA
319C:  CALL    1F84
31A0:  CALL    1BD6
31A4:  MOV     W0,804
31A6:  MOV     W1,806
....................  
.................... 			reference=0.412/reference; 
31A8:  MOV     #F1AA,W0
31AA:  MOV     #3ED2,W1
31AC:  MOV     814,W2
31AE:  MOV     816,W3
31B0:  CALL    1FBC
31B4:  MOV     W0,814
31B6:  MOV     W1,816
.................... 			temp=(temp*reference)*1000; 
31B8:  MOV     808,W0
31BA:  MOV     80A,W1
31BC:  MOV     814,W2
31BE:  MOV     816,W3
31C0:  CALL    2086
31C4:  MOV     W0,W5
31C6:  MOV     W1,W6
31C8:  MOV     W5,W0
31CA:  MOV     W6,W1
31CC:  MOV     #0,W2
31CE:  MOV     #447A,W3
31D0:  CALL    2086
31D4:  MOV     W0,808
31D6:  MOV     W1,80A
.................... 			current=(current*reference)*8; 
31D8:  MOV     800,W0
31DA:  MOV     802,W1
31DC:  MOV     814,W2
31DE:  MOV     816,W3
31E0:  CALL    2086
31E4:  MOV     W0,W5
31E6:  MOV     W1,W6
31E8:  MOV     W5,W0
31EA:  MOV     W6,W1
31EC:  MOV     #0,W2
31EE:  MOV     #4100,W3
31F0:  CALL    2086
31F4:  MOV     W0,800
31F6:  MOV     W1,802
.................... 			battery=(battery*reference)*3.11;	 
31F8:  MOV     804,W0
31FA:  MOV     806,W1
31FC:  MOV     814,W2
31FE:  MOV     816,W3
3200:  CALL    2086
3204:  MOV     W0,W5
3206:  MOV     W1,W6
3208:  MOV     W5,W0
320A:  MOV     W6,W1
320C:  MOV     #A3D,W2
320E:  MOV     #4047,W3
3210:  CALL    2086
3214:  MOV     W0,804
3216:  MOV     W1,806
.................... 			s1=s1*reference/.165; 	//165 Ohms resitor in serie with sensor, (v/165)*1000 (in mA) 
3218:  MOV     80C,W0
321A:  MOV     80E,W1
321C:  MOV     814,W2
321E:  MOV     816,W3
3220:  CALL    2086
3224:  MOV     W0,W5
3226:  MOV     W1,W6
3228:  MOV     W5,W0
322A:  MOV     W6,W1
322C:  MOV     #F5C3,W2
322E:  MOV     #3E28,W3
3230:  CALL    1FBC
3234:  MOV     W0,80C
3236:  MOV     W1,80E
.................... 			s2=s2*reference/.165;	//165 Ohms resitor in serie with sensor, (v/165)*1000 (in mA) 
3238:  MOV     810,W0
323A:  MOV     812,W1
323C:  MOV     814,W2
323E:  MOV     816,W3
3240:  CALL    2086
3244:  MOV     W0,W5
3246:  MOV     W1,W6
3248:  MOV     W5,W0
324A:  MOV     W6,W1
324C:  MOV     #F5C3,W2
324E:  MOV     #3E28,W3
3250:  CALL    1FBC
3254:  MOV     W0,810
3256:  MOV     W1,812
....................  
.................... 			lcd_putc("\f"); 
3258:  MOV     #0,W5
325A:  MOV     W5,W0
325C:  CALL    110
3260:  IOR.B   #0,W0L
3262:  BTSC.B  42.1
3264:  BRA     3270
3266:  INC     W5,W5
3268:  MOV.B   W0L,9BC
326A:  CALL    9DC
326E:  BRA     325A
.................... 			printf(lcd_putc,"Battery= %6.3fV",battery); 
3270:  MOV     #0,W1
3272:  MOV     W1,W0
3274:  CALL    6BC
3278:  INC     W1,W1
327A:  MOV     W1,[W15++]
327C:  MOV.B   W0L,9BC
327E:  CALL    9DC
3282:  MOV     [--W15],W1
3284:  MOV     #8,W0
3286:  CPSGT   W1,W0
3288:  BRA     3272
328A:  MOV     806,W2
328C:  MOV     804,W1
328E:  MOV     #0,W0
3290:  CALL    2144
3294:  MOV     #3,W9
3296:  MOV     #5,W10
3298:  CALL    2382
329C:  MOV.B   #56,W0L
329E:  MOV.B   W0L,9BC
32A0:  CALL    9DC
.................... 			delay_ms(LCD_Delay); 
32A4:  MOV     #3E8,W0
32A6:  CALL    738
.................... 			lcd_putc("\f"); 
32AA:  MOV     #0,W5
32AC:  MOV     W5,W0
32AE:  CALL    110
32B2:  IOR.B   #0,W0L
32B4:  BTSC.B  42.1
32B6:  BRA     32C2
32B8:  INC     W5,W5
32BA:  MOV.B   W0L,9BC
32BC:  CALL    9DC
32C0:  BRA     32AC
.................... 			printf(lcd_putc,"Current: %6.3fA",current);//\nTemperature: %6.3fmV",current,temp);//1.1,1.1);//current,temp); 
32C2:  MOV     #0,W1
32C4:  MOV     W1,W0
32C6:  CALL    6D8
32CA:  INC     W1,W1
32CC:  MOV     W1,[W15++]
32CE:  MOV.B   W0L,9BC
32D0:  CALL    9DC
32D4:  MOV     [--W15],W1
32D6:  MOV     #8,W0
32D8:  CPSGT   W1,W0
32DA:  BRA     32C4
32DC:  MOV     802,W2
32DE:  MOV     800,W1
32E0:  MOV     #0,W0
32E2:  CALL    2144
32E6:  MOV     #3,W9
32E8:  MOV     #5,W10
32EA:  CALL    2382
32EE:  MOV.B   #41,W0L
32F0:  MOV.B   W0L,9BC
32F2:  CALL    9DC
.................... 			delay_ms(LCD_Delay); 
32F6:  MOV     #3E8,W0
32F8:  CALL    738
.................... 			lcd_putc("\f"); 
32FC:  MOV     #0,W5
32FE:  MOV     W5,W0
3300:  CALL    110
3304:  IOR.B   #0,W0L
3306:  BTSC.B  42.1
3308:  BRA     3314
330A:  INC     W5,W5
330C:  MOV.B   W0L,9BC
330E:  CALL    9DC
3312:  BRA     32FE
.................... 			printf(lcd_putc,"Reference= \n%6.3fmV",(reference*1000)); 
3314:  MOV     814,W0
3316:  MOV     816,W1
3318:  MOV     #0,W2
331A:  MOV     #447A,W3
331C:  CALL    2086
3320:  MOV     W0,W5
3322:  MOV     W1,W6
3324:  MOV     #0,W1
3326:  MOV     W1,W0
3328:  CALL    6F4
332C:  INC     W1,W1
332E:  MOV     W1,[W15++]
3330:  MOV.B   W0L,9BC
3332:  CALL    9DC
3336:  MOV     [--W15],W1
3338:  MOV     #B,W0
333A:  CPSGT   W1,W0
333C:  BRA     3326
333E:  MOV     W6,W2
3340:  MOV     W5,W1
3342:  MOV     #0,W0
3344:  CALL    2144
3348:  MOV     #3,W9
334A:  MOV     #5,W10
334C:  CALL    2382
3350:  MOV.B   #6D,W0L
3352:  MOV.B   W0L,9BC
3354:  CALL    9DC
3358:  MOV.B   #56,W0L
335A:  MOV.B   W0L,9BC
335C:  CALL    9DC
.................... 			delay_ms(LCD_Delay); 
3360:  MOV     #3E8,W0
3362:  CALL    738
.................... 			lcd_putc("\f"); 
3366:  MOV     #0,W5
3368:  MOV     W5,W0
336A:  CALL    110
336E:  IOR.B   #0,W0L
3370:  BTSC.B  42.1
3372:  BRA     337E
3374:  INC     W5,W5
3376:  MOV.B   W0L,9BC
3378:  CALL    9DC
337C:  BRA     3368
.................... 			printf(lcd_putc,"S1: %6.3fmA\nS2: %6.3fmA",s1,s2); 
337E:  MOV     #0,W1
3380:  MOV     W1,W0
3382:  CALL    714
3386:  INC     W1,W1
3388:  MOV     W1,[W15++]
338A:  MOV.B   W0L,9BC
338C:  CALL    9DC
3390:  MOV     [--W15],W1
3392:  MOV     #3,W0
3394:  CPSGT   W1,W0
3396:  BRA     3380
3398:  MOV     80E,W2
339A:  MOV     80C,W1
339C:  MOV     #0,W0
339E:  CALL    2144
33A2:  MOV     #3,W9
33A4:  MOV     #5,W10
33A6:  CALL    2382
33AA:  MOV     #9,W1
33AC:  MOV     W1,W0
33AE:  CALL    714
33B2:  INC     W1,W1
33B4:  MOV     W1,[W15++]
33B6:  MOV.B   W0L,9BC
33B8:  CALL    9DC
33BC:  MOV     [--W15],W1
33BE:  MOV     #F,W0
33C0:  CPSGT   W1,W0
33C2:  BRA     33AC
33C4:  MOV     812,W2
33C6:  MOV     810,W1
33C8:  MOV     #0,W0
33CA:  CALL    2144
33CE:  MOV     #3,W9
33D0:  MOV     #5,W10
33D2:  CALL    2382
33D6:  MOV.B   #6D,W0L
33D8:  MOV.B   W0L,9BC
33DA:  CALL    9DC
33DE:  MOV.B   #41,W0L
33E0:  MOV.B   W0L,9BC
33E2:  CALL    9DC
.................... 			delay_ms(LCD_Delay); 
33E6:  MOV     #3E8,W0
33E8:  CALL    738
....................  
.................... 			if(battery<6.3) {alert_status=1; CreateAlert(Device_Id,2);} 
33EC:  MOV     804,W0
33EE:  MOV     806,W1
33F0:  MOV     #999A,W2
33F2:  MOV     #40C9,W3
33F4:  CALL    1C20
33F8:  BRA     NC,340C
33FA:  MOV     #1,W4
33FC:  MOV     W4,97E
33FE:  MOV     #2,W4
3400:  MOV     W4,9A8
3402:  PUSH    98E
3404:  POP     9A6
3406:  CALL    2504
.................... 			else alert_status=0; 
340A:  BRA     340E
340C:  CLR     97E
.................... 		}//*****End of for loop************** 
340E:  INC     0990
3410:  BRA     2D82
.................... 		ReportData(Device_Id,lamp_status);//1,1.1,1.1); 
3412:  PUSH    98E
3414:  POP     9A6
3416:  PUSH    97A
3418:  POP     9A8
341A:  CALL    286E
.................... 	}//*****End of while loop************** 
341E:  BRA     2D80
.................... } 
3420:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C701   NOCKSFSM FRC_PLL4 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 0733   PUT64 NOBROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN NOMCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  
