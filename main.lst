CCS PCD C Compiler, Version 4.104, 5967               05-Aug-15 22:41

               Filename: C:\Users\e882742\Documents\TELEGESTION\dsPIC software\main.lst

               ROM used: 10470 bytes (23%)
                         Largest free fragment is 34586
               RAM used: 548 (27%) at main() level
                         587 (29%) worst case
               Stack:    7 locations

*
0000:  GOTO    2028
.................... /******************Configuration file********************/ 
.................... #include "Config.h" 
.................... #include <30f5015.h> 
.................... //////// Standard Header file for the DSPIC30F5015 device //////////////// 
.................... #device DSPIC30F5015 
.................... #list 
....................  
....................  
.................... #device ADC=10 
.................... #fuses FRC_PLL4, NOWRT, NOPROTECT, NOWDT, NOBROWNOUT, NOMCLR 
.................... #use delay(clock=29480000)  
*
050A:  CP0     W0
050C:  BTSC.B  42.1
050E:  BRA     518
0510:  REPEAT  #1CC3
0512:  NOP     
0514:  DEC     W0,W0
0516:  BRA     50A
0518:  RETURN  
*
151C:  LSR     W0,#0,W0
151E:  CP0     W0
1520:  BTSC.B  42.1
1522:  BRA     152C
1524:  REPEAT  #34
1526:  NOP     
1528:  DEC     W0,W0
152A:  BRA     151E
152C:  RETURN  
.................... #use rs232(baud=115200,bits=8, xmit=PIN_F3,rcv=PIN_F2, parity=N)//, timeout=2000) 
.................... #byte OERR=0x020E 
.................... #USE FIXED_IO(B_OUTPUTS=PIN_B7,PIN_B8) 
....................  
.................... #define Timmer_Mode     1	//new mode  operation 
.................... #define Automated_Mode  3 
.................... #define Manual_Mode     2 
....................  
.................... #define Lamp_On         1 
.................... #define Lamp_Off        0 
....................  
.................... #define day_             0 
.................... #define month_           1 
.................... #define year_            2 
.................... #define hour_            3 
.................... #define min_             4 
.................... #define sec_             5 
....................  
.................... #define RoboCable			0 
.................... #define RoboEnergia			1 
.................... #define LamparaFundida		2 
....................  
.................... #define LCD_Delay			2000 
....................  
.................... #define TEMP_ch				0 
.................... #define CURRENT_ch			1 
.................... #define AN2_ch				2 
.................... #define SENSOR1_ch			3 
.................... #define SENSOR2_ch			4 
.................... #define POWER_ch			5 
.................... #define REFERENCE_ch		6 
....................  
.................... /******************Include files*************************/ 
.................... #include "DS1302_2.c"		//Driver for Real Time Clock  
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////                               DS1302.C                           //// 
.................... ////                     Driver for Real Time Clock                   //// 
.................... ////                                                                  //// 
.................... ////  rtc_init()                                   Call after power up//// 
.................... ////                                                                  //// 
.................... ////  rtc_set_datetime(day,mth,year,dow,hour,min)  Set the date/time  //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_date(day,mth,year,dow)               Get the date       //// 
.................... ////                                                                  //// 
.................... ////  rtc_get_time(hr,min,sec)                     Get the time       //// 
.................... ////                                                                  //// 
.................... ////  rtc_write_nvr(address,data)                  Write to NVR       //// 
.................... ////                                                                  //// 
.................... ////  data = rtc_read_nvr(address)                 Read from NVR      //// 
.................... ////                                                                  //// 
.................... ////  get_bcd(data)                              Convert data to BCD  //// 
.................... ////                                                                  //// 
.................... ////  rm_bcd(data)                               Convert data to int  //// 
.................... ////                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C //// 
.................... //// compiler.  This source code may only be distributed to other     //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction//// 
.................... //// or distribution is permitted without written permission.         //// 
.................... //// Derivative programs created using this software in object code   //// 
.................... //// form are not restricted in any way.                              //// 
.................... ////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef RTC_SCLK 
....................  
.................... #define RTC_SCLK PIN_D5 
.................... #define RTC_IO   PIN_D6 
.................... #define RTC_RST  PIN_D4 
....................  
.................... #endif 
....................  
.................... void write_ds1302_byte(BYTE cmd) { 
....................    BYTE i; 
....................  
....................    for(i=0;i<=7;++i) { 
*
06B8:  CLR.B   9AF
06BA:  MOV     9AE,W4
06BC:  LSR     W4,#8,W4
06BE:  CP.B    W4L,#7
06C0:  BRA     GTU,6DC
....................       output_bit(RTC_IO, shift_right(&cmd,1,0) ); 
06C2:  BCLR.B  42.0
06C4:  RRC.B   9AE
06C6:  BRA     C,6CC
06C8:  BCLR.B  2D6.6
06CA:  BRA     6CE
06CC:  BSET.B  2D6.6
06CE:  BCLR.B  2D2.6
....................       output_high(RTC_SCLK); 
06D0:  BCLR.B  2D2.5
06D2:  BSET.B  2D6.5
....................       output_low(RTC_SCLK); 
06D4:  BCLR.B  2D2.5
06D6:  BCLR.B  2D6.5
....................    } 
06D8:  INC.B   09AF
06DA:  BRA     6BA
.................... } 
06DC:  RETURN  
....................  
.................... void write_ds1302(BYTE cmd, BYTE data) { 
....................  
....................    output_high(RTC_RST); 
06DE:  BCLR.B  2D2.4
06E0:  BSET.B  2D6.4
....................    write_ds1302_byte(cmd); 
06E2:  MOV.B   9AA,W0L
06E4:  MOV.B   W0L,9AE
06E6:  CALL    6B8
....................    write_ds1302_byte(data); 
06EA:  MOV.B   9AB,W0L
06EC:  MOV.B   W0L,9AE
06EE:  CALL    6B8
....................    output_low(RTC_RST); 
06F2:  BCLR.B  2D2.4
06F4:  BCLR.B  2D6.4
.................... } 
06F6:  RETURN  
....................  
.................... BYTE read_ds1302(BYTE cmd) { 
....................    BYTE i,data; 
....................  
....................    output_high(RTC_RST); 
06F8:  BCLR.B  2D2.4
06FA:  BSET.B  2D6.4
....................    write_ds1302_byte(cmd); 
06FC:  MOV.B   9A0,W0L
06FE:  MOV.B   W0L,9AE
0700:  CALL    6B8
....................     
....................    input(RTC_IO); 
0704:  BSET.B  2D2.6
....................    delay_us(1); 
0706:  REPEAT  #5
0708:  NOP     
....................           
....................    for(i=0;i<=7;++i) { 
070A:  CLR.B   9A1
070C:  MOV     9A0,W4
070E:  LSR     W4,#8,W4
0710:  CP.B    W4L,#7
0712:  BRA     GTU,736
....................       shift_right(&data,1,input(RTC_IO)); 
0714:  BSET.B  2D2.6
0716:  BTSC.B  2D4.6
0718:  BRA     71E
071A:  BCLR.B  42.0
071C:  BRA     720
071E:  BSET.B  42.0
0720:  RRC.B   9A2
....................       output_high(RTC_SCLK); 
0722:  BCLR.B  2D2.5
0724:  BSET.B  2D6.5
....................       delay_us(2); 
0726:  REPEAT  #C
0728:  NOP     
....................       output_low(RTC_SCLK); 
072A:  BCLR.B  2D2.5
072C:  BCLR.B  2D6.5
....................       delay_us(2); 
072E:  REPEAT  #C
0730:  NOP     
....................    } 
0732:  INC.B   09A1
0734:  BRA     70C
....................    output_low(RTC_RST); 
0736:  BCLR.B  2D2.4
0738:  BCLR.B  2D6.4
....................  
....................    return(data); 
073A:  MOV.B   9A2,W0L
073C:  MOV.B   W0L,0
.................... } 
073E:  RETURN  
....................  
.................... void rtc_init() { 
0740:  MOV     W5,[W15++]
....................    BYTE x; 
....................    output_low(RTC_RST); 
0742:  BCLR.B  2D2.4
0744:  BCLR.B  2D6.4
....................    delay_us(2); 
0746:  REPEAT  #C
0748:  NOP     
....................    output_low(RTC_SCLK); 
074A:  BCLR.B  2D2.5
074C:  BCLR.B  2D6.5
....................    write_ds1302(0x8e,0); 
074E:  MOV.B   #8E,W0L
0750:  MOV.B   W0L,9AA
0752:  CLR.B   9AB
0754:  CALL    6DE
....................    write_ds1302(0x90,0xa4); 
0758:  MOV.B   #90,W0L
075A:  MOV.B   W0L,9AA
075C:  MOV.B   #A4,W0L
075E:  MOV.B   W0L,9AB
0760:  CALL    6DE
....................    x=read_ds1302(0x81); 
0764:  MOV.B   #81,W0L
0766:  MOV.B   W0L,9A0
0768:  CALL    6F8
076C:  MOV.B   W0L,99C
....................    if((x & 0x80)!=0) 
076E:  MOV.B   99C,W0L
0770:  AND.B   #80,W0L
0772:  CP0.B   W0L
0774:  BRA     Z,780
....................      write_ds1302(0x80,0); 
0776:  MOV.B   #80,W0L
0778:  MOV.B   W0L,9AA
077A:  CLR.B   9AB
077C:  CALL    6DE
.................... } 
0780:  MOV     [--W15],W5
0782:  RETURN  
....................  
.................... byte get_bcd(BYTE data) 
.................... { 
*
0E68:  MOV     W5,[W15++]
....................    byte nibh; 
....................    byte nibl; 
....................  
....................    nibh=data/10; 
0E6A:  MOV     9A8,W4
0E6C:  CLR.B   9
0E6E:  MOV     #A,W3
0E70:  REPEAT  #11
0E72:  DIV.U   W4,W3
0E74:  MOV.B   W0L,9A9
....................    nibl=data-(nibh*10); 
0E76:  MOV     9A8,W4
0E78:  LSR     W4,#8,W4
0E7A:  MUL.UU  W4,#A,W0
0E7C:  MOV     9A8,W4
0E7E:  SUB.B   W4L,W0L,W0L
0E80:  MOV.B   W0L,9AA
....................  
....................    return((nibh<<4)|nibl); 
0E82:  MOV.B   9A9,W0L
0E84:  SL      W0,#4,W0
0E86:  IOR.B   9AA,W0L
.................... } 
0E88:  MOV     [--W15],W5
0E8A:  RETURN  
....................  
.................... byte rm_bcd(BYTE data) 
.................... { 
*
14F6:  MOV     W5,[W15++]
....................    byte i; 
....................  
....................    i=data; 
14F8:  MOV.B   9A2,W0L
14FA:  MOV.B   W0L,9A3
....................    data=(i>>4)*10; 
14FC:  MOV.B   9A3,W0L
14FE:  CLR.B   1
1500:  LSR     W0,#4,W0
1502:  MOV.B   W0L,W4L
1504:  CLR.B   9
1506:  MUL.UU  W4,#A,W0
1508:  MOV.B   W0L,9A2
....................    data=data+(i<<4>>4); 
150A:  MOV.B   9A3,W0L
150C:  SL      W0,#4,W0
150E:  CLR.B   1
1510:  LSR     W0,#4,W0
1512:  ADD.B   9A2
....................  
....................    return data; 
1514:  MOV.B   9A2,W0L
1516:  MOV.B   W0L,0
.................... } 
1518:  MOV     [--W15],W5
151A:  RETURN  
....................  
.................... void rtc_set_datetime(BYTE day, BYTE mth, BYTE year, BYTE dow, BYTE hr, BYTE min) { 
*
0E8C:  MOV     W5,[W15++]
....................  
....................    write_ds1302(0x86,get_bcd(day)); 
0E8E:  MOV.B   99C,W0L
0E90:  MOV.B   W0L,9A8
0E92:  CALL    E68
0E96:  MOV.B   W0L,W5L
0E98:  MOV.B   #86,W0L
0E9A:  MOV.B   W0L,9AA
0E9C:  MOV.B   W5L,W0L
0E9E:  MOV.B   W0L,9AB
0EA0:  CALL    6DE
....................    write_ds1302(0x88,get_bcd(mth)); 
0EA4:  MOV.B   99D,W0L
0EA6:  MOV.B   W0L,9A8
0EA8:  CALL    E68
0EAC:  MOV.B   W0L,W5L
0EAE:  MOV.B   #88,W0L
0EB0:  MOV.B   W0L,9AA
0EB2:  MOV.B   W5L,W0L
0EB4:  MOV.B   W0L,9AB
0EB6:  CALL    6DE
....................    write_ds1302(0x8c,get_bcd(year)); 
0EBA:  MOV.B   99E,W0L
0EBC:  MOV.B   W0L,9A8
0EBE:  CALL    E68
0EC2:  MOV.B   W0L,W5L
0EC4:  MOV.B   #8C,W0L
0EC6:  MOV.B   W0L,9AA
0EC8:  MOV.B   W5L,W0L
0ECA:  MOV.B   W0L,9AB
0ECC:  CALL    6DE
....................    write_ds1302(0x8a,get_bcd(dow)); 
0ED0:  MOV.B   99F,W0L
0ED2:  MOV.B   W0L,9A8
0ED4:  CALL    E68
0ED8:  MOV.B   W0L,W5L
0EDA:  MOV.B   #8A,W0L
0EDC:  MOV.B   W0L,9AA
0EDE:  MOV.B   W5L,W0L
0EE0:  MOV.B   W0L,9AB
0EE2:  CALL    6DE
....................    write_ds1302(0x84,get_bcd(hr)); 
0EE6:  MOV.B   9A0,W0L
0EE8:  MOV.B   W0L,9A8
0EEA:  CALL    E68
0EEE:  MOV.B   W0L,W5L
0EF0:  MOV.B   #84,W0L
0EF2:  MOV.B   W0L,9AA
0EF4:  MOV.B   W5L,W0L
0EF6:  MOV.B   W0L,9AB
0EF8:  CALL    6DE
....................    write_ds1302(0x82,get_bcd(min)); 
0EFC:  MOV.B   9A1,W0L
0EFE:  MOV.B   W0L,9A8
0F00:  CALL    E68
0F04:  MOV.B   W0L,W5L
0F06:  MOV.B   #82,W0L
0F08:  MOV.B   W0L,9AA
0F0A:  MOV.B   W5L,W0L
0F0C:  MOV.B   W0L,9AB
0F0E:  CALL    6DE
....................    write_ds1302(0x80,get_bcd(0)); 
0F12:  CLR.B   9A8
0F14:  CALL    E68
0F18:  MOV.B   W0L,W5L
0F1A:  MOV.B   #80,W0L
0F1C:  MOV.B   W0L,9AA
0F1E:  MOV.B   W5L,W0L
0F20:  MOV.B   W0L,9AB
0F22:  CALL    6DE
.................... } 
0F26:  MOV     [--W15],W5
0F28:  RETURN  
....................  
.................... void rtc_get_date(BYTE& day, BYTE& mth, BYTE& year, BYTE& dow) { 
....................    day = rm_bcd(read_ds1302(0x87)); 
*
2446:  MOV.B   #87,W0L
2448:  MOV.B   W0L,9A0
244A:  CALL    6F8
244E:  MOV.B   W0L,W5L
2450:  PUSH    9A2
2452:  MOV.B   W5L,[W15-#2]
2454:  POP     9A2
2456:  CALL    14F6
245A:  MOV.B   W0L,988
....................    mth = rm_bcd(read_ds1302(0x89)); 
245C:  MOV.B   #89,W0L
245E:  MOV.B   W0L,9A0
2460:  CALL    6F8
2464:  MOV.B   W0L,W5L
2466:  PUSH    9A2
2468:  MOV.B   W5L,[W15-#2]
246A:  POP     9A2
246C:  CALL    14F6
2470:  MOV.B   W0L,989
....................    year = rm_bcd(read_ds1302(0x8d)); 
2472:  MOV.B   #8D,W0L
2474:  MOV.B   W0L,9A0
2476:  CALL    6F8
247A:  MOV.B   W0L,W5L
247C:  PUSH    9A2
247E:  MOV.B   W5L,[W15-#2]
2480:  POP     9A2
2482:  CALL    14F6
2486:  MOV.B   W0L,98A
....................    dow = rm_bcd(read_ds1302(0x8b)); 
2488:  MOV.B   #8B,W0L
248A:  MOV.B   W0L,9A0
248C:  CALL    6F8
2490:  MOV.B   W0L,W5L
2492:  PUSH    9A2
2494:  MOV.B   W5L,[W15-#2]
2496:  POP     9A2
2498:  CALL    14F6
249C:  MOV.B   W0L,98E
.................... } 
....................  
.................... void rtc_get_time(BYTE& hr, BYTE& min, BYTE& sec) { 
....................    hr = rm_bcd(read_ds1302(0x85)); 
249E:  MOV.B   #85,W0L
24A0:  MOV.B   W0L,9A0
24A2:  CALL    6F8
24A6:  MOV.B   W0L,W5L
24A8:  PUSH    9A2
24AA:  MOV.B   W5L,[W15-#2]
24AC:  POP     9A2
24AE:  CALL    14F6
24B2:  MOV.B   W0L,98B
....................    min = rm_bcd(read_ds1302(0x83)); 
24B4:  MOV.B   #83,W0L
24B6:  MOV.B   W0L,9A0
24B8:  CALL    6F8
24BC:  MOV.B   W0L,W5L
24BE:  PUSH    9A2
24C0:  MOV.B   W5L,[W15-#2]
24C2:  POP     9A2
24C4:  CALL    14F6
24C8:  MOV.B   W0L,98C
....................    sec = rm_bcd(read_ds1302(0x81)); 
24CA:  MOV.B   #81,W0L
24CC:  MOV.B   W0L,9A0
24CE:  CALL    6F8
24D2:  MOV.B   W0L,W5L
24D4:  PUSH    9A2
24D6:  MOV.B   W5L,[W15-#2]
24D8:  POP     9A2
24DA:  CALL    14F6
24DE:  MOV.B   W0L,98D
.................... } 
....................  
.................... void rtc_write_nvr(BYTE address, BYTE data) { 
....................    write_ds1302(address|0xc0,data); 
.................... } 
....................  
.................... BYTE rtc_read_nvr(BYTE address) { 
....................     return(read_ds1302(address|0xc1)); 
.................... } 
....................  
.................... //#include "mcp4921_DSPIC.c" 
.................... #include "lcd_2.c"			//Driver for common LCD modules    
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
....................      #define LCD_ENABLE_PIN  PIN_B12                                   //// 
....................      #define LCD_RS_PIN      PIN_B10                                    ////     
....................      #define LCD_RW_PIN      PIN_B11                                    //// 
....................      #define LCD_DATA4       PIN_D0                                    //// 
....................      #define LCD_DATA5       PIN_D1                                    //// 
....................      #define LCD_DATA6       PIN_D2                                    //// 
....................      #define LCD_DATA7       PIN_D3  
....................  
....................  
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    BOOLEAN enable;           // on to an I/O port to gain 
....................    BOOLEAN rs;               // access to the LCD pins. 
....................    BOOLEAN rw;               // The bits are allocated from 
....................    BOOLEAN unused;           // low order up.  ENABLE will 
....................    int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... BYTE const LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................  
.................... BYTE lcd_read_nibble(void); 
....................  
.................... BYTE lcd_read_byte(void) 
.................... { 
*
0598:  MOV     W5,[W15++]
....................    BYTE low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
059A:  BSET.B  2D2.0
....................    output_float(LCD_DATA5); 
059C:  BSET.B  2D2.1
....................    output_float(LCD_DATA6); 
059E:  BSET.B  2D2.2
....................    output_float(LCD_DATA7); 
05A0:  BSET.B  2D2.3
....................   #else 
....................    lcdtris.data = 0xF; 
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
05A2:  BSET.B  2CB.3
05A4:  MOV     #7E,W4
05A6:  MOV     W4,2C6
....................    delay_cycles(1); 
05A8:  NOP     
....................    lcd_output_enable(1); 
05AA:  BSET.B  2CB.4
05AC:  MOV     #7E,W4
05AE:  MOV     W4,2C6
....................    delay_cycles(1); 
05B0:  NOP     
....................    high = lcd_read_nibble(); 
05B2:  CALL    55E
05B6:  MOV.B   W0L,9B9
....................        
....................    lcd_output_enable(0); 
05B8:  BCLR.B  2CB.4
05BA:  MOV     #7E,W4
05BC:  MOV     W4,2C6
....................    delay_cycles(1); 
05BE:  NOP     
....................    lcd_output_enable(1); 
05C0:  BSET.B  2CB.4
05C2:  MOV     #7E,W4
05C4:  MOV     W4,2C6
....................    delay_us(1); 
05C6:  REPEAT  #5
05C8:  NOP     
....................    low = lcd_read_nibble(); 
05CA:  CALL    55E
05CE:  MOV.B   W0L,9B8
....................        
....................    lcd_output_enable(0); 
05D0:  BCLR.B  2CB.4
05D2:  MOV     #7E,W4
05D4:  MOV     W4,2C6
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
05D6:  BCLR.B  2D2.0
....................    output_drive(LCD_DATA5); 
05D8:  BCLR.B  2D2.1
....................    output_drive(LCD_DATA6); 
05DA:  BCLR.B  2D2.2
....................    output_drive(LCD_DATA7); 
05DC:  BCLR.B  2D2.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
05DE:  MOV.B   9B9,W0L
05E0:  SL      W0,#4,W0
05E2:  IOR.B   9B8,W0L
.................... } 
05E4:  MOV     [--W15],W5
05E6:  RETURN  
....................  
.................... BYTE lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
*
055E:  MOV     W5,[W15++]
0560:  CLR.B   9BA
....................    BYTE n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
0562:  BSET.B  2D2.0
0564:  CLR.B   W0
0566:  BTSC.B  2D4.0
0568:  INC     W0,W0
056A:  IOR.B   9BA
....................    n |= input(LCD_DATA5) << 1; 
056C:  BSET.B  2D2.1
056E:  CLR.B   W0
0570:  BTSC.B  2D4.1
0572:  INC     W0,W0
0574:  SL      W0,#1,W0
0576:  IOR.B   9BA
....................    n |= input(LCD_DATA6) << 2; 
0578:  BSET.B  2D2.2
057A:  CLR.B   W0
057C:  BTSC.B  2D4.2
057E:  INC     W0,W0
0580:  SL      W0,#2,W0
0582:  IOR.B   9BA
....................    n |= input(LCD_DATA7) << 3; 
0584:  BSET.B  2D2.3
0586:  CLR.B   W0
0588:  BTSC.B  2D4.3
058A:  INC     W0,W0
058C:  SL      W0,#3,W0
058E:  IOR.B   9BA
....................     
....................    return(n); 
0590:  MOV.B   9BA,W0L
0592:  MOV.B   W0L,0
....................   #else 
....................    return(lcd.data); 
....................   #endif 
.................... } 
0594:  MOV     [--W15],W5
0596:  RETURN  
....................  
.................... void lcd_send_nibble(BYTE n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
*
051A:  BTSC.B  9BA.0
051C:  BRA     522
051E:  BCLR.B  2D6.0
0520:  BRA     524
0522:  BSET.B  2D6.0
0524:  BCLR.B  2D2.0
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
0526:  BTSC.B  9BA.1
0528:  BRA     52E
052A:  BCLR.B  2D6.1
052C:  BRA     530
052E:  BSET.B  2D6.1
0530:  BCLR.B  2D2.1
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
0532:  BTSC.B  9BA.2
0534:  BRA     53A
0536:  BCLR.B  2D6.2
0538:  BRA     53C
053A:  BSET.B  2D6.2
053C:  BCLR.B  2D2.2
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
053E:  BTSC.B  9BA.3
0540:  BRA     546
0542:  BCLR.B  2D6.3
0544:  BRA     548
0546:  BSET.B  2D6.3
0548:  BCLR.B  2D2.3
....................   #else       
....................    lcdlat.data = n; 
....................   #endif 
....................        
....................    delay_cycles(1); 
054A:  NOP     
....................    lcd_output_enable(1); 
054C:  BSET.B  2CB.4
054E:  MOV     #7E,W4
0550:  MOV     W4,2C6
....................    delay_us(2); 
0552:  REPEAT  #C
0554:  NOP     
....................    lcd_output_enable(0); 
0556:  BCLR.B  2CB.4
0558:  MOV     #7E,W4
055A:  MOV     W4,2C6
.................... } 
055C:  RETURN  
....................  
.................... void lcd_send_byte(BYTE address, BYTE n) 
.................... { 
*
05E8:  MOV     W5,[W15++]
....................    lcd_output_rs(0); 
05EA:  BCLR.B  2CB.2
05EC:  MOV     #7E,W4
05EE:  MOV     W4,2C6
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
05F0:  CALL    598
05F4:  MOV.B   W0L,W5L
05F6:  BTSC    W5.7
05F8:  BRA     5F0
....................    lcd_output_rs(address); 
05FA:  CP0.B   9B4
05FC:  BRA     NZ,602
05FE:  BCLR.B  2CB.2
0600:  BRA     604
0602:  BSET.B  2CB.2
0604:  MOV     #7E,W4
0606:  MOV     W4,2C6
....................    delay_cycles(1); 
0608:  NOP     
....................    lcd_output_rw(0); 
060A:  BCLR.B  2CB.3
060C:  MOV     #7E,W4
060E:  MOV     W4,2C6
....................    delay_cycles(1); 
0610:  NOP     
....................    lcd_output_enable(0); 
0612:  BCLR.B  2CB.4
0614:  MOV     #7E,W4
0616:  MOV     W4,2C6
....................    lcd_send_nibble(n >> 4); 
0618:  MOV     9B4,W5
061A:  LSR     W5,#8,W5
061C:  CLR.B   B
061E:  LSR     W5,#4,W5
0620:  PUSH    9BA
0622:  MOV.B   W5L,[W15-#2]
0624:  POP     9BA
0626:  CALL    51A
....................    lcd_send_nibble(n & 0xf); 
062A:  MOV.B   9B5,W0L
062C:  AND.B   W0L,#F,W5L
062E:  PUSH    9BA
0630:  MOV.B   W5L,[W15-#2]
0632:  POP     9BA
0634:  CALL    51A
.................... } 
0638:  MOV     [--W15],W5
063A:  RETURN  
....................  
.................... void lcd_init(void)  
.................... { 
063C:  MOV     W5,[W15++]
....................    BYTE i; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
063E:  BCLR.B  2D2.0
....................    output_drive(LCD_DATA5); 
0640:  BCLR.B  2D2.1
....................    output_drive(LCD_DATA6); 
0642:  BCLR.B  2D2.2
....................    output_drive(LCD_DATA7); 
0644:  BCLR.B  2D2.3
....................   #else 
....................    lcdtris.data = 0x0; 
....................   #endif 
....................    lcd_enable_tris(); 
0646:  MOV     #7E,W4
0648:  MOV     W4,2C6
....................    lcd_rs_tris(); 
064A:  MOV     #7E,W4
064C:  MOV     W4,2C6
....................    lcd_rw_tris(); 
064E:  MOV     #7E,W4
0650:  MOV     W4,2C6
....................  #endif 
....................  
....................    lcd_output_rs(0); 
0652:  BCLR.B  2CB.2
0654:  MOV     #7E,W4
0656:  MOV     W4,2C6
....................    lcd_output_rw(0); 
0658:  BCLR.B  2CB.3
065A:  MOV     #7E,W4
065C:  MOV     W4,2C6
....................    lcd_output_enable(0); 
065E:  BCLR.B  2CB.4
0660:  MOV     #7E,W4
0662:  MOV     W4,2C6
....................      
....................    delay_ms(15); 
0664:  MOV     #F,W0
0666:  CALL    50A
....................    for(i=1;i<=3;++i) 
066A:  MOV.B   #1,W0L
066C:  MOV.B   W0L,99C
066E:  MOV     99C,W4
0670:  CP.B    W4L,#3
0672:  BRA     GTU,68C
....................    { 
....................        lcd_send_nibble(3); 
0674:  MOV.B   #3,W0L
0676:  MOV.B   W0L,9BA
0678:  CALL    51A
....................        delay_ms(5); 
067C:  REPEAT  #FF0
067E:  NOP     
0680:  REPEAT  #3FFF
0682:  NOP     
0684:  REPEAT  #3FFF
0686:  NOP     
....................    } 
0688:  INC.B   099C
068A:  BRA     66E
....................      
....................    lcd_send_nibble(2); 
068C:  MOV.B   #2,W0L
068E:  MOV.B   W0L,9BA
0690:  CALL    51A
....................    for(i=0;i<=3;++i) 
0694:  CLR.B   99C
0696:  MOV     99C,W4
0698:  CP.B    W4L,#3
069A:  BRA     GTU,6B4
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
069C:  MOV.B   99C,W0L
069E:  CLR.B   1
06A0:  CALL    100
06A4:  MOV.B   W0L,W5L
06A6:  CLR.B   9B4
06A8:  MOV.B   W5L,W0L
06AA:  MOV.B   W0L,9B5
06AC:  CALL    5E8
06B0:  INC.B   099C
06B2:  BRA     696
.................... } 
06B4:  MOV     [--W15],W5
06B6:  RETURN  
....................  
.................... void lcd_gotoxy(BYTE x, BYTE y) 
.................... { 
*
0784:  MOV     W5,[W15++]
....................    BYTE address; 
....................  
....................    if(y!=1) 
0786:  MOV     9AE,W4
0788:  LSR     W4,#8,W4
078A:  CP.B    W4L,#1
078C:  BRA     Z,794
....................       address=LCD_LINE_TWO; 
078E:  MOV.B   #40,W0L
0790:  MOV.B   W0L,9B0
....................    else 
0792:  BRA     796
....................       address=0; 
0794:  CLR.B   9B0
....................       
....................    address+=x-1; 
0796:  MOV     9AE,W4
0798:  SUB.B   W4L,#1,W0L
079A:  ADD.B   9B0
....................    lcd_send_byte(0,0x80|address); 
079C:  MOV     9B0,W5
079E:  IOR.B   #80,W5L
07A0:  CLR.B   9B4
07A2:  MOV.B   W5L,W0L
07A4:  MOV.B   W0L,9B5
07A6:  CALL    5E8
.................... } 
07AA:  MOV     [--W15],W5
07AC:  RETURN  
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
....................    { 
07AE:  MOV.B   9AC,W0L
07B0:  CLR.B   1
07B2:  XOR     #C,W0
07B4:  BRA     Z,7C0
07B6:  XOR     #6,W0
07B8:  BRA     Z,7D0
07BA:  XOR     #2,W0
07BC:  BRA     Z,7DE
07BE:  BRA     7EA
....................       case '\f'   :  lcd_send_byte(0,1); 
07C0:  CLR.B   9B4
07C2:  MOV.B   #1,W0L
07C4:  MOV.B   W0L,9B5
07C6:  CALL    5E8
....................                      delay_ms(2); 
07CA:  REPEAT  #3992
07CC:  NOP     
....................                      break; 
07CE:  BRA     7F8
....................                       
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
07D0:  MOV.B   #1,W0L
07D2:  MOV.B   W0L,9AE
07D4:  MOV.B   #2,W0L
07D6:  MOV.B   W0L,9AF
07D8:  CALL    784
07DC:  BRA     7F8
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
07DE:  CLR.B   9B4
07E0:  MOV.B   #10,W0L
07E2:  MOV.B   W0L,9B5
07E4:  CALL    5E8
07E8:  BRA     7F8
....................       
....................       default     : lcd_send_byte(1,c);     break; 
07EA:  MOV.B   #1,W0L
07EC:  MOV.B   W0L,9B4
07EE:  MOV.B   9AC,W0L
07F0:  MOV.B   W0L,9B5
07F2:  CALL    5E8
07F6:  BRA     7F8
....................    } 
.................... } 
07F8:  RETURN  
....................   
.................... char lcd_getc(BYTE x, BYTE y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... #include "ADH8066.c" 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             ADH8066.C                                 //// 
.................... ////                 Driver for ADH8066 GPRS modules                       //// 
.................... ////                                                                       //// 
.................... ////  StringToHex(Str,size,result)                                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                     The following have special meaning:               //// 
.................... ////                      \f  Clear display                                //// 
.................... ////                      \n  Go to start of second line                   //// 
.................... ////                      \b  Move back one position                       //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 2014  Adolfo Emmanuel Sigala Villa           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************Global definitions********************/ 
.................... //#define AT "AT+" 
.................... //#define CPIN "CPIN?\r\n" 
.................... //#define AIPDCONT "AIPDCONT=\"INTERNET.MOVISTAR.MX\",\"MOVISTAR\",\"MOVISTAR\"\r\n" 
.................... //#define AIPO "AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n" 
.................... //#define HOST "HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n" 
....................  
.................... #define Buzzer_delay	200 
.................... #define Buzzer_On		1 
.................... #define Buzzer_Off      0 
....................  
.................... /******************Variable and constant definitions*****/ 
.................... const char hexcode[17]="0123456789abcdef"; 
....................  
.................... char InputBuffer[350]={0}; 
*
2074:  CLR     800
2076:  CLR     802
2078:  CLR     804
207A:  CLR     806
207C:  CLR     808
207E:  CLR     80A
2080:  CLR     80C
2082:  CLR     80E
2084:  CLR     810
2086:  CLR     812
2088:  CLR     814
208A:  CLR     816
208C:  CLR     818
208E:  CLR     81A
2090:  CLR     81C
2092:  CLR     81E
2094:  CLR     820
2096:  CLR     822
2098:  CLR     824
209A:  CLR     826
209C:  CLR     828
209E:  CLR     82A
20A0:  CLR     82C
20A2:  CLR     82E
20A4:  CLR     830
20A6:  CLR     832
20A8:  CLR     834
20AA:  CLR     836
20AC:  CLR     838
20AE:  CLR     83A
20B0:  CLR     83C
20B2:  CLR     83E
20B4:  CLR     840
20B6:  CLR     842
20B8:  CLR     844
20BA:  CLR     846
20BC:  CLR     848
20BE:  CLR     84A
20C0:  CLR     84C
20C2:  CLR     84E
20C4:  CLR     850
20C6:  CLR     852
20C8:  CLR     854
20CA:  CLR     856
20CC:  CLR     858
20CE:  CLR     85A
20D0:  CLR     85C
20D2:  CLR     85E
20D4:  CLR     860
20D6:  CLR     862
20D8:  CLR     864
20DA:  CLR     866
20DC:  CLR     868
20DE:  CLR     86A
20E0:  CLR     86C
20E2:  CLR     86E
20E4:  CLR     870
20E6:  CLR     872
20E8:  CLR     874
20EA:  CLR     876
20EC:  CLR     878
20EE:  CLR     87A
20F0:  CLR     87C
20F2:  CLR     87E
20F4:  CLR     880
20F6:  CLR     882
20F8:  CLR     884
20FA:  CLR     886
20FC:  CLR     888
20FE:  CLR     88A
2100:  CLR     88C
2102:  CLR     88E
2104:  CLR     890
2106:  CLR     892
2108:  CLR     894
210A:  CLR     896
210C:  CLR     898
210E:  CLR     89A
2110:  CLR     89C
2112:  CLR     89E
2114:  CLR     8A0
2116:  CLR     8A2
2118:  CLR     8A4
211A:  CLR     8A6
211C:  CLR     8A8
211E:  CLR     8AA
2120:  CLR     8AC
2122:  CLR     8AE
2124:  CLR     8B0
2126:  CLR     8B2
2128:  CLR     8B4
212A:  CLR     8B6
212C:  CLR     8B8
212E:  CLR     8BA
2130:  CLR     8BC
2132:  CLR     8BE
2134:  CLR     8C0
2136:  CLR     8C2
2138:  CLR     8C4
213A:  CLR     8C6
213C:  CLR     8C8
213E:  CLR     8CA
2140:  CLR     8CC
2142:  CLR     8CE
2144:  CLR     8D0
2146:  CLR     8D2
2148:  CLR     8D4
214A:  CLR     8D6
214C:  CLR     8D8
214E:  CLR     8DA
2150:  CLR     8DC
2152:  CLR     8DE
2154:  CLR     8E0
2156:  CLR     8E2
2158:  CLR     8E4
215A:  CLR     8E6
215C:  CLR     8E8
215E:  CLR     8EA
2160:  CLR     8EC
2162:  CLR     8EE
2164:  CLR     8F0
2166:  CLR     8F2
2168:  CLR     8F4
216A:  CLR     8F6
216C:  CLR     8F8
216E:  CLR     8FA
2170:  CLR     8FC
2172:  CLR     8FE
2174:  CLR     900
2176:  CLR     902
2178:  CLR     904
217A:  CLR     906
217C:  CLR     908
217E:  CLR     90A
2180:  CLR     90C
2182:  CLR     90E
2184:  CLR     910
2186:  CLR     912
2188:  CLR     914
218A:  CLR     916
218C:  CLR     918
218E:  CLR     91A
2190:  CLR     91C
2192:  CLR     91E
2194:  CLR     920
2196:  CLR     922
2198:  CLR     924
219A:  CLR     926
219C:  CLR     928
219E:  CLR     92A
21A0:  CLR     92C
21A2:  CLR     92E
21A4:  CLR     930
21A6:  CLR     932
21A8:  CLR     934
21AA:  CLR     936
21AC:  CLR     938
21AE:  CLR     93A
21B0:  CLR     93C
21B2:  CLR     93E
21B4:  CLR     940
21B6:  CLR     942
21B8:  CLR     944
21BA:  CLR     946
21BC:  CLR     948
21BE:  CLR     94A
21C0:  CLR     94C
21C2:  CLR     94E
21C4:  CLR     950
21C6:  CLR     952
21C8:  CLR     954
21CA:  CLR     956
21CC:  CLR     958
21CE:  CLR     95A
21D0:  CLR     95C
.................... int16 ptime=100; 
....................  
.................... /***********StringToHex*********************************** 
.................... **   Description: This function converts a string in    ** 
.................... **     their hex codification                           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void StringToHex(char* str,unsigned int size,char* result) 
.................... { 
.................... 	int index=0,aux=0,aux2=0; 
.................... 	for(index=0;index<size;index++) 
.................... 		{ 
.................... 			aux=*(str+index); 
.................... 			aux2=aux/16; 
.................... 			*(result+(index*2))=hexcode[aux2]; 
.................... 			if(aux>15) 
.................... 				{ 
.................... 					aux=aux-(aux2*16); 
.................... 				} 
.................... 			*(result+((index*2)+1))=hexcode[aux];	 
.................... 		} 
.................... } 
....................  
.................... /***********FillArray************************************* 
.................... **   Description: Function used to fill an array with   ** 
.................... **     value of (val) variable                          ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void FillArray(char* arrayval,int size,char val) 
.................... { 
*
07FA:  MOV     W5,[W15++]
07FC:  CLR     9CA
.................... 	int index=0; 
.................... 	for(index=0;index<size;index++) 
07FE:  CLR     9CA
0800:  MOV     9CA,W0
0802:  MOV     9C6,W4
0804:  CP      W4,W0
0806:  BRA     LE,816
.................... 	{ 
.................... 		*(arrayval+index)=val; 
0808:  MOV     9C4,W0
080A:  ADD     9CA,W0
080C:  MOV     W0,W5
080E:  MOV.B   9C8,W0L
0810:  MOV.B   W0L,[W5+#0]
.................... 	} 
0812:  INC     09CA
0814:  BRA     800
.................... } 
0816:  MOV     [--W15],W5
0818:  RETURN  
....................  
.................... /***********ReadBuffer************************************ 
.................... **   Description: Reads incoming characters until arrive** 
.................... **     a carriage return '\r' and save the buffer in    ** 
.................... **       *buffer array                                  ** 
.................... *********************************************************/ 
.................... void ReadBuffer(char* buffer) 
.................... { 
081A:  MOV     W5,[W15++]
081C:  CLR     9C6
.................... 	int16 index=0; 
.................... 	OERR=16; 
081E:  MOV.B   #10,W0L
0820:  MOV.B   W0L,20E
.................... 	//******Get incoming buffer data****** 
.................... 	while(getc()!='\n'); 
0822:  BTSS.B  20E.0
0824:  BRA     822
0826:  MOV     212,W0
0828:  CP.B    W0L,#A
082A:  BRA     NZ,822
....................     do 
....................     { 
....................        *(buffer+index)=getc();	 
082C:  MOV     9C4,W0
082E:  ADD     9C6,W0
0830:  MOV     W0,W5
0832:  BTSS.B  20E.0
0834:  BRA     832
0836:  MOV     212,W0
0838:  MOV.B   W0L,[W5]
.................... 		index++; 
083A:  INC     09C6
....................     }while(index<350 && *(buffer+index-1)!='\r'); 
083C:  MOV     9C6,W4
083E:  MOV     #15E,W3
0840:  CP      W3,W4
0842:  BRA     LE,852
0844:  MOV     9C4,W0
0846:  ADD     9C6,W0
0848:  MOV     W0,W5
084A:  SUB     W5,#1,W0
084C:  MOV.B   [W0],W4L
084E:  CP.B    W4L,#D
0850:  BRA     NZ,82C
....................  
.................... 	//***Buzzer sound when receive******** 
....................     //output_bit(PIN_D9,Buzzer_On); 
.................... 	delay_ms(Buzzer_delay); 
0852:  MOV     #C8,W0
0854:  CALL    50A
.................... 	//output_bit(PIN_D9,Buzzer_Off); 
.................... 	OERR=16; 
0858:  MOV.B   #10,W0L
085A:  MOV.B   W0L,20E
....................  
.................... } 
085C:  MOV     [--W15],W5
085E:  RETURN  
....................  
.................... /***********PrintBuffer*********************************** 
.................... **   Description: Prints in LCD the specified buffer    ** 
.................... **     of characters with a permanency of ms            ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void PrintBuffer(char* buffer,int16 permanency) 
.................... { 
0860:  MOV     W5,[W15++]
.................... 	lcd_putc("\f"); 
0862:  MOV     #0,W5
0864:  MOV     W5,W0
0866:  CALL    110
086A:  IOR.B   #0,W0L
086C:  BTSC.B  42.1
086E:  BRA     87A
0870:  INC     W5,W5
0872:  MOV.B   W0L,9AC
0874:  CALL    7AE
0878:  BRA     864
....................     printf(lcd_putc,"%s",buffer); 
087A:  MOV     9A0,W1
087C:  CP0.B   [W1]
087E:  BRA     Z,890
0880:  MOV     W1,[W15++]
0882:  MOV.B   [W1+#0],W0L
0884:  MOV.B   W0L,9AC
0886:  CALL    7AE
088A:  MOV     [--W15],W1
088C:  INC     W1,W1
088E:  BRA     87C
.................... 	delay_ms(permanency); 
0890:  MOV     9A2,W0
0892:  CALL    50A
.................... } 
0896:  MOV     [--W15],W5
0898:  RETURN  
....................  
.................... /***********ValidateCommand******************************* 
.................... **   Description: Validate that input string does not   ** 
.................... **     contains an ERROR                                ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int ValidateCommand(char* cmdstr,int size) 
.................... { 
089A:  MOV     W5,[W15++]
089C:  CLR     9B0
089E:  MOV     #1,W4
08A0:  MOV     W4,9B2
.................... 	int index=0,result=1; 
.................... 	for(index=0;index<size;index++) 
08A2:  CLR     9B0
08A4:  MOV     9B0,W0
08A6:  MOV     9AE,W4
08A8:  CP      W4,W0
08AA:  BRA     LE,8CC
.................... 	{ 
.................... 		if(*(cmdstr+index)=='E' && *(cmdstr+(index+1))=='R')  
08AC:  MOV     9AC,W0
08AE:  ADD     9B0,W0
08B0:  MOV.B   [W0],W4L
08B2:  XOR.B   #45,W4L
08B4:  BRA     NZ,8C8
08B6:  MOV     9B0,W4
08B8:  ADD     W4,#1,W4
08BA:  MOV     W4,W0
08BC:  MOV     9AC,W4
08BE:  ADD     W0,W4,W0
08C0:  MOV.B   [W0],W4L
08C2:  XOR.B   #52,W4L
08C4:  BRA     NZ,8C8
.................... 		{ 
.................... 			result=0; 
08C6:  CLR     9B2
.................... 		} 
.................... 	} 
08C8:  INC     09B0
08CA:  BRA     8A4
....................     return result; 
08CC:  PUSH    9B2
08CE:  POP     0
.................... } 
08D0:  MOV     [--W15],W5
08D2:  RETURN  
....................  
.................... /***********GetDecVal************************************* 
.................... **   Description: Function used to find a decimal value ** 
.................... **     into string                                      ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int GetDecVal(char* arrayval,int16 size,char stch1,char stch2) 
.................... { 
*
0C20:  MOV     W5,[W15++]
0C22:  CLR     9B6
0C24:  SETM    9B8
.................... 	int16 ind=0; 
....................     int16  value=-1; 
.................... 	while(ind<size && *(arrayval+ind)!='$')// && value==-1) 
.................... 	{ 
0C26:  MOV     9B6,W0
0C28:  MOV     9B2,W4
0C2A:  CP      W4,W0
0C2C:  BRA     LE,C8E
0C2E:  MOV     9B0,W0
0C30:  ADD     9B6,W0
0C32:  MOV.B   [W0],W4L
0C34:  XOR.B   #24,W4L
0C36:  BRA     Z,C8E
.................... 		if(*(arrayval+ind)==stch1 && *(arrayval+(ind+1))==stch2) 
0C38:  MOV     9B0,W0
0C3A:  ADD     9B6,W0
0C3C:  MOV.B   [W0],W0L
0C3E:  CP.B    9B4
0C40:  BRA     NZ,C8A
0C42:  MOV     9B6,W4
0C44:  ADD     W4,#1,W4
0C46:  MOV     W4,W0
0C48:  MOV     9B0,W4
0C4A:  ADD     W0,W4,W0
0C4C:  MOV.B   [W0],W0L
0C4E:  CP.B    9B5
0C50:  BRA     NZ,C8A
.................... 			{ 
.................... 				ind+=2; 
0C52:  MOV     9B6,W4
0C54:  ADD     W4,#2,W4
0C56:  MOV     W4,9B6
.................... 				value=0; 
0C58:  CLR     9B8
.................... 				while(*(arrayval+ind)>47 && *(arrayval+ind)<58) 
.................... 					{ 
0C5A:  MOV     9B0,W0
0C5C:  ADD     9B6,W0
0C5E:  MOV     #2F,W4
0C60:  CP.B    W4L,[W0]
0C62:  BRA     C,C8A
0C64:  MOV     9B0,W0
0C66:  ADD     9B6,W0
0C68:  MOV.B   [W0],W4L
0C6A:  MOV     #3A,W3
0C6C:  CP.B    W3L,W4L
0C6E:  BRA     LEU,C8A
.................... 						value*=10; 
0C70:  MOV     9B8,W4
0C72:  MUL.UU  W4,#A,W0
0C74:  MOV     W0,9B8
.................... 						value+=(*(arrayval+ind)-48); 
0C76:  MOV     9B0,W0
0C78:  ADD     9B6,W0
0C7A:  MOV.B   [W0],W4L
0C7C:  SUB.B   #30,W4L
0C7E:  MOV.B   W4L,W0L
0C80:  MOV.B   W0L,0
0C82:  ZE      W0,W0
0C84:  ADD     9B8
.................... 						ind++; 
0C86:  INC     09B6
.................... 					} 
0C88:  BRA     C5A
.................... 			} 
.................... 		ind++; 
0C8A:  INC     09B6
.................... 	} 
0C8C:  BRA     C26
.................... 	return value; 
0C8E:  PUSH    9B8
0C90:  POP     0
.................... } 
0C92:  MOV     [--W15],W5
0C94:  RETURN  
....................  
.................... /***********ConfigureGPRS********************************* 
.................... **   Description: Function used to configure the GPRS   ** 
.................... **     module to conect it to internet                  ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ConfigureGPRS() 
.................... { 
*
08D4:  MOV     W5,[W15++]
08D6:  CLR     99C
08D8:  CLR     99E
.................... 	int status=0,count=0; 
.................... 	while(status==0 && count<5) 
.................... 		{ 
08DA:  CP0     99C
08DC:  BRA     NZ,B22
08DE:  MOV     99E,W4
08E0:  CP      W4,#5
08E2:  BRA     GE,B22
.................... 			FillArray(InputBuffer,350,0);  //Clear input_buffer 
08E4:  CLR.B   9C8
08E6:  MOV     #800,W4
08E8:  MOV     W4,9C4
08EA:  MOV     #15E,W4
08EC:  MOV     W4,9C6
08EE:  CALL    7FA
.................... 			printf("AT+CPIN?\r\n");         //Verify chip 
08F2:  MOV     #0,W1
08F4:  MOV     W1,W0
08F6:  CALL    11E
08FA:  INC     W1,W1
08FC:  MOV     W1,[W15++]
08FE:  BTSC.B  20F.1
0900:  BRA     8FE
0902:  MOV     W0,210
0904:  MOV     [--W15],W1
0906:  MOV     #9,W0
0908:  CPSGT   W1,W0
090A:  BRA     8F4
.................... 			ReadBuffer(InputBuffer); 
090C:  MOV     #800,W4
090E:  MOV     W4,9C4
0910:  CALL    81A
.................... 			PrintBuffer(InputBuffer,100); 
0914:  MOV     #64,W4
0916:  MOV     W4,9A2
0918:  MOV     #800,W4
091A:  MOV     W4,9A0
091C:  CALL    860
.................... 			status=ValidateCommand(InputBuffer,30); 
0920:  MOV     #1E,W4
0922:  MOV     W4,9AE
0924:  MOV     #800,W4
0926:  MOV     W4,9AC
0928:  CALL    89A
092C:  MOV     W0,99C
.................... 			if(status==1) lcd_putc("\fCMD OK"); 
092E:  MOV     99C,W4
0930:  CP      W4,#1
0932:  BRA     NZ,94E
0934:  MOV     #0,W5
0936:  MOV     W5,W0
0938:  CALL    136
093C:  IOR.B   #0,W0L
093E:  BTSC.B  42.1
0940:  BRA     94C
0942:  INC     W5,W5
0944:  MOV.B   W0L,9AC
0946:  CALL    7AE
094A:  BRA     936
.................... 			else  
094C:  BRA     968
.................... 				{	 
.................... 					lcd_putc("\fCMD BAD"); 
094E:  MOV     #0,W5
0950:  MOV     W5,W0
0952:  CALL    14A
0956:  IOR.B   #0,W0L
0958:  BTSC.B  42.1
095A:  BRA     966
095C:  INC     W5,W5
095E:  MOV.B   W0L,9AC
0960:  CALL    7AE
0964:  BRA     950
.................... 					status=0; 
0966:  CLR     99C
.................... 				} 
.................... 			delay_ms(600); 
0968:  MOV     #258,W0
096A:  CALL    50A
.................... 			if(status==1) 
096E:  MOV     99C,W4
0970:  CP      W4,#1
0972:  BRA     NZ,9FE
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0974:  CLR.B   9C8
0976:  MOV     #800,W4
0978:  MOV     W4,9C4
097A:  MOV     #15E,W4
097C:  MOV     W4,9C6
097E:  CALL    7FA
.................... 					printf("AT+AIPDCONT=\"internet.movistar.mx\",\"movistar\",\"movistar\"\r\n");  //Configure internet 
0982:  MOV     #0,W1
0984:  MOV     W1,W0
0986:  CALL    160
098A:  INC     W1,W1
098C:  MOV     W1,[W15++]
098E:  BTSC.B  20F.1
0990:  BRA     98E
0992:  MOV     W0,210
0994:  MOV     [--W15],W1
0996:  MOV     #39,W0
0998:  CPSGT   W1,W0
099A:  BRA     984
.................... 					ReadBuffer(InputBuffer); 
099C:  MOV     #800,W4
099E:  MOV     W4,9C4
09A0:  CALL    81A
.................... 					PrintBuffer(InputBuffer,1000); 
09A4:  MOV     #800,W4
09A6:  MOV     W4,9A0
09A8:  MOV     #3E8,W4
09AA:  MOV     W4,9A2
09AC:  CALL    860
.................... 					status=ValidateCommand(InputBuffer,30); 
09B0:  MOV     #1E,W4
09B2:  MOV     W4,9AE
09B4:  MOV     #800,W4
09B6:  MOV     W4,9AC
09B8:  CALL    89A
09BC:  MOV     W0,99C
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
09BE:  MOV     99C,W4
09C0:  CP      W4,#1
09C2:  BRA     NZ,9DE
09C4:  MOV     #0,W5
09C6:  MOV     W5,W0
09C8:  CALL    136
09CC:  IOR.B   #0,W0L
09CE:  BTSC.B  42.1
09D0:  BRA     9DC
09D2:  INC     W5,W5
09D4:  MOV.B   W0L,9AC
09D6:  CALL    7AE
09DA:  BRA     9C6
.................... 					else  
09DC:  BRA     9F8
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
09DE:  MOV     #0,W5
09E0:  MOV     W5,W0
09E2:  CALL    14A
09E6:  IOR.B   #0,W0L
09E8:  BTSC.B  42.1
09EA:  BRA     9F6
09EC:  INC     W5,W5
09EE:  MOV.B   W0L,9AC
09F0:  CALL    7AE
09F4:  BRA     9E0
.................... 							status=0; 
09F6:  CLR     99C
.................... 						} 
.................... 					delay_ms(600); 
09F8:  MOV     #258,W0
09FA:  CALL    50A
.................... 				}		 
.................... 			if(status==1) 
09FE:  MOV     99C,W4
0A00:  CP      W4,#1
0A02:  BRA     NZ,A8E
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0A04:  CLR.B   9C8
0A06:  MOV     #800,W4
0A08:  MOV     W4,9C4
0A0A:  MOV     #15E,W4
0A0C:  MOV     W4,9C6
0A0E:  CALL    7FA
.................... 					printf("AT+AIPA=1\r\n");        //Conect to internet 
0A12:  MOV     #0,W1
0A14:  MOV     W1,W0
0A16:  CALL    1A4
0A1A:  INC     W1,W1
0A1C:  MOV     W1,[W15++]
0A1E:  BTSC.B  20F.1
0A20:  BRA     A1E
0A22:  MOV     W0,210
0A24:  MOV     [--W15],W1
0A26:  MOV     #A,W0
0A28:  CPSGT   W1,W0
0A2A:  BRA     A14
.................... 					ReadBuffer(InputBuffer); 
0A2C:  MOV     #800,W4
0A2E:  MOV     W4,9C4
0A30:  CALL    81A
.................... 					PrintBuffer(InputBuffer,1000); 
0A34:  MOV     #800,W4
0A36:  MOV     W4,9A0
0A38:  MOV     #3E8,W4
0A3A:  MOV     W4,9A2
0A3C:  CALL    860
.................... 					status=ValidateCommand(InputBuffer,30); 
0A40:  MOV     #1E,W4
0A42:  MOV     W4,9AE
0A44:  MOV     #800,W4
0A46:  MOV     W4,9AC
0A48:  CALL    89A
0A4C:  MOV     W0,99C
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0A4E:  MOV     99C,W4
0A50:  CP      W4,#1
0A52:  BRA     NZ,A6E
0A54:  MOV     #0,W5
0A56:  MOV     W5,W0
0A58:  CALL    136
0A5C:  IOR.B   #0,W0L
0A5E:  BTSC.B  42.1
0A60:  BRA     A6C
0A62:  INC     W5,W5
0A64:  MOV.B   W0L,9AC
0A66:  CALL    7AE
0A6A:  BRA     A56
.................... 					else  
0A6C:  BRA     A88
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0A6E:  MOV     #0,W5
0A70:  MOV     W5,W0
0A72:  CALL    14A
0A76:  IOR.B   #0,W0L
0A78:  BTSC.B  42.1
0A7A:  BRA     A86
0A7C:  INC     W5,W5
0A7E:  MOV.B   W0L,9AC
0A80:  CALL    7AE
0A84:  BRA     A70
.................... 							status=0; 
0A86:  CLR     99C
.................... 						} 
.................... 					delay_ms(500); 
0A88:  MOV     #1F4,W0
0A8A:  CALL    50A
.................... 				} 
.................... 			if(status==1) 
0A8E:  MOV     99C,W4
0A90:  CP      W4,#1
0A92:  BRA     NZ,B1E
.................... 				{ 
.................... 					FillArray(InputBuffer,350,0);  //Clear input_buffer 
0A94:  CLR.B   9C8
0A96:  MOV     #800,W4
0A98:  MOV     W4,9C4
0A9A:  MOV     #15E,W4
0A9C:  MOV     W4,9C6
0A9E:  CALL    7FA
.................... 					printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server"AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n" 
0AA2:  MOV     #0,W1
0AA4:  MOV     W1,W0
0AA6:  CALL    1BC
0AAA:  INC     W1,W1
0AAC:  MOV     W1,[W15++]
0AAE:  BTSC.B  20F.1
0AB0:  BRA     AAE
0AB2:  MOV     W0,210
0AB4:  MOV     [--W15],W1
0AB6:  MOV     #30,W0
0AB8:  CPSGT   W1,W0
0ABA:  BRA     AA4
.................... 					ReadBuffer(InputBuffer);																	  
0ABC:  MOV     #800,W4
0ABE:  MOV     W4,9C4
0AC0:  CALL    81A
.................... 					PrintBuffer(InputBuffer,1000); 
0AC4:  MOV     #800,W4
0AC6:  MOV     W4,9A0
0AC8:  MOV     #3E8,W4
0ACA:  MOV     W4,9A2
0ACC:  CALL    860
.................... 					status=ValidateCommand(InputBuffer,30); 
0AD0:  MOV     #1E,W4
0AD2:  MOV     W4,9AE
0AD4:  MOV     #800,W4
0AD6:  MOV     W4,9AC
0AD8:  CALL    89A
0ADC:  MOV     W0,99C
.................... 					if(status==1) lcd_putc("\fCMD OK"); 
0ADE:  MOV     99C,W4
0AE0:  CP      W4,#1
0AE2:  BRA     NZ,AFE
0AE4:  MOV     #0,W5
0AE6:  MOV     W5,W0
0AE8:  CALL    136
0AEC:  IOR.B   #0,W0L
0AEE:  BTSC.B  42.1
0AF0:  BRA     AFC
0AF2:  INC     W5,W5
0AF4:  MOV.B   W0L,9AC
0AF6:  CALL    7AE
0AFA:  BRA     AE6
.................... 					else  
0AFC:  BRA     B18
.................... 						{ 
.................... 							lcd_putc("\fCMD BAD"); 
0AFE:  MOV     #0,W5
0B00:  MOV     W5,W0
0B02:  CALL    14A
0B06:  IOR.B   #0,W0L
0B08:  BTSC.B  42.1
0B0A:  BRA     B16
0B0C:  INC     W5,W5
0B0E:  MOV.B   W0L,9AC
0B10:  CALL    7AE
0B14:  BRA     B00
.................... 							status=0; 
0B16:  CLR     99C
.................... 						} 
.................... 					delay_ms(500); 
0B18:  MOV     #1F4,W0
0B1A:  CALL    50A
.................... 				} 
.................... 			count++; 
0B1E:  INC     099E
.................... 		} 
0B20:  BRA     8DA
.................... 	//return status; 
.................... } 
0B22:  MOV     [--W15],W5
0B24:  RETURN  
.................... /***********OpenPort************************************** 
.................... **   Description: Open a TCP port in domain name and    ** 
.................... **     specified in dname and rport variables           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int OpenPort(int socket, int lport,char dname[100], int rport) 
.................... { 
.................... 	int state=0; 
.................... 	printf("AT+AIPO=%d,%d,\"%s\",%d,0,,1,2\r\n",socket,lport,dname,rport);  //Conect to server 
.................... 	//******Get incoming buffer data****** 
.................... 	ReadBuffer(InputBuffer); 
.................... 	//***Validate ok command************** 
.................... 	state=ValidateCommand(InputBuffer,30); 
.................... 	if(state==1) lcd_putc("\fCMD OK"); 
.................... 	else 
.................... 		{ 
.................... 			 lcd_putc("\fCMD BAD"); 
.................... 			 state=0; 
.................... 		} 
.................... 	delay_ms(ptime); 
.................... 	return state; 
.................... } 
....................  
.................... /***********ClosePort************************************* 
.................... **   Description: Close a TCP port in domain name and   ** 
.................... **     specified in dname and rport variables           ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ClosePort(int socket) 
.................... { 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
*
0C96:  CLR.B   9C8
0C98:  MOV     #800,W4
0C9A:  MOV     W4,9C4
0C9C:  MOV     #15E,W4
0C9E:  MOV     W4,9C6
0CA0:  CALL    7FA
.................... 	printf("AT+AIPC=%d\r\n",socket);  //Disconnect 
0CA4:  MOV     #0,W1
0CA6:  MOV     W1,W0
0CA8:  CALL    1FA
0CAC:  INC     W1,W1
0CAE:  MOV     W1,[W15++]
0CB0:  BTSC.B  20F.1
0CB2:  BRA     CB0
0CB4:  MOV     W0,210
0CB6:  MOV     [--W15],W1
0CB8:  MOV     #7,W0
0CBA:  CPSGT   W1,W0
0CBC:  BRA     CA6
0CBE:  MOV     9C0,W0
0CC0:  MOV     #0,W4
0CC2:  CALL    B26
0CC6:  BTSC.B  20F.1
0CC8:  BRA     CC6
0CCA:  MOV     #D,W4
0CCC:  MOV     W4,210
0CCE:  BTSC.B  20F.1
0CD0:  BRA     CCE
0CD2:  MOV     #A,W4
0CD4:  MOV     W4,210
.................... 	ReadBuffer(InputBuffer); 
0CD6:  MOV     #800,W4
0CD8:  MOV     W4,9C4
0CDA:  CALL    81A
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	//delay_ms(ptime); 
.................... } 
0CDE:  RETURN  
....................  
.................... /***********ConfigureDatetime***************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  dy24mt3yr2014hr11mn52$ (24/marzo/2014 11:52 a.m)    ** 
.................... *********************************************************/ 
.................... int ConfigureDatetime(int Id, byte* DateTime) 
.................... { 
0CE0:  MOV     W5,[W15++]
0CE2:  MOV     W6,[W15++]
0CE4:  CLR     9A0
0CE6:  CLR     9A2
.................... 	int status=0; 
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
0CE8:  CLR.B   9C8
0CEA:  MOV     #800,W4
0CEC:  MOV     W4,9C4
0CEE:  MOV     #15E,W4
0CF0:  MOV     W4,9C6
0CF2:  CALL    7FA
.................... 	printf("GET /TIMEGPRS/NOWTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
0CF6:  MOV     #0,W1
0CF8:  MOV     W1,W0
0CFA:  CALL    214
0CFE:  INC     W1,W1
0D00:  MOV     W1,[W15++]
0D02:  BTSC.B  20F.1
0D04:  BRA     D02
0D06:  MOV     W0,210
0D08:  MOV     [--W15],W1
0D0A:  MOV     #15,W0
0D0C:  CPSGT   W1,W0
0D0E:  BRA     CF8
0D10:  MOV     99C,W0
0D12:  MOV     #0,W4
0D14:  CALL    B26
0D18:  MOV     #18,W1
0D1A:  MOV     W1,W0
0D1C:  CALL    214
0D20:  INC     W1,W1
0D22:  MOV     W1,[W15++]
0D24:  BTSC.B  20F.1
0D26:  BRA     D24
0D28:  MOV     W0,210
0D2A:  MOV     [--W15],W1
0D2C:  MOV     #44,W0
0D2E:  CPSGT   W1,W0
0D30:  BRA     D1A
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
0D32:  MOV     #800,W4
0D34:  MOV     9A2,W3
0D36:  ADD     W3,W4,W5
0D38:  BTSS.B  20E.0
0D3A:  BRA     D38
0D3C:  MOV     212,W0
0D3E:  MOV.B   W0L,[W5]
.................... 		index++; 
0D40:  INC     09A2
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
0D42:  MOV     9A2,W4
0D44:  MOV     #15E,W3
0D46:  CP      W3,W4
0D48:  BRA     LE,D58
0D4A:  MOV     9A2,W4
0D4C:  SUB     W4,#1,W5
0D4E:  MOV     #800,W4
0D50:  ADD     W5,W4,W0
0D52:  MOV.B   [W0],W4L
0D54:  XOR.B   #24,W4L
0D56:  BRA     NZ,D32
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
0D58:  MOV     #800,W4
0D5A:  MOV     W4,9AC
0D5C:  PUSH    9A2
0D5E:  POP     9AE
0D60:  CALL    89A
0D64:  MOV     W0,W5
0D66:  CP      W5,#1
0D68:  BRA     NZ,E24
.................... 		{ 
.................... 			lcd_putc("\fCMD OK"); 
0D6A:  MOV     #0,W5
0D6C:  MOV     W5,W0
0D6E:  CALL    136
0D72:  IOR.B   #0,W0L
0D74:  BTSC.B  42.1
0D76:  BRA     D82
0D78:  INC     W5,W5
0D7A:  MOV.B   W0L,9AC
0D7C:  CALL    7AE
0D80:  BRA     D6C
.................... 			delay_ms(ptime); 
0D82:  MOV     95E,W0
0D84:  CALL    50A
....................  
.................... 			*(DateTime)=(int)GetDecVal(InputBuffer,index,'d','y'); 
0D88:  MOV     99E,W5
0D8A:  MOV.B   #64,W0L
0D8C:  MOV.B   W0L,9B4
0D8E:  MOV.B   #79,W0L
0D90:  MOV.B   W0L,9B5
0D92:  MOV     #800,W4
0D94:  MOV     W4,9B0
0D96:  PUSH    9A2
0D98:  POP     9B2
0D9A:  CALL    C20
0D9E:  MOV.B   W0L,[W5]
.................... 			*(DateTime+1)=(int)GetDecVal(InputBuffer,index,'m','t'); 
0DA0:  MOV     99E,W4
0DA2:  ADD     W4,#1,W4
0DA4:  MOV     W4,W0
0DA6:  MOV     W0,W5
0DA8:  MOV.B   #6D,W0L
0DAA:  MOV.B   W0L,9B4
0DAC:  MOV.B   #74,W0L
0DAE:  MOV.B   W0L,9B5
0DB0:  MOV     #800,W4
0DB2:  MOV     W4,9B0
0DB4:  PUSH    9A2
0DB6:  POP     9B2
0DB8:  CALL    C20
0DBC:  MOV.B   W0L,[W5]
.................... 			*(DateTime+2)=(int)(GetDecVal(InputBuffer,index,'y','r')-2000); 
0DBE:  MOV     99E,W4
0DC0:  ADD     W4,#2,W4
0DC2:  MOV     W4,W0
0DC4:  MOV     W0,W5
0DC6:  MOV.B   #79,W0L
0DC8:  MOV.B   W0L,9B4
0DCA:  MOV.B   #72,W0L
0DCC:  MOV.B   W0L,9B5
0DCE:  MOV     #800,W4
0DD0:  MOV     W4,9B0
0DD2:  PUSH    9A2
0DD4:  POP     9B2
0DD6:  CALL    C20
0DDA:  MOV     W0,W6
0DDC:  MOV     #7D0,W4
0DDE:  SUB     W6,W4,W0
0DE0:  MOV.B   W0L,[W5]
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
0DE2:  MOV     99E,W4
0DE4:  ADD     W4,#3,W4
0DE6:  MOV     W4,W0
0DE8:  MOV     W0,W5
0DEA:  MOV.B   #68,W0L
0DEC:  MOV.B   W0L,9B4
0DEE:  MOV.B   #72,W0L
0DF0:  MOV.B   W0L,9B5
0DF2:  MOV     #800,W4
0DF4:  MOV     W4,9B0
0DF6:  PUSH    9A2
0DF8:  POP     9B2
0DFA:  CALL    C20
0DFE:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
0E00:  MOV     99E,W4
0E02:  ADD     W4,#4,W4
0E04:  MOV     W4,W0
0E06:  MOV     W0,W5
0E08:  MOV.B   #6D,W0L
0E0A:  MOV.B   W0L,9B4
0E0C:  MOV.B   #6E,W0L
0E0E:  MOV.B   W0L,9B5
0E10:  MOV     #800,W4
0E12:  MOV     W4,9B0
0E14:  PUSH    9A2
0E16:  POP     9B2
0E18:  CALL    C20
0E1C:  MOV.B   W0L,[W5]
....................  
.................... 			status=1; 
0E1E:  MOV     #1,W4
0E20:  MOV     W4,9A0
.................... 		} 
....................  
.................... 	else  
0E22:  BRA     E26
.................... 		{ 
.................... 			status=0; 
0E24:  CLR     9A0
.................... 		} 
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
0E26:  MOV     #32,W0
0E28:  CALL    50A
.................... 	printf("+"); 
0E2C:  BTSC.B  20F.1
0E2E:  BRA     E2C
0E30:  MOV     #2B,W4
0E32:  MOV     W4,210
.................... 	printf("+"); 
0E34:  BTSC.B  20F.1
0E36:  BRA     E34
0E38:  MOV     #2B,W4
0E3A:  MOV     W4,210
.................... 	printf("+"); 
0E3C:  BTSC.B  20F.1
0E3E:  BRA     E3C
0E40:  MOV     #2B,W4
0E42:  MOV     W4,210
.................... 	OERR=16; 
0E44:  MOV.B   #10,W0L
0E46:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
0E48:  MOV     #800,W4
0E4A:  MOV     W4,9C4
0E4C:  CALL    81A
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
0E50:  MOV     #32,W0
0E52:  CALL    50A
.................... 	ClosePort(1); 
0E56:  MOV     #1,W4
0E58:  MOV     W4,9C0
0E5A:  CALL    C96
.................... 	return status; 
0E5E:  PUSH    9A0
0E60:  POP     0
.................... } 
0E62:  MOV     [--W15],W6
0E64:  MOV     [--W15],W5
0E66:  RETURN  
....................  
.................... /***********GetSunriseTime******************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current sunrise time of the specified device     ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  hr11mn52$ (11:52 a.m)                               ** 
.................... *********************************************************/ 
.................... void GetOnTime(int Id, byte* DateTime) 
.................... { 
*
1228:  MOV     W5,[W15++]
122A:  CLR     9A0
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
122C:  CLR.B   9C8
122E:  MOV     #800,W4
1230:  MOV     W4,9C4
1232:  MOV     #15E,W4
1234:  MOV     W4,9C6
1236:  CALL    7FA
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
123A:  MOV     #0,W1
123C:  MOV     W1,W0
123E:  CALL    1A4
1242:  INC     W1,W1
1244:  MOV     W1,[W15++]
1246:  BTSC.B  20F.1
1248:  BRA     1246
124A:  MOV     W0,210
124C:  MOV     [--W15],W1
124E:  MOV     #A,W0
1250:  CPSGT   W1,W0
1252:  BRA     123C
.................... 	ReadBuffer(InputBuffer); 
1254:  MOV     #800,W4
1256:  MOV     W4,9C4
1258:  CALL    81A
.................... 	delay_ms(ptime); 
125C:  MOV     95E,W0
125E:  CALL    50A
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1262:  CLR.B   9C8
1264:  MOV     #800,W4
1266:  MOV     W4,9C4
1268:  MOV     #15E,W4
126A:  MOV     W4,9C6
126C:  CALL    7FA
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
1270:  MOV     #0,W1
1272:  MOV     W1,W0
1274:  CALL    1BC
1278:  INC     W1,W1
127A:  MOV     W1,[W15++]
127C:  BTSC.B  20F.1
127E:  BRA     127C
1280:  MOV     W0,210
1282:  MOV     [--W15],W1
1284:  MOV     #30,W0
1286:  CPSGT   W1,W0
1288:  BRA     1272
.................... 	ReadBuffer(InputBuffer); 
128A:  MOV     #800,W4
128C:  MOV     W4,9C4
128E:  CALL    81A
.................... 	delay_ms(ptime); 
1292:  MOV     95E,W0
1294:  CALL    50A
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1298:  CLR.B   9C8
129A:  MOV     #800,W4
129C:  MOV     W4,9C4
129E:  MOV     #15E,W4
12A0:  MOV     W4,9C6
12A2:  CALL    7FA
.................... 	printf("GET /TIMEGPRS/ONTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
12A6:  MOV     #0,W1
12A8:  MOV     W1,W0
12AA:  CALL    260
12AE:  INC     W1,W1
12B0:  MOV     W1,[W15++]
12B2:  BTSC.B  20F.1
12B4:  BRA     12B2
12B6:  MOV     W0,210
12B8:  MOV     [--W15],W1
12BA:  MOV     #14,W0
12BC:  CPSGT   W1,W0
12BE:  BRA     12A8
12C0:  MOV     99C,W0
12C2:  MOV     #0,W4
12C4:  CALL    B26
12C8:  MOV     #17,W1
12CA:  MOV     W1,W0
12CC:  CALL    260
12D0:  INC     W1,W1
12D2:  MOV     W1,[W15++]
12D4:  BTSC.B  20F.1
12D6:  BRA     12D4
12D8:  MOV     W0,210
12DA:  MOV     [--W15],W1
12DC:  MOV     #43,W0
12DE:  CPSGT   W1,W0
12E0:  BRA     12CA
....................  
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
12E2:  MOV     #800,W4
12E4:  MOV     9A0,W3
12E6:  ADD     W3,W4,W5
12E8:  BTSS.B  20E.0
12EA:  BRA     12E8
12EC:  MOV     212,W0
12EE:  MOV.B   W0L,[W5]
.................... 		index++; 
12F0:  INC     09A0
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
12F2:  MOV     9A0,W4
12F4:  MOV     #15E,W3
12F6:  CP      W3,W4
12F8:  BRA     LE,1308
12FA:  MOV     9A0,W4
12FC:  SUB     W4,#1,W5
12FE:  MOV     #800,W4
1300:  ADD     W5,W4,W0
1302:  MOV.B   [W0],W4L
1304:  XOR.B   #24,W4L
1306:  BRA     NZ,12E2
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1308:  MOV     #800,W4
130A:  MOV     W4,9AC
130C:  PUSH    9A0
130E:  POP     9AE
1310:  CALL    89A
1314:  MOV     W0,W5
1316:  CP      W5,#1
1318:  BRA     NZ,1356
.................... 		{ 
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
131A:  MOV     99E,W4
131C:  ADD     W4,#3,W4
131E:  MOV     W4,W0
1320:  MOV     W0,W5
1322:  MOV.B   #68,W0L
1324:  MOV.B   W0L,9B4
1326:  MOV.B   #72,W0L
1328:  MOV.B   W0L,9B5
132A:  MOV     #800,W4
132C:  MOV     W4,9B0
132E:  PUSH    9A0
1330:  POP     9B2
1332:  CALL    C20
1336:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
1338:  MOV     99E,W4
133A:  ADD     W4,#4,W4
133C:  MOV     W4,W0
133E:  MOV     W0,W5
1340:  MOV.B   #6D,W0L
1342:  MOV.B   W0L,9B4
1344:  MOV.B   #6E,W0L
1346:  MOV.B   W0L,9B5
1348:  MOV     #800,W4
134A:  MOV     W4,9B0
134C:  PUSH    9A0
134E:  POP     9B2
1350:  CALL    C20
1354:  MOV.B   W0L,[W5]
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1356:  MOV     #32,W0
1358:  CALL    50A
.................... 	printf("+"); 
135C:  BTSC.B  20F.1
135E:  BRA     135C
1360:  MOV     #2B,W4
1362:  MOV     W4,210
.................... 	printf("+"); 
1364:  BTSC.B  20F.1
1366:  BRA     1364
1368:  MOV     #2B,W4
136A:  MOV     W4,210
.................... 	printf("+"); 
136C:  BTSC.B  20F.1
136E:  BRA     136C
1370:  MOV     #2B,W4
1372:  MOV     W4,210
.................... 	OERR=16; 
1374:  MOV.B   #10,W0L
1376:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
1378:  MOV     #800,W4
137A:  MOV     W4,9C4
137C:  CALL    81A
.................... 	ClosePort(1); 
1380:  MOV     #1,W4
1382:  MOV     W4,9C0
1384:  CALL    C96
.................... } 
1388:  MOV     [--W15],W5
138A:  RETURN  
....................  
.................... /***********GetSunsetTime******************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current sunset time of the specified device      ** 
.................... **                                                      ** 
.................... **  Notes: incoming format:                             ** 
.................... **  hr11mn52$ (11:52 a.m)                               ** 
.................... *********************************************************/ 
.................... void GetOffTime(int Id, byte* DateTime) 
.................... { 
138C:  MOV     W5,[W15++]
138E:  CLR     9A0
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1390:  CLR.B   9C8
1392:  MOV     #800,W4
1394:  MOV     W4,9C4
1396:  MOV     #15E,W4
1398:  MOV     W4,9C6
139A:  CALL    7FA
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
139E:  MOV     #0,W1
13A0:  MOV     W1,W0
13A2:  CALL    1A4
13A6:  INC     W1,W1
13A8:  MOV     W1,[W15++]
13AA:  BTSC.B  20F.1
13AC:  BRA     13AA
13AE:  MOV     W0,210
13B0:  MOV     [--W15],W1
13B2:  MOV     #A,W0
13B4:  CPSGT   W1,W0
13B6:  BRA     13A0
.................... 	ReadBuffer(InputBuffer); 
13B8:  MOV     #800,W4
13BA:  MOV     W4,9C4
13BC:  CALL    81A
.................... 	delay_ms(ptime); 
13C0:  MOV     95E,W0
13C2:  CALL    50A
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
13C6:  CLR.B   9C8
13C8:  MOV     #800,W4
13CA:  MOV     W4,9C4
13CC:  MOV     #15E,W4
13CE:  MOV     W4,9C6
13D0:  CALL    7FA
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
13D4:  MOV     #0,W1
13D6:  MOV     W1,W0
13D8:  CALL    1BC
13DC:  INC     W1,W1
13DE:  MOV     W1,[W15++]
13E0:  BTSC.B  20F.1
13E2:  BRA     13E0
13E4:  MOV     W0,210
13E6:  MOV     [--W15],W1
13E8:  MOV     #30,W0
13EA:  CPSGT   W1,W0
13EC:  BRA     13D6
.................... 	ReadBuffer(InputBuffer); 
13EE:  MOV     #800,W4
13F0:  MOV     W4,9C4
13F2:  CALL    81A
.................... 	delay_ms(ptime); 
13F6:  MOV     95E,W0
13F8:  CALL    50A
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
13FC:  CLR.B   9C8
13FE:  MOV     #800,W4
1400:  MOV     W4,9C4
1402:  MOV     #15E,W4
1404:  MOV     W4,9C6
1406:  CALL    7FA
.................... 	printf("GET /TIMEGPRS/OFFTIME/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
140A:  MOV     #0,W1
140C:  MOV     W1,W0
140E:  CALL    2AA
1412:  INC     W1,W1
1414:  MOV     W1,[W15++]
1416:  BTSC.B  20F.1
1418:  BRA     1416
141A:  MOV     W0,210
141C:  MOV     [--W15],W1
141E:  MOV     #15,W0
1420:  CPSGT   W1,W0
1422:  BRA     140C
1424:  MOV     99C,W0
1426:  MOV     #0,W4
1428:  CALL    B26
142C:  MOV     #18,W1
142E:  MOV     W1,W0
1430:  CALL    2AA
1434:  INC     W1,W1
1436:  MOV     W1,[W15++]
1438:  BTSC.B  20F.1
143A:  BRA     1438
143C:  MOV     W0,210
143E:  MOV     [--W15],W1
1440:  MOV     #44,W0
1442:  CPSGT   W1,W0
1444:  BRA     142E
....................     do 
....................     { 
....................         InputBuffer[index]=getc();	 
1446:  MOV     #800,W4
1448:  MOV     9A0,W3
144A:  ADD     W3,W4,W5
144C:  BTSS.B  20E.0
144E:  BRA     144C
1450:  MOV     212,W0
1452:  MOV.B   W0L,[W5]
.................... 		index++; 
1454:  INC     09A0
....................     }while(index<350 && InputBuffer[index-1]!='$'); 
1456:  MOV     9A0,W4
1458:  MOV     #15E,W3
145A:  CP      W3,W4
145C:  BRA     LE,146C
145E:  MOV     9A0,W4
1460:  SUB     W4,#1,W5
1462:  MOV     #800,W4
1464:  ADD     W5,W4,W0
1466:  MOV.B   [W0],W4L
1468:  XOR.B   #24,W4L
146A:  BRA     NZ,1446
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
146C:  MOV     #800,W4
146E:  MOV     W4,9AC
1470:  PUSH    9A0
1472:  POP     9AE
1474:  CALL    89A
1478:  MOV     W0,W5
147A:  CP      W5,#1
147C:  BRA     NZ,14BA
.................... 		{ 
.................... 			*(DateTime+3)=(int)GetDecVal(InputBuffer,index,'h','r'); 
147E:  MOV     99E,W4
1480:  ADD     W4,#3,W4
1482:  MOV     W4,W0
1484:  MOV     W0,W5
1486:  MOV.B   #68,W0L
1488:  MOV.B   W0L,9B4
148A:  MOV.B   #72,W0L
148C:  MOV.B   W0L,9B5
148E:  MOV     #800,W4
1490:  MOV     W4,9B0
1492:  PUSH    9A0
1494:  POP     9B2
1496:  CALL    C20
149A:  MOV.B   W0L,[W5]
.................... 			*(DateTime+4)=(int)GetDecVal(InputBuffer,index,'m','n'); 
149C:  MOV     99E,W4
149E:  ADD     W4,#4,W4
14A0:  MOV     W4,W0
14A2:  MOV     W0,W5
14A4:  MOV.B   #6D,W0L
14A6:  MOV.B   W0L,9B4
14A8:  MOV.B   #6E,W0L
14AA:  MOV.B   W0L,9B5
14AC:  MOV     #800,W4
14AE:  MOV     W4,9B0
14B0:  PUSH    9A0
14B2:  POP     9B2
14B4:  CALL    C20
14B8:  MOV.B   W0L,[W5]
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
14BA:  MOV     #32,W0
14BC:  CALL    50A
.................... 	printf("+"); 
14C0:  BTSC.B  20F.1
14C2:  BRA     14C0
14C4:  MOV     #2B,W4
14C6:  MOV     W4,210
.................... 	printf("+"); 
14C8:  BTSC.B  20F.1
14CA:  BRA     14C8
14CC:  MOV     #2B,W4
14CE:  MOV     W4,210
.................... 	printf("+"); 
14D0:  BTSC.B  20F.1
14D2:  BRA     14D0
14D4:  MOV     #2B,W4
14D6:  MOV     W4,210
.................... 	OERR=16; 
14D8:  MOV.B   #10,W0L
14DA:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
14DC:  MOV     #800,W4
14DE:  MOV     W4,9C4
14E0:  CALL    81A
.................... 	delay_ms(50); 
14E4:  MOV     #32,W0
14E6:  CALL    50A
.................... 	ClosePort(1); 
14EA:  MOV     #1,W4
14EC:  MOV     W4,9C0
14EE:  CALL    C96
.................... } 
14F2:  MOV     [--W15],W5
14F4:  RETURN  
....................  
.................... /***********GetMode*************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void GetMode(int Id, int* mod,int state) 
.................... { 
*
1024:  MOV     W5,[W15++]
1026:  CLR     9A2
1028:  CLR     9A4
.................... 	int status=0; 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
102A:  CLR.B   9C8
102C:  MOV     #800,W4
102E:  MOV     W4,9C4
1030:  MOV     #15E,W4
1032:  MOV     W4,9C6
1034:  CALL    7FA
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
1038:  MOV     #0,W1
103A:  MOV     W1,W0
103C:  CALL    1A4
1040:  INC     W1,W1
1042:  MOV     W1,[W15++]
1044:  BTSC.B  20F.1
1046:  BRA     1044
1048:  MOV     W0,210
104A:  MOV     [--W15],W1
104C:  MOV     #A,W0
104E:  CPSGT   W1,W0
1050:  BRA     103A
.................... 	ReadBuffer(InputBuffer); 
1052:  MOV     #800,W4
1054:  MOV     W4,9C4
1056:  CALL    81A
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
105A:  MOV     95E,W0
105C:  CALL    50A
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1060:  CLR.B   9C8
1062:  MOV     #800,W4
1064:  MOV     W4,9C4
1066:  MOV     #15E,W4
1068:  MOV     W4,9C6
106A:  CALL    7FA
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
106E:  MOV     #0,W1
1070:  MOV     W1,W0
1072:  CALL    1BC
1076:  INC     W1,W1
1078:  MOV     W1,[W15++]
107A:  BTSC.B  20F.1
107C:  BRA     107A
107E:  MOV     W0,210
1080:  MOV     [--W15],W1
1082:  MOV     #30,W0
1084:  CPSGT   W1,W0
1086:  BRA     1070
.................... 	ReadBuffer(InputBuffer); 
1088:  MOV     #800,W4
108A:  MOV     W4,9C4
108C:  CALL    81A
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	//if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	//else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
1090:  MOV     95E,W0
1092:  CALL    50A
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1096:  CLR.B   9C8
1098:  MOV     #800,W4
109A:  MOV     W4,9C4
109C:  MOV     #15E,W4
109E:  MOV     W4,9C6
10A0:  CALL    7FA
.................... 	printf("GET /DEVICEGPRS/GETMODE/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
10A4:  MOV     #0,W1
10A6:  MOV     W1,W0
10A8:  CALL    2F6
10AC:  INC     W1,W1
10AE:  MOV     W1,[W15++]
10B0:  BTSC.B  20F.1
10B2:  BRA     10B0
10B4:  MOV     W0,210
10B6:  MOV     [--W15],W1
10B8:  MOV     #17,W0
10BA:  CPSGT   W1,W0
10BC:  BRA     10A6
10BE:  MOV     99C,W0
10C0:  MOV     #0,W4
10C2:  CALL    B26
10C6:  MOV     #1A,W1
10C8:  MOV     W1,W0
10CA:  CALL    2F6
10CE:  INC     W1,W1
10D0:  MOV     W1,[W15++]
10D2:  BTSC.B  20F.1
10D4:  BRA     10D2
10D6:  MOV     W0,210
10D8:  MOV     [--W15],W1
10DA:  MOV     #46,W0
10DC:  CPSGT   W1,W0
10DE:  BRA     10C8
.................... 	while(getc()!='\n'); 
10E0:  BTSS.B  20E.0
10E2:  BRA     10E0
10E4:  MOV     212,W0
10E6:  CP.B    W0L,#A
10E8:  BRA     NZ,10E0
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
10EA:  MOV     #800,W4
10EC:  MOV     9A4,W3
10EE:  ADD     W3,W4,W5
10F0:  BTSS.B  20E.0
10F2:  BRA     10F0
10F4:  MOV     212,W0
10F6:  MOV.B   W0L,[W5]
.................... 		index++; 
10F8:  INC     09A4
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
10FA:  MOV     9A4,W4
10FC:  MOV     #15E,W3
10FE:  CP      W3,W4
1100:  BRA     LE,1110
1102:  MOV     9A4,W4
1104:  SUB     W4,#1,W5
1106:  MOV     #800,W4
1108:  ADD     W5,W4,W0
110A:  MOV.B   [W0],W4L
110C:  XOR.B   #24,W4L
110E:  BRA     NZ,10EA
....................  
.................... 	OERR=16; 
1110:  MOV.B   #10,W0L
1112:  MOV.B   W0L,20E
.................... 	//PrintBuffer(InputBuffer,ptime); 
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
1114:  MOV     #800,W4
1116:  MOV     W4,9AC
1118:  PUSH    9A4
111A:  POP     9AE
111C:  CALL    89A
1120:  MOV     W0,W5
1122:  CP      W5,#1
1124:  BRA     NZ,1142
.................... 		{ 
.................... 			*mod=(int)GetDecVal(InputBuffer,index,'m','d'); 
1126:  MOV     99E,W5
1128:  MOV.B   #6D,W0L
112A:  MOV.B   W0L,9B4
112C:  MOV.B   #64,W0L
112E:  MOV.B   W0L,9B5
1130:  MOV     #800,W4
1132:  MOV     W4,9B0
1134:  PUSH    9A4
1136:  POP     9B2
1138:  CALL    C20
113C:  MOV     W0,[W5]
.................... 			status=1; 
113E:  MOV     #1,W4
1140:  MOV     W4,9A2
.................... 		} 
....................  
.................... 	//**************GET REQUEST TO OBTAIN STATUS************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1142:  CLR.B   9C8
1144:  MOV     #800,W4
1146:  MOV     W4,9C4
1148:  MOV     #15E,W4
114A:  MOV     W4,9C6
114C:  CALL    7FA
.................... 	index=0; 
1150:  CLR     9A4
.................... 	printf("GET /DEVICEGPRS/GETSTATUS/%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id); 
1152:  MOV     #0,W1
1154:  MOV     W1,W0
1156:  CALL    342
115A:  INC     W1,W1
115C:  MOV     W1,[W15++]
115E:  BTSC.B  20F.1
1160:  BRA     115E
1162:  MOV     W0,210
1164:  MOV     [--W15],W1
1166:  MOV     #19,W0
1168:  CPSGT   W1,W0
116A:  BRA     1154
116C:  MOV     99C,W0
116E:  MOV     #0,W4
1170:  CALL    B26
1174:  MOV     #1C,W1
1176:  MOV     W1,W0
1178:  CALL    342
117C:  INC     W1,W1
117E:  MOV     W1,[W15++]
1180:  BTSC.B  20F.1
1182:  BRA     1180
1184:  MOV     W0,210
1186:  MOV     [--W15],W1
1188:  MOV     #48,W0
118A:  CPSGT   W1,W0
118C:  BRA     1176
.................... 	while(getc()!='\n'); 
118E:  BTSS.B  20E.0
1190:  BRA     118E
1192:  MOV     212,W0
1194:  CP.B    W0L,#A
1196:  BRA     NZ,118E
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1198:  MOV     #800,W4
119A:  MOV     9A4,W3
119C:  ADD     W3,W4,W5
119E:  BTSS.B  20E.0
11A0:  BRA     119E
11A2:  MOV     212,W0
11A4:  MOV.B   W0L,[W5]
.................... 		index++; 
11A6:  INC     09A4
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
11A8:  MOV     9A4,W4
11AA:  MOV     #15E,W3
11AC:  CP      W3,W4
11AE:  BRA     LE,11BE
11B0:  MOV     9A4,W4
11B2:  SUB     W4,#1,W5
11B4:  MOV     #800,W4
11B6:  ADD     W5,W4,W0
11B8:  MOV.B   [W0],W4L
11BA:  XOR.B   #24,W4L
11BC:  BRA     NZ,1198
....................  
.................... 	if(ValidateCommand(InputBuffer,index)==1)  
11BE:  MOV     #800,W4
11C0:  MOV     W4,9AC
11C2:  PUSH    9A4
11C4:  POP     9AE
11C6:  CALL    89A
11CA:  MOV     W0,W5
11CC:  CP      W5,#1
11CE:  BRA     NZ,11EC
.................... 		{ 
.................... 			*state=(int)GetDecVal(InputBuffer,index,'s','t'); 
11D0:  MOV     9A0,W5
11D2:  MOV.B   #73,W0L
11D4:  MOV.B   W0L,9B4
11D6:  MOV.B   #74,W0L
11D8:  MOV.B   W0L,9B5
11DA:  MOV     #800,W4
11DC:  MOV     W4,9B0
11DE:  PUSH    9A4
11E0:  POP     9B2
11E2:  CALL    C20
11E6:  MOV.B   W0L,[W5]
.................... 			status=1; 
11E8:  MOV     #1,W4
11EA:  MOV     W4,9A2
.................... 		} 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
11EC:  MOV     #32,W0
11EE:  CALL    50A
.................... 	printf("+"); 
11F2:  BTSC.B  20F.1
11F4:  BRA     11F2
11F6:  MOV     #2B,W4
11F8:  MOV     W4,210
.................... 	printf("+"); 
11FA:  BTSC.B  20F.1
11FC:  BRA     11FA
11FE:  MOV     #2B,W4
1200:  MOV     W4,210
.................... 	printf("+"); 
1202:  BTSC.B  20F.1
1204:  BRA     1202
1206:  MOV     #2B,W4
1208:  MOV     W4,210
.................... 	OERR=16; 
120A:  MOV.B   #10,W0L
120C:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
120E:  MOV     #800,W4
1210:  MOV     W4,9C4
1212:  CALL    81A
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	delay_ms(50); 
1216:  MOV     #32,W0
1218:  CALL    50A
.................... 	ClosePort(1); 
121C:  MOV     #1,W4
121E:  MOV     W4,9C0
1220:  CALL    C96
.................... } 
1224:  MOV     [--W15],W5
1226:  RETURN  
....................  
.................... /***********ReportData************************************ 
.................... **   Description: Connects to server to report the      ** 
.................... **     current consuptions of current and voltage       ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void ReportData(int Id, int state,float curr,float volt) 
.................... { 
*
1E82:  MOV     W5,[W15++]
1E84:  CLR     9B2
.................... 	int16 index=0; 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1E86:  CLR.B   9C8
1E88:  MOV     #800,W4
1E8A:  MOV     W4,9C4
1E8C:  MOV     #15E,W4
1E8E:  MOV     W4,9C6
1E90:  CALL    7FA
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
1E94:  MOV     #0,W1
1E96:  MOV     W1,W0
1E98:  CALL    1A4
1E9C:  INC     W1,W1
1E9E:  MOV     W1,[W15++]
1EA0:  BTSC.B  20F.1
1EA2:  BRA     1EA0
1EA4:  MOV     W0,210
1EA6:  MOV     [--W15],W1
1EA8:  MOV     #A,W0
1EAA:  CPSGT   W1,W0
1EAC:  BRA     1E96
.................... 	ReadBuffer(InputBuffer); 
1EAE:  MOV     #800,W4
1EB0:  MOV     W4,9C4
1EB2:  CALL    81A
.................... 	delay_ms(ptime); 
1EB6:  MOV     95E,W0
1EB8:  CALL    50A
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
1EBC:  CLR.B   9C8
1EBE:  MOV     #800,W4
1EC0:  MOV     W4,9C4
1EC2:  MOV     #15E,W4
1EC4:  MOV     W4,9C6
1EC6:  CALL    7FA
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
1ECA:  MOV     #0,W1
1ECC:  MOV     W1,W0
1ECE:  CALL    1BC
1ED2:  INC     W1,W1
1ED4:  MOV     W1,[W15++]
1ED6:  BTSC.B  20F.1
1ED8:  BRA     1ED6
1EDA:  MOV     W0,210
1EDC:  MOV     [--W15],W1
1EDE:  MOV     #30,W0
1EE0:  CPSGT   W1,W0
1EE2:  BRA     1ECC
.................... 	ReadBuffer(InputBuffer); 
1EE4:  MOV     #800,W4
1EE6:  MOV     W4,9C4
1EE8:  CALL    81A
.................... 	delay_ms(ptime); 
1EEC:  MOV     95E,W0
1EEE:  CALL    50A
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer /monitoringgprs/create?id=14&status=0&current=1&voltage=2 
1EF2:  CLR.B   9C8
1EF4:  MOV     #800,W4
1EF6:  MOV     W4,9C4
1EF8:  MOV     #15E,W4
1EFA:  MOV     W4,9C6
1EFC:  CALL    7FA
.................... 	printf("GET /MONITORINGGPRS/CREATE?ID=%d&STATUS=%d&CURRENT=%6.3f&VOLTAGE=%6.3f HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id,state,curr,volt); 
1F00:  MOV     #0,W1
1F02:  MOV     W1,W0
1F04:  CALL    390
1F08:  INC     W1,W1
1F0A:  MOV     W1,[W15++]
1F0C:  BTSC.B  20F.1
1F0E:  BRA     1F0C
1F10:  MOV     W0,210
1F12:  MOV     [--W15],W1
1F14:  MOV     #1D,W0
1F16:  CPSGT   W1,W0
1F18:  BRA     1F02
1F1A:  MOV     9A6,W0
1F1C:  MOV     #0,W4
1F1E:  CALL    B26
1F22:  MOV     #20,W1
1F24:  MOV     W1,W0
1F26:  CALL    390
1F2A:  INC     W1,W1
1F2C:  MOV     W1,[W15++]
1F2E:  BTSC.B  20F.1
1F30:  BRA     1F2E
1F32:  MOV     W0,210
1F34:  MOV     [--W15],W1
1F36:  MOV     #27,W0
1F38:  CPSGT   W1,W0
1F3A:  BRA     1F24
1F3C:  MOV     9A8,W0
1F3E:  MOV     #0,W4
1F40:  CALL    B26
1F44:  MOV     #2A,W1
1F46:  MOV     W1,W0
1F48:  CALL    390
1F4C:  INC     W1,W1
1F4E:  MOV     W1,[W15++]
1F50:  BTSC.B  20F.1
1F52:  BRA     1F50
1F54:  MOV     W0,210
1F56:  MOV     [--W15],W1
1F58:  MOV     #32,W0
1F5A:  CPSGT   W1,W0
1F5C:  BRA     1F46
1F5E:  MOV     9AC,W2
1F60:  MOV     9AA,W1
1F62:  MOV     #0,W0
1F64:  CALL    1738
1F68:  MOV     #3,W9
1F6A:  MOV     #5,W10
1F6C:  CALL    1D00
1F70:  MOV     #38,W1
1F72:  MOV     W1,W0
1F74:  CALL    390
1F78:  INC     W1,W1
1F7A:  MOV     W1,[W15++]
1F7C:  BTSC.B  20F.1
1F7E:  BRA     1F7C
1F80:  MOV     W0,210
1F82:  MOV     [--W15],W1
1F84:  MOV     #40,W0
1F86:  CPSGT   W1,W0
1F88:  BRA     1F72
1F8A:  MOV     9B0,W2
1F8C:  MOV     9AE,W1
1F8E:  MOV     #0,W0
1F90:  CALL    1738
1F94:  MOV     #3,W9
1F96:  MOV     #5,W10
1F98:  CALL    1D00
1F9C:  MOV     #46,W1
1F9E:  MOV     W1,W0
1FA0:  CALL    390
1FA4:  INC     W1,W1
1FA6:  MOV     W1,[W15++]
1FA8:  BTSC.B  20F.1
1FAA:  BRA     1FA8
1FAC:  MOV     W0,210
1FAE:  MOV     [--W15],W1
1FB0:  MOV     #72,W0
1FB2:  CPSGT   W1,W0
1FB4:  BRA     1F9E
.................... 		//printf("GET /MONITORINGGPRS/CREATE?ID=9&STATUS=1&CURRENT=6&VOLTAGE=6 HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n"); 
.................... 	while(getc()!='\n'); 
1FB6:  BTSS.B  20E.0
1FB8:  BRA     1FB6
1FBA:  MOV     212,W0
1FBC:  CP.B    W0L,#A
1FBE:  BRA     NZ,1FB6
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
1FC0:  MOV     #800,W4
1FC2:  MOV     9B2,W3
1FC4:  ADD     W3,W4,W5
1FC6:  BTSS.B  20E.0
1FC8:  BRA     1FC6
1FCA:  MOV     212,W0
1FCC:  MOV.B   W0L,[W5]
.................... 		index++; 
1FCE:  INC     09B2
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
1FD0:  MOV     9B2,W4
1FD2:  MOV     #15E,W3
1FD4:  CP      W3,W4
1FD6:  BRA     LE,1FE6
1FD8:  MOV     9B2,W4
1FDA:  SUB     W4,#1,W5
1FDC:  MOV     #800,W4
1FDE:  ADD     W5,W4,W0
1FE0:  MOV.B   [W0],W4L
1FE2:  XOR.B   #24,W4L
1FE4:  BRA     NZ,1FC0
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
1FE6:  MOV     #32,W0
1FE8:  CALL    50A
.................... 	printf("+"); 
1FEC:  BTSC.B  20F.1
1FEE:  BRA     1FEC
1FF0:  MOV     #2B,W4
1FF2:  MOV     W4,210
.................... 	printf("+"); 
1FF4:  BTSC.B  20F.1
1FF6:  BRA     1FF4
1FF8:  MOV     #2B,W4
1FFA:  MOV     W4,210
.................... 	printf("+"); 
1FFC:  BTSC.B  20F.1
1FFE:  BRA     1FFC
2000:  MOV     #2B,W4
2002:  MOV     W4,210
.................... 	OERR=16; 
2004:  MOV.B   #10,W0L
2006:  MOV.B   W0L,20E
.................... 	ReadBuffer(InputBuffer); 
2008:  MOV     #800,W4
200A:  MOV     W4,9C4
200C:  CALL    81A
.................... 	delay_ms(50); 
2010:  MOV     #32,W0
2012:  CALL    50A
.................... 	ClosePort(1); 
2016:  MOV     #1,W4
2018:  MOV     W4,9C0
201A:  CALL    C96
.................... 	delay_ms(5000); 
201E:  MOV     #1388,W0
2020:  CALL    50A
.................... } 
2024:  MOV     [--W15],W5
2026:  RETURN  
....................  
.................... /***********CreateAlert*********************************** 
.................... **   Description: Connects to server to report the      ** 
.................... **     current alert detected by the device             ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... void CreateAlert(int Id, int type) 
.................... { 
.................... 	int16 index=0; 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("AT+AIPA=1\r\n");        //Conect to internet 
.................... 	ReadBuffer(InputBuffer); 
.................... 	PrintBuffer(InputBuffer,ptime); 
.................... 	if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
....................  
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer 
.................... 	printf("AT+AIPO=1,,\"www.serverdeus.somee.com\",80,0,,1,2\r\n");  //Conect to server 
.................... 	ReadBuffer(InputBuffer); 
.................... 	PrintBuffer(InputBuffer,ptime); 
.................... 	if(ValidateCommand(InputBuffer,30)==1) lcd_putc("\fCMD OK"); 
.................... 	else lcd_putc("\fCMD BAD"); 
.................... 	delay_ms(ptime); 
....................  
.................... 	//**************GET REQUEST TO OBTAIN MODE**************** 
.................... 	FillArray(InputBuffer,350,0);  //Clear input_buffer /monitoringgprs/create?id=14&status=0&current=1&voltage=2 
.................... 	printf("GET /ALERTGGPRS/CREATE?ID=%d&TYPE=%d HTTP/1.1\r\nHost: www.serverdeus.somee.com\r\n\r\n",Id,type); 
.................... 	while(getc()!='\n'); 
.................... 	do 
.................... 	{ 
.................... 		InputBuffer[index]=getc(); 
.................... 		index++; 
.................... 	}while(index<350 && InputBuffer[index-1]!='$'); 
....................  
.................... 	//***Close data connection************ 
.................... 	delay_ms(50); 
.................... 	printf("+++\r\n"); 
.................... 	OERR=16; 
.................... 	//PrintBuffer(InputBuffer,ptime); 
.................... 	PrintBuffer(InputBuffer,1000); 
....................  
.................... 	ClosePort(1); 
.................... } 
.................... /***********Read ADC************************************** 
.................... **   Description: Connects to server to obtain the      ** 
.................... **     current datetime of the specified device         ** 
.................... **                                                      ** 
.................... *********************************************************/ 
.................... int16 ReadADC(int channel,int delay, int16 samples) 
.................... { 
*
152E:  CLR     9A2
1530:  CLR     9A4
.................... 	int sample=0; 
.................... 	int16 measure=0; 
.................... 	set_adc_channel(channel); 
1532:  PUSH    99C
1534:  POP     2A6
.................... 	for(sample=0;sample<samples;sample++)	 
1536:  CLR     9A2
1538:  MOV     9A2,W0
153A:  MOV     9A0,W4
153C:  CP      W4,W0
153E:  BRA     LE,1556
.................... 	{ 
.................... 		measure=measure+read_ADC(); 
1540:  BCLR.B  2A0.0
1542:  BSET.B  2A0.1
1544:  BTSS.B  2A0.0
1546:  BRA     1544
1548:  MOV     280,W0
154A:  ADD     9A4
.................... 		delay_us(delay); 
154C:  MOV     99E,W0
154E:  CALL    151C
.................... 	} 
1552:  INC     09A2
1554:  BRA     1538
.................... 	measure=measure/samples; 
1556:  MOV     9A4,W4
1558:  MOV     9A0,W3
155A:  REPEAT  #11
155C:  DIV.S   W4,W3
155E:  MOV     W0,9A4
.................... return measure;	 
1560:  PUSH    9A4
1562:  POP     0
.................... } 
1564:  RETURN  
....................  
....................  
.................... /******************Global variables***********************/ 
.................... int operation_mode=0,lamp_status=1,lamp_statusw=1,alert_status=0;//,alert_type; 
.................... //int port_status=0,port_statusw=0; //New variables used in new operation mode 
.................... int lamp1=0,lamp2=0; 
.................... //int set_point=0,histeresys=0; 
.................... int16 Device_Id=21,loops=0; 
....................  
.................... float current=0,battery=0,temp=0,s1=0,s2=0,reference=0; 
....................  
.................... byte DateTime[6]={0,2,13,8,30,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
*
21D2:  MOV     #200,W4
21D4:  MOV     W4,988
21D6:  MOV     #80D,W4
21D8:  MOV     W4,98A
21DA:  MOV     #1E,W4
21DC:  MOV     W4,98C
.................... //byte RiseTime[6]={25,2,13,19,27,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
.................... //byte SetTime[6]={25,2,13,19,29,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
.................... byte dow1=0; 
....................  
.................... /*struct ADC_Channels 
.................... { 
.................... 	float value; 
.................... 	char  name[10]; 
.................... 	char  unit[4];	 
....................  
.................... }ADC_Channels[7];*/ 
....................  
.................... //new datetime variables for new operation mode 
.................... byte OnTime[6]={25,2,13,19,27,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
21DE:  MOV     #219,W4
21E0:  MOV     W4,990
21E2:  MOV     #130D,W4
21E4:  MOV     W4,992
21E6:  MOV     #1B,W4
21E8:  MOV     W4,994
.................... byte OffTime[6]={25,2,13,19,29,0}; //day=1,month=2,year=13,hour=8,minute=30,second=0 (1/feb/2013 08:30:00) 
21EA:  MOV     #219,W4
21EC:  MOV     W4,996
21EE:  MOV     #130D,W4
21F0:  MOV     W4,998
21F2:  MOV     #1D,W4
21F4:  MOV     W4,99A
....................  
.................... /******************Main function, program****************/ 
.................... void main(void) 
.................... {	 
*
2028:  BSET.B  81.7
202A:  MOV     #8000,W4
202C:  MOV     W4,20C
202E:  MOV     #400,W4
2030:  MOV     W4,20E
2032:  MOV     #3,W4
2034:  MOV     W4,214
2036:  MOV     #64,W4
2038:  MOV     W4,95E
203A:  CLR     960
203C:  MOV     #1,W4
203E:  MOV     W4,962
2040:  MOV     #1,W4
2042:  MOV     W4,964
2044:  CLR     966
2046:  CLR     968
2048:  CLR     96A
204A:  MOV     #15,W4
204C:  MOV     W4,96C
204E:  CLR     96E
2050:  CLR     970
2052:  CLR     972
2054:  CLR     974
2056:  CLR     976
2058:  CLR     978
205A:  CLR     97A
205C:  CLR     97C
205E:  CLR     97E
2060:  CLR     980
2062:  CLR     982
2064:  CLR     984
2066:  CLR     986
2068:  CLR.B   98E
206A:  SETM    2A8
206C:  MOV     #F80,W15
206E:  MOV     #FFF,W0
2070:  MOV     W0,20
2072:  NOP     
.................... 	//***Component initializers**** 
.................... 	lcd_init();        //LCD INITIALIZE 
*
21F6:  CALL    63C
.................... 	//init_dac();      //MPC4921 DAC INITIALIZE 
.................... 	rtc_init();		   //DS1302 RTC INITIALIZE 
21FA:  CALL    740
.................... 	//***Device initialize********* 
.................... 	lcd_putc("\fTelegestion UTCH"); 
21FE:  MOV     #0,W5
2200:  MOV     W5,W0
2202:  CALL    3FA
2206:  IOR.B   #0,W0L
2208:  BTSC.B  42.1
220A:  BRA     2216
220C:  INC     W5,W5
220E:  MOV.B   W0L,9AC
2210:  CALL    7AE
2214:  BRA     2200
.................... 	delay_ms(100); 
2216:  MOV     #64,W0
2218:  CALL    50A
.................... 	setup_adc_ports(sAN0|sAN1|sAN2|sAN3|sAN4|sAN5|sAN6);//*******Setup CH0-CH6 as ADC 
221C:  MOV     #FF80,W4
221E:  MOV     W4,2A8
2220:  CLR     2A2
.................... 	setup_adc(ADC_CLOCK_INTERNAL); 
2222:  MOV     #80,W4
2224:  MOV     W4,2A4
2226:  MOV     #80E0,W4
2228:  MOV     W4,2A0
.................... 	//******Configure PORTB*********** 
.................... 	SET_TRIS_B(0x007F);   //PB0-PB6 as input, PB7-PB15 as output 
222A:  MOV     #7F,W4
222C:  MOV     W4,2C6
.................... 	//******Clear RS232 error********** 
.................... 	OERR=16; 
222E:  MOV.B   #10,W0L
2230:  MOV.B   W0L,20E
.................... 	//******Configure GPRS device****** 
.................... 	ConfigureGPRS(); 
2232:  CALL    8D4
.................... 	//******Set datetime***************** 
.................... 	switch(ConfigureDatetime(Device_Id, DateTime)) 
.................... 	{ 
2236:  PUSH    96C
2238:  POP     99C
223A:  MOV     #988,W4
223C:  MOV     W4,99E
223E:  CALL    CE0
2242:  XOR     #0,W0
2244:  BRA     Z,224C
2246:  XOR     #1,W0
2248:  BRA     Z,2266
224A:  BRA     231C
.................... 		case 0: 
.................... 			lcd_putc("\fCMD BAD"); 
224C:  MOV     #0,W5
224E:  MOV     W5,W0
2250:  CALL    14A
2254:  IOR.B   #0,W0L
2256:  BTSC.B  42.1
2258:  BRA     2264
225A:  INC     W5,W5
225C:  MOV.B   W0L,9AC
225E:  CALL    7AE
2262:  BRA     224E
.................... 		break; 
2264:  BRA     2336
.................... 		case 1: 
.................... 			rtc_set_datetime(DateTime[day_],DateTime[month_],DateTime[year_],dow1,DateTime[hour_],DateTime[min_]); 
2266:  MOV.B   988,W0L
2268:  MOV.B   W0L,99C
226A:  MOV.B   989,W0L
226C:  MOV.B   W0L,99D
226E:  MOV.B   98A,W0L
2270:  MOV.B   W0L,99E
2272:  MOV.B   98E,W0L
2274:  MOV.B   W0L,99F
2276:  MOV.B   98B,W0L
2278:  MOV.B   W0L,9A0
227A:  MOV.B   98C,W0L
227C:  MOV.B   W0L,9A1
227E:  CALL    E8C
.................... 			lcd_putc("\f"); 
2282:  MOV     #0,W5
2284:  MOV     W5,W0
2286:  CALL    110
228A:  IOR.B   #0,W0L
228C:  BTSC.B  42.1
228E:  BRA     229A
2290:  INC     W5,W5
2292:  MOV.B   W0L,9AC
2294:  CALL    7AE
2298:  BRA     2284
.................... 			lcd_putc("Datetime:\n"); 
229A:  MOV     #0,W5
229C:  MOV     W5,W0
229E:  CALL    418
22A2:  IOR.B   #0,W0L
22A4:  BTSC.B  42.1
22A6:  BRA     22B2
22A8:  INC     W5,W5
22AA:  MOV.B   W0L,9AC
22AC:  CALL    7AE
22B0:  BRA     229C
.................... 			printf(lcd_putc,"%d/%d/20%d %02d:%02d",DateTime[day_],DateTime[month_],DateTime[year_],DateTime[hour_],DateTime[min_]); 
22B2:  MOV.B   988,W0L
22B4:  SE      W0,W0
22B6:  MOV     #0,W4
22B8:  CALL    F2A
22BC:  MOV.B   #2F,W0L
22BE:  MOV.B   W0L,9AC
22C0:  CALL    7AE
22C4:  MOV.B   989,W0L
22C6:  SE      W0,W0
22C8:  MOV     #0,W4
22CA:  CALL    F2A
22CE:  MOV.B   #2F,W0L
22D0:  MOV.B   W0L,9AC
22D2:  CALL    7AE
22D6:  MOV.B   #32,W0L
22D8:  MOV.B   W0L,9AC
22DA:  CALL    7AE
22DE:  MOV.B   #30,W0L
22E0:  MOV.B   W0L,9AC
22E2:  CALL    7AE
22E6:  MOV.B   98A,W0L
22E8:  SE      W0,W0
22EA:  MOV     #0,W4
22EC:  CALL    F2A
22F0:  MOV.B   #20,W0L
22F2:  MOV.B   W0L,9AC
22F4:  CALL    7AE
22F8:  MOV.B   98B,W0L
22FA:  SE      W0,W0
22FC:  MOV     #8002,W4
22FE:  CALL    F2A
2302:  MOV.B   #3A,W0L
2304:  MOV.B   W0L,9AC
2306:  CALL    7AE
230A:  MOV.B   98C,W0L
230C:  SE      W0,W0
230E:  MOV     #8002,W4
2310:  CALL    F2A
.................... 			delay_ms(1000); 
2314:  MOV     #3E8,W0
2316:  CALL    50A
.................... 		break; 
231A:  BRA     2336
.................... 		default: 
.................... 			lcd_putc("\fCMD BAD"); 
231C:  MOV     #0,W5
231E:  MOV     W5,W0
2320:  CALL    14A
2324:  IOR.B   #0,W0L
2326:  BTSC.B  42.1
2328:  BRA     2334
232A:  INC     W5,W5
232C:  MOV.B   W0L,9AC
232E:  CALL    7AE
2332:  BRA     231E
.................... 		break; 
2334:  BRA     2336
....................  
.................... 	} 
.................... 	//ClosePort(1); 
.................... 	//***While loop, main program starts here*** 
.................... 	while(TRUE) 
.................... 	{//*****Start of while loop**************        
.................... 		for(loops=0;loops<4;loops++) 
2336:  CLR     96E
2338:  MOV     96E,W4
233A:  CP      W4,#4
233C:  BRA     GE,28AA
.................... 		{//*****Start of for loop************** 
.................... 			//**********BUZZER******************** 
.................... 			output_bit(PIN_D9,alert_status);  //BUZZER depend of alert state 
233E:  CP0     966
2340:  BRA     NZ,2346
2342:  BCLR.B  2D7.1
2344:  BRA     2348
2346:  BSET.B  2D7.1
2348:  BCLR.B  2D3.1
.................... 			//**********GPO*********************** 
.................... 			//******Get status/mode*********************** 
.................... 			lcd_putc("\fGetting data\nfrom server.+."); 
234A:  MOV     #0,W5
234C:  MOV     W5,W0
234E:  CALL    430
2352:  IOR.B   #0,W0L
2354:  BTSC.B  42.1
2356:  BRA     2362
2358:  INC     W5,W5
235A:  MOV.B   W0L,9AC
235C:  CALL    7AE
2360:  BRA     234C
.................... 			GetMode(Device_Id,&operation_mode,&lamp_statusw);	 
2362:  PUSH    96C
2364:  POP     99C
2366:  MOV     #960,W4
2368:  MOV     W4,99E
236A:  MOV     #964,W4
236C:  MOV     W4,9A0
236E:  CALL    1024
.................... 			delay_ms(1500);		 
2372:  MOV     #5DC,W0
2374:  CALL    50A
.................... 			switch(operation_mode) 
.................... 			{ 
2378:  MOV     960,W0
237A:  XOR     #1,W0
237C:  BRA     Z,2388
237E:  XOR     #2,W0
2380:  BRA     Z,23E8
2382:  XOR     #1,W0
2384:  BRA     Z,23EA
2386:  BRA     23F8
.................... 				case Timmer_Mode: 
.................... 					GetOnTime(Device_Id,OnTime); 
2388:  PUSH    96C
238A:  POP     99C
238C:  MOV     #990,W4
238E:  MOV     W4,99E
2390:  CALL    1228
.................... 					GetOffTime(Device_Id,OffTime); 
2394:  PUSH    96C
2396:  POP     99C
2398:  MOV     #996,W4
239A:  MOV     W4,99E
239C:  CALL    138C
.................... 					if(DateTime[hour_]==OnTime[hour_]&&((DateTime[min_]>=OnTime[min_])&&(DateTime[min_]<=(OnTime[min_]+1)))) lamp_status=1; 
23A0:  MOV.B   98B,W0L
23A2:  CP.B    993
23A4:  BRA     NZ,23C0
23A6:  MOV.B   994,W0L
23A8:  MOV     98C,W4
23AA:  CP.B    W4L,W0L
23AC:  BRA     NC,23C0
23AE:  MOV     994,W4
23B0:  ADD.B   W4L,#1,W4L
23B2:  MOV.B   W4L,W0L
23B4:  MOV.B   W0L,0
23B6:  MOV     98C,W4
23B8:  CP.B    W4L,W0L
23BA:  BRA     GTU,23C0
23BC:  MOV     #1,W4
23BE:  MOV     W4,962
.................... 					if(DateTime[hour_]==OffTime[hour_]&&((DateTime[min_]>=OffTime[min_])&&(DateTime[min_]<=(OffTime[min_]+1)))) lamp_status=0; 
23C0:  MOV.B   98B,W0L
23C2:  CP.B    999
23C4:  BRA     NZ,23DE
23C6:  MOV.B   99A,W0L
23C8:  MOV     98C,W4
23CA:  CP.B    W4L,W0L
23CC:  BRA     NC,23DE
23CE:  MOV     99A,W4
23D0:  ADD.B   W4L,#1,W4L
23D2:  MOV.B   W4L,W0L
23D4:  MOV.B   W0L,0
23D6:  MOV     98C,W4
23D8:  CP.B    W4L,W0L
23DA:  BRA     GTU,23DE
23DC:  CLR     962
.................... 					lamp1= lamp_status; lamp2=lamp_status; 
23DE:  PUSH    962
23E0:  POP     968
23E2:  PUSH    962
23E4:  POP     96A
.................... 				break;	 
23E6:  BRA     23FA
.................... 				case Automated_Mode: 
.................... 					//if(S1>set_point+histeresys) lamp_status=0; 
.................... 					//if(S1<set_point-histeresys) lamp_status=1; 
.................... 				break;	 
23E8:  BRA     23FA
.................... 				case Manual_Mode: 
.................... 					lamp_status=lamp_statusw; 
23EA:  PUSH    964
23EC:  POP     962
.................... 					lamp1= lamp_status; lamp2=lamp_status; 
23EE:  PUSH    962
23F0:  POP     968
23F2:  PUSH    962
23F4:  POP     96A
.................... 				break;	 
23F6:  BRA     23FA
.................... 				default: 
.................... 				break; 
23F8:  BRA     23FA
.................... 			}						 
.................... 			output_bit(PIN_B7,lamp1);	output_bit(PIN_B8,lamp2);					 
23FA:  CP0     968
23FC:  BRA     NZ,2402
23FE:  BCLR.B  2CA.7
2400:  BRA     2404
2402:  BSET.B  2CA.7
2404:  MOV     #7E,W4
2406:  MOV     W4,2C6
2408:  CP0     96A
240A:  BRA     NZ,2410
240C:  BCLR.B  2CB.0
240E:  BRA     2412
2410:  BSET.B  2CB.0
2412:  MOV     #7E,W4
2414:  MOV     W4,2C6
.................... 			//******RTC Get and show datetime***** 
.................... 			lcd_putc("\f"); 
2416:  MOV     #0,W5
2418:  MOV     W5,W0
241A:  CALL    110
241E:  IOR.B   #0,W0L
2420:  BTSC.B  42.1
2422:  BRA     242E
2424:  INC     W5,W5
2426:  MOV.B   W0L,9AC
2428:  CALL    7AE
242C:  BRA     2418
.................... 			lcd_putc("Datetime:\n"); 
242E:  MOV     #0,W5
2430:  MOV     W5,W0
2432:  CALL    418
2436:  IOR.B   #0,W0L
2438:  BTSC.B  42.1
243A:  BRA     2446
243C:  INC     W5,W5
243E:  MOV.B   W0L,9AC
2440:  CALL    7AE
2444:  BRA     2430
.................... 			rtc_get_date(DateTime[day_],DateTime[month_],DateTime[year_],dow1); 
.................... 			rtc_get_time(DateTime[hour_],DateTime[min_],DateTime[sec_]); 
.................... 			printf(lcd_putc,"%d/%d/20%d %02d:%02d",DateTime[day_],DateTime[month_],DateTime[year_],DateTime[hour_],DateTime[min_]); 
*
24E0:  MOV.B   988,W0L
24E2:  SE      W0,W0
24E4:  MOV     #0,W4
24E6:  CALL    F2A
24EA:  MOV.B   #2F,W0L
24EC:  MOV.B   W0L,9AC
24EE:  CALL    7AE
24F2:  MOV.B   989,W0L
24F4:  SE      W0,W0
24F6:  MOV     #0,W4
24F8:  CALL    F2A
24FC:  MOV.B   #2F,W0L
24FE:  MOV.B   W0L,9AC
2500:  CALL    7AE
2504:  MOV.B   #32,W0L
2506:  MOV.B   W0L,9AC
2508:  CALL    7AE
250C:  MOV.B   #30,W0L
250E:  MOV.B   W0L,9AC
2510:  CALL    7AE
2514:  MOV.B   98A,W0L
2516:  SE      W0,W0
2518:  MOV     #0,W4
251A:  CALL    F2A
251E:  MOV.B   #20,W0L
2520:  MOV.B   W0L,9AC
2522:  CALL    7AE
2526:  MOV.B   98B,W0L
2528:  SE      W0,W0
252A:  MOV     #8002,W4
252C:  CALL    F2A
2530:  MOV.B   #3A,W0L
2532:  MOV.B   W0L,9AC
2534:  CALL    7AE
2538:  MOV.B   98C,W0L
253A:  SE      W0,W0
253C:  MOV     #8002,W4
253E:  CALL    F2A
.................... 			delay_ms(2000); 
2542:  MOV     #7D0,W0
2544:  CALL    50A
....................  
.................... 			//******Get and show status/mode******* 
.................... 			lcd_putc("\f"); 
2548:  MOV     #0,W5
254A:  MOV     W5,W0
254C:  CALL    110
2550:  IOR.B   #0,W0L
2552:  BTSC.B  42.1
2554:  BRA     2560
2556:  INC     W5,W5
2558:  MOV.B   W0L,9AC
255A:  CALL    7AE
255E:  BRA     254A
.................... 			printf(lcd_putc,"Mode: %d\nStatus: %d",operation_mode,lamp_status); 
2560:  MOV     #0,W1
2562:  MOV     W1,W0
2564:  CALL    45A
2568:  INC     W1,W1
256A:  MOV     W1,[W15++]
256C:  MOV.B   W0L,9AC
256E:  CALL    7AE
2572:  MOV     [--W15],W1
2574:  MOV     #5,W0
2576:  CPSGT   W1,W0
2578:  BRA     2562
257A:  MOV     960,W0
257C:  MOV     #0,W4
257E:  CALL    F2A
2582:  MOV     #8,W1
2584:  MOV     W1,W0
2586:  CALL    45A
258A:  INC     W1,W1
258C:  MOV     W1,[W15++]
258E:  MOV.B   W0L,9AC
2590:  CALL    7AE
2594:  MOV     [--W15],W1
2596:  MOV     #10,W0
2598:  CPSGT   W1,W0
259A:  BRA     2584
259C:  MOV     962,W0
259E:  MOV     #0,W4
25A0:  CALL    F2A
.................... 			delay_ms(2000); 
25A4:  MOV     #7D0,W0
25A6:  CALL    50A
....................  
.................... 			//******Get and show ADC values*** 
.................... 			temp=ReadADC(TEMP_ch,100,10); 
25AA:  CLR     99C
25AC:  MOV     #64,W4
25AE:  MOV     W4,99E
25B0:  MOV     #A,W4
25B2:  MOV     W4,9A0
25B4:  CALL    152E
25B8:  CALL    1566
25BC:  MOV     W0,978
25BE:  MOV     W1,97A
.................... 			current=ReadADC(CURRENT_ch,100,10); 
25C0:  MOV     #1,W4
25C2:  MOV     W4,99C
25C4:  MOV     #64,W4
25C6:  MOV     W4,99E
25C8:  MOV     #A,W4
25CA:  MOV     W4,9A0
25CC:  CALL    152E
25D0:  CALL    1566
25D4:  MOV     W0,970
25D6:  MOV     W1,972
.................... 			s1=ReadADC(SENSOR1_ch,100,10); 
25D8:  MOV     #3,W4
25DA:  MOV     W4,99C
25DC:  MOV     #64,W4
25DE:  MOV     W4,99E
25E0:  MOV     #A,W4
25E2:  MOV     W4,9A0
25E4:  CALL    152E
25E8:  CALL    1566
25EC:  MOV     W0,97C
25EE:  MOV     W1,97E
.................... 			s2=ReadADC(SENSOR2_ch,100,10); 
25F0:  MOV     #4,W4
25F2:  MOV     W4,99C
25F4:  MOV     #64,W4
25F6:  MOV     W4,99E
25F8:  MOV     #A,W4
25FA:  MOV     W4,9A0
25FC:  CALL    152E
2600:  CALL    1566
2604:  MOV     W0,980
2606:  MOV     W1,982
.................... 			reference=ReadADC(REFERENCE_ch,100,10); 
2608:  MOV     #6,W4
260A:  MOV     W4,99C
260C:  MOV     #64,W4
260E:  MOV     W4,99E
2610:  MOV     #A,W4
2612:  MOV     W4,9A0
2614:  CALL    152E
2618:  CALL    1566
261C:  MOV     W0,984
261E:  MOV     W1,986
.................... 			battery=ReadADC(POWER_ch,100,10); 
2620:  MOV     #5,W4
2622:  MOV     W4,99C
2624:  MOV     #64,W4
2626:  MOV     W4,99E
2628:  MOV     #A,W4
262A:  MOV     W4,9A0
262C:  CALL    152E
2630:  CALL    1566
2634:  MOV     W0,974
2636:  MOV     W1,976
....................  
.................... 			reference=0.412/reference; 
2638:  MOV     #F1AA,W0
263A:  MOV     #3ED2,W1
263C:  MOV     984,W2
263E:  MOV     986,W3
2640:  CALL    15B0
2644:  MOV     W0,984
2646:  MOV     W1,986
.................... 			temp=(temp*reference)*1000; 
2648:  MOV     978,W0
264A:  MOV     97A,W1
264C:  MOV     984,W2
264E:  MOV     986,W3
2650:  CALL    167A
2654:  MOV     W0,W5
2656:  MOV     W1,W6
2658:  MOV     W5,W0
265A:  MOV     W6,W1
265C:  MOV     #0,W2
265E:  MOV     #447A,W3
2660:  CALL    167A
2664:  MOV     W0,978
2666:  MOV     W1,97A
.................... 			current=(current*reference)*1000; 
2668:  MOV     970,W0
266A:  MOV     972,W1
266C:  MOV     984,W2
266E:  MOV     986,W3
2670:  CALL    167A
2674:  MOV     W0,W5
2676:  MOV     W1,W6
2678:  MOV     W5,W0
267A:  MOV     W6,W1
267C:  MOV     #0,W2
267E:  MOV     #447A,W3
2680:  CALL    167A
2684:  MOV     W0,970
2686:  MOV     W1,972
.................... 			battery=(battery*reference)*3.11;	 
2688:  MOV     974,W0
268A:  MOV     976,W1
268C:  MOV     984,W2
268E:  MOV     986,W3
2690:  CALL    167A
2694:  MOV     W0,W5
2696:  MOV     W1,W6
2698:  MOV     W5,W0
269A:  MOV     W6,W1
269C:  MOV     #A3D,W2
269E:  MOV     #4047,W3
26A0:  CALL    167A
26A4:  MOV     W0,974
26A6:  MOV     W1,976
.................... 			s1=s1*reference/.165; 	//165 Ohms resitor in serie with sensor, (v/165)*1000 (in mA) 
26A8:  MOV     97C,W0
26AA:  MOV     97E,W1
26AC:  MOV     984,W2
26AE:  MOV     986,W3
26B0:  CALL    167A
26B4:  MOV     W0,W5
26B6:  MOV     W1,W6
26B8:  MOV     W5,W0
26BA:  MOV     W6,W1
26BC:  MOV     #F5C3,W2
26BE:  MOV     #3E28,W3
26C0:  CALL    15B0
26C4:  MOV     W0,97C
26C6:  MOV     W1,97E
.................... 			s2=s2*reference/.165;	//165 Ohms resitor in serie with sensor, (v/165)*1000 (in mA) 
26C8:  MOV     980,W0
26CA:  MOV     982,W1
26CC:  MOV     984,W2
26CE:  MOV     986,W3
26D0:  CALL    167A
26D4:  MOV     W0,W5
26D6:  MOV     W1,W6
26D8:  MOV     W5,W0
26DA:  MOV     W6,W1
26DC:  MOV     #F5C3,W2
26DE:  MOV     #3E28,W3
26E0:  CALL    15B0
26E4:  MOV     W0,980
26E6:  MOV     W1,982
....................  
.................... 			lcd_putc("\f"); 
26E8:  MOV     #0,W5
26EA:  MOV     W5,W0
26EC:  CALL    110
26F0:  IOR.B   #0,W0L
26F2:  BTSC.B  42.1
26F4:  BRA     2700
26F6:  INC     W5,W5
26F8:  MOV.B   W0L,9AC
26FA:  CALL    7AE
26FE:  BRA     26EA
.................... 			printf(lcd_putc,"Battery= %6.3fv",battery); 
2700:  MOV     #0,W1
2702:  MOV     W1,W0
2704:  CALL    47A
2708:  INC     W1,W1
270A:  MOV     W1,[W15++]
270C:  MOV.B   W0L,9AC
270E:  CALL    7AE
2712:  MOV     [--W15],W1
2714:  MOV     #8,W0
2716:  CPSGT   W1,W0
2718:  BRA     2702
271A:  MOV     976,W2
271C:  MOV     974,W1
271E:  MOV     #0,W0
2720:  CALL    1738
2724:  MOV     #3,W9
2726:  MOV     #5,W10
2728:  CALL    1976
272C:  MOV.B   #76,W0L
272E:  MOV.B   W0L,9AC
2730:  CALL    7AE
.................... 			delay_ms(LCD_Delay); 
2734:  MOV     #7D0,W0
2736:  CALL    50A
.................... 			lcd_putc("\f"); 
273A:  MOV     #0,W5
273C:  MOV     W5,W0
273E:  CALL    110
2742:  IOR.B   #0,W0L
2744:  BTSC.B  42.1
2746:  BRA     2752
2748:  INC     W5,W5
274A:  MOV.B   W0L,9AC
274C:  CALL    7AE
2750:  BRA     273C
.................... 			printf(lcd_putc,"Current: %6.3fmV\nTemperature: %6.3fmV",current,temp);//1.1,1.1);//current,temp); 
2752:  MOV     #0,W1
2754:  MOV     W1,W0
2756:  CALL    496
275A:  INC     W1,W1
275C:  MOV     W1,[W15++]
275E:  MOV.B   W0L,9AC
2760:  CALL    7AE
2764:  MOV     [--W15],W1
2766:  MOV     #8,W0
2768:  CPSGT   W1,W0
276A:  BRA     2754
276C:  MOV     972,W2
276E:  MOV     970,W1
2770:  MOV     #0,W0
2772:  CALL    1738
2776:  MOV     #3,W9
2778:  MOV     #5,W10
277A:  CALL    1976
277E:  MOV     #E,W1
2780:  MOV     W1,W0
2782:  CALL    496
2786:  INC     W1,W1
2788:  MOV     W1,[W15++]
278A:  MOV.B   W0L,9AC
278C:  CALL    7AE
2790:  MOV     [--W15],W1
2792:  MOV     #1D,W0
2794:  CPSGT   W1,W0
2796:  BRA     2780
2798:  MOV     97A,W2
279A:  MOV     978,W1
279C:  MOV     #0,W0
279E:  CALL    1738
27A2:  MOV     #3,W9
27A4:  MOV     #5,W10
27A6:  CALL    1976
27AA:  MOV.B   #6D,W0L
27AC:  MOV.B   W0L,9AC
27AE:  CALL    7AE
27B2:  MOV.B   #56,W0L
27B4:  MOV.B   W0L,9AC
27B6:  CALL    7AE
.................... 			delay_ms(LCD_Delay); 
27BA:  MOV     #7D0,W0
27BC:  CALL    50A
.................... 			lcd_putc("\f"); 
27C0:  MOV     #0,W5
27C2:  MOV     W5,W0
27C4:  CALL    110
27C8:  IOR.B   #0,W0L
27CA:  BTSC.B  42.1
27CC:  BRA     27D8
27CE:  INC     W5,W5
27D0:  MOV.B   W0L,9AC
27D2:  CALL    7AE
27D6:  BRA     27C2
.................... 			printf(lcd_putc,"Reference= %6.3f",reference); 
27D8:  MOV     #0,W1
27DA:  MOV     W1,W0
27DC:  CALL    4C8
27E0:  INC     W1,W1
27E2:  MOV     W1,[W15++]
27E4:  MOV.B   W0L,9AC
27E6:  CALL    7AE
27EA:  MOV     [--W15],W1
27EC:  MOV     #A,W0
27EE:  CPSGT   W1,W0
27F0:  BRA     27DA
27F2:  MOV     986,W2
27F4:  MOV     984,W1
27F6:  MOV     #0,W0
27F8:  CALL    1738
27FC:  MOV     #3,W9
27FE:  MOV     #5,W10
2800:  CALL    1976
.................... 			delay_ms(LCD_Delay); 
2804:  MOV     #7D0,W0
2806:  CALL    50A
.................... 			lcd_putc("\f"); 
280A:  MOV     #0,W5
280C:  MOV     W5,W0
280E:  CALL    110
2812:  IOR.B   #0,W0L
2814:  BTSC.B  42.1
2816:  BRA     2822
2818:  INC     W5,W5
281A:  MOV.B   W0L,9AC
281C:  CALL    7AE
2820:  BRA     280C
.................... 			printf(lcd_putc,"S1: %6.3fmA\nS2: %6.3fmA",s1,s2); 
2822:  MOV     #0,W1
2824:  MOV     W1,W0
2826:  CALL    4E6
282A:  INC     W1,W1
282C:  MOV     W1,[W15++]
282E:  MOV.B   W0L,9AC
2830:  CALL    7AE
2834:  MOV     [--W15],W1
2836:  MOV     #3,W0
2838:  CPSGT   W1,W0
283A:  BRA     2824
283C:  MOV     97E,W2
283E:  MOV     97C,W1
2840:  MOV     #0,W0
2842:  CALL    1738
2846:  MOV     #3,W9
2848:  MOV     #5,W10
284A:  CALL    1976
284E:  MOV     #9,W1
2850:  MOV     W1,W0
2852:  CALL    4E6
2856:  INC     W1,W1
2858:  MOV     W1,[W15++]
285A:  MOV.B   W0L,9AC
285C:  CALL    7AE
2860:  MOV     [--W15],W1
2862:  MOV     #F,W0
2864:  CPSGT   W1,W0
2866:  BRA     2850
2868:  MOV     982,W2
286A:  MOV     980,W1
286C:  MOV     #0,W0
286E:  CALL    1738
2872:  MOV     #3,W9
2874:  MOV     #5,W10
2876:  CALL    1976
287A:  MOV.B   #6D,W0L
287C:  MOV.B   W0L,9AC
287E:  CALL    7AE
2882:  MOV.B   #41,W0L
2884:  MOV.B   W0L,9AC
2886:  CALL    7AE
.................... 			delay_ms(LCD_Delay); 
288A:  MOV     #7D0,W0
288C:  CALL    50A
....................  
.................... 			if(battery<6.3) alert_status=1; 
2890:  MOV     974,W0
2892:  MOV     976,W1
2894:  MOV     #999A,W2
2896:  MOV     #40C9,W3
2898:  CALL    1AF8
289C:  BRA     NC,28A4
289E:  MOV     #1,W4
28A0:  MOV     W4,966
.................... 			else alert_status=0; 
28A2:  BRA     28A6
28A4:  CLR     966
.................... 		}//*****End of for loop************** 
28A6:  INC     096E
28A8:  BRA     2338
.................... 		ReportData(Device_Id,lamp_status,(current+100),(battery+100));//1,1.1,1.1); 
28AA:  BCLR.B  43.0
28AC:  MOV     970,W0
28AE:  MOV     972,W1
28B0:  MOV     #0,W2
28B2:  MOV     #42C8,W3
28B4:  CALL    1B60
28B8:  MOV     W0,W5
28BA:  MOV     W1,W6
28BC:  BCLR.B  43.0
28BE:  MOV     974,W0
28C0:  MOV     976,W1
28C2:  MOV     #0,W2
28C4:  MOV     #42C8,W3
28C6:  CALL    1B60
28CA:  MOV     W0,W7
28CC:  MOV     W1,W8
28CE:  PUSH    96C
28D0:  POP     9A6
28D2:  PUSH    962
28D4:  POP     9A8
28D6:  MOV     W5,9AA
28D8:  MOV     W6,9AC
28DA:  MOV     W7,9AE
28DC:  MOV     W8,9B0
28DE:  CALL    1E82
.................... 	}//*****End of while loop************** 
28E2:  BRA     2336
.................... } 
28E4:  PWRSAV  #0

Configuration Fuses:
   Word  1L: C701   NOCKSFSM FRC_PLL4 PR_PLL
          H: 0000  
   Word  2L: 003F   NOWDT WPSB16 WPSA512
          H: 0000  
   Word  3L: 0733   PUT64 NOBROWNOUT BORRES LPOL_HIGH HPOL_HIGH NOPWMPIN NOMCLR
          H: 0000  
   Word  4L: 310F  
          H: 0000  
   Word  5L: 330F  
          H: 0000  
   Word  6L: 0007   NOPROTECT NOWRT
          H: 0000  
   Word  7L: C003   NODEBUG NOCOE ICSP1
          H: 0000  
